Index: app/src/main/java/com/dou361/jjdxm_ijkplayer/remotecontrol/RemoteControl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.dou361.jjdxm_ijkplayer.remotecontrol;\r\n\r\nimport android.annotation.SuppressLint;\r\nimport android.app.Activity;\r\nimport android.app.AlertDialog;\r\nimport android.content.Context;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.res.AssetManager;\r\nimport android.content.res.Configuration;\r\nimport android.os.Bundle;\r\nimport android.os.CountDownTimer;\r\nimport android.os.Environment;\r\nimport android.os.Handler;\r\nimport android.os.Message;\r\nimport android.os.PowerManager;\r\nimport android.util.Log;\r\nimport android.view.MotionEvent;\r\nimport android.view.View;\r\nimport android.widget.AdapterView;\r\nimport android.widget.Button;\r\nimport android.widget.ImageButton;\r\nimport android.widget.ImageView;\r\nimport android.widget.Spinner;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.activity.OnBackPressedCallback;\r\n\r\nimport com.alibaba.fastjson.JSON;\r\nimport com.bumptech.glide.Glide;\r\nimport com.dou361.ijkplayer.bean.VideoijkBean;\r\nimport com.dou361.ijkplayer.listener.OnPlayerBackListener;\r\nimport com.dou361.ijkplayer.listener.OnPlayerStartOrPauseListener;\r\nimport com.dou361.ijkplayer.listener.OnShowThumbnailListener;\r\nimport com.dou361.ijkplayer.widget.PlayStateParams;\r\nimport com.dou361.ijkplayer.widget.PlayerView;\r\nimport com.dou361.jjdxm_ijkplayer.MainActivity;\r\nimport com.dou361.jjdxm_ijkplayer.R;\r\nimport com.dou361.jjdxm_ijkplayer.command.Control;\r\nimport com.dou361.jjdxm_ijkplayer.command.Gears;\r\nimport com.dou361.jjdxm_ijkplayer.command.Handbrake;\r\nimport com.dou361.jjdxm_ijkplayer.command.Video;\r\nimport com.dou361.jjdxm_ijkplayer.mqtt.MQTTRequest;\r\nimport com.dou361.jjdxm_ijkplayer.mqtt.MQTTSample;\r\nimport com.dou361.jjdxm_ijkplayer.videomonitoring.VideoMonitor;\r\nimport com.dou361.jjdxm_ijkplayer.videomonitoring.utlis.MediaUtils;\r\nimport com.tencent.iot.hub.device.android.core.log.TXMqttLogCallBack;\r\nimport com.tencent.iot.hub.device.android.core.util.TXLog;\r\nimport com.tencent.iot.hub.device.java.core.common.Status;\r\nimport com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;\r\n\r\n\r\nimport org.eclipse.paho.client.mqttv3.IMqttToken;\r\nimport org.eclipse.paho.client.mqttv3.MqttMessage;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.nio.charset.Charset;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\nimport static android.os.SystemClock.uptimeMillis;\r\n\r\n/**\r\n 遥控车辆进行移动\r\n */\r\npublic class RemoteControl extends Activity {\r\n\r\n    public String hostIP = /*\"192.168.0.108:18081\";*/\"10.6.206.20:30549\";\r\n    public String userId = \"6D的安卓測試機\";\r\n    public String vin = \"001\";\r\n\r\n    private final static String mLogPath = Environment.getExternalStorageDirectory().getPath() + \"/tencent/\";\r\n\r\n    public CountDownTimer countDownTimer;\r\n    private MainActivity mParent;\r\n    private MQTTSample mqttSample;\r\n\r\n    private PlayerView player;\r\n    private Context mContext;\r\n    private TextView  Speed;\r\n    private List<VideoijkBean> list;\r\n    private PowerManager.WakeLock wakeLock;\r\n    private View rootView;\r\n    private Activity mActivity;\r\n\r\n    private static final String TAG = \"FullscreenActivity\";\r\n    private boolean braking = true;\r\n    private int gearGlobal=0;\r\n    private int handBrakeStatus = 0;\r\n    private Button LlightingButton;\r\n    private ImageButton imageButton_forward,imageButton_backward;\r\n    private ImageView app_video_play;\r\n    private Spinner Video_Modul_Spinner;\r\n\r\n    private double wheelAngle=0.0;\r\n    private double speed=0.0;\r\n\r\n\r\n\r\n    /*虛擬機*/\r\n    private String mBrokerURL = \"ssl://fawtsp-mqtt-public-dev.faw.cn:8883\";  //传入null，即使用腾讯云物联网通信默认地址 \"${ProductId}.iotcloud.tencentdevices.com:8883\"  https://cloud.tencent.com/document/product/634/32546\r\n    private String mProductID = \"2N8PWJAI0V\";\r\n    private String mDevName = \"android_test_phone\";\r\n    private String mDevPSK  = \"KdV+RSnHAlmEpM75aWZQZg==\"; //若使用证书验证，设为null\r\n    private String mTestTopic = \"2N8PWJAI0V/android_test_phone/data\";\r\n\r\n    /*OPPO A57t*/\r\n/*    private String mBrokerURL = \"ssl://fawtsp-mqtt-public-dev.faw.cn:8883\";  //传入null，即使用腾讯云物联网通信默认地址 \"${ProductId}.iotcloud.tencentdevices.com:8883\"  https://cloud.tencent.com/document/product/634/32546\r\n    private String mProductID = \"2N8PWJAI0V\";\r\n    private String mDevName = \"OPPOA57t\";\r\n    private String mDevPSK  = \"TbtnFhJDmRe7N41vDBRVtA==\"; //若使用证书验证，设为null\r\n    private String mTestTopic = \"2N8PWJAI0V/OPPOA57t/data\";  */  // productID/DeviceName/TopicName\r\n\r\n    /*真车配置*/\r\n    /*private String mBrokerURL = \"ssl://fawtsp-mqtt-public-dev.faw.cn:8883\";\r\n    private String mProductID = \"KM8UZXZOV9\";\r\n    private String mDevName = \"android_test\";\r\n    private String mDevPSK  = \"+xRWqTlp0UPbwSKXVgiNxA==\"; //若使用证书验证，设为null\r\n    private String mTestTopic = \"KM8UZXZOV9/android_test/data\";    // productID/DeviceName/TopicName\r\n*/    private String mSubProductID = \"\"; // If you wont test gateway, let this to be null\r\n    private String mSubDevName = \"\";\r\n    private String mSubDevPsk = \"BuildConfig.SUB_DEVICE_PSK\";\r\n    private String mDevCertName = \"YOUR_DEVICE_NAME_cert.crt\";\r\n    private String mDevKeyName  = \"YOUR_DEVICE_NAME_private.key\";\r\n    private String mProductKey = \"BuildConfig.PRODUCT_KEY\";        // Used for dynamic register\r\n    private String mDevCert = \"\";           // Cert String\r\n    private String mDevPriv = \"\";           // Priv String\r\n\r\n    private volatile boolean mIsConnected=false;\r\n    ScalableImageView sImgView ;\r\n\r\n    @SuppressLint(\"InvalidWakeLockTag\")\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        Log.d(TAG, \"onCreate: \");\r\n        super.onCreate(savedInstanceState);\r\n        this.mContext = this;\r\n        this.mActivity = this;\r\n        rootView = getLayoutInflater().from(this).inflate(R.layout.activity_remote_control, null);\r\n\r\n        setContentView(rootView);\r\n\r\n        if (!mIsConnected) {\r\n            Log.d(TAG, \"onCreate: Connecting Mqtt\");\r\n            //轮询连接,万分感谢陈岩大佬\r\n            mqttSample= new MQTTSample(getApplication(), new SelfMqttActionCallBack(), mBrokerURL, mProductID, mDevName, mDevPSK,\r\n                    mDevCert, mDevPriv, mSubProductID, mSubDevName, mTestTopic, null, null, true, new SelfMqttLogCallBack());\r\n            Log.d(TAG, \"onCreate: mqttSample\"+mqttSample.toString());\r\n            mqttSample.connect();\r\n            sleep(2000);}\r\n        mqttSample.subscribeTopic();\r\n\r\n\r\n        shiftHandbrake(1);\r\n        Log.d(TAG, \"onCreate: \");\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                 while (true) {\r\n                     if(braking){\r\n                    try {\r\n\r\n                        moveVehicle(-0.1,0.0,wheelAngle);\r\n                        sleep(50);\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }}\r\n            }\r\n        }}).start();\r\n\r\n        /**常亮*/\r\n        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);\r\n        wakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, \"liveTAG\");\r\n        wakeLock.acquire();\r\n\r\n        CompentOnTouch compentOnTouch = new CompentOnTouch();\r\n\r\n        imageButton_forward=findViewById(R.id.forward);\r\n        imageButton_forward.setOnTouchListener(compentOnTouch);\r\n\r\n        imageButton_backward=findViewById(R.id.backward);\r\n        imageButton_backward.setOnTouchListener(compentOnTouch);\r\n        sImgView = findViewById(R.id.steering_wheel);\r\n\r\n        //方向盘角度在速度处显示\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while(true){\r\n                    wheelAngle = sImgView.getmDegree();\r\n                }\r\n            }\r\n        }).start();\r\n\r\n        countDownTimer=new CountDownTimer(100000,200) {\r\n            @Override\r\n            public void onTick(long millisUntilFinished) {\r\n                Speed = findViewById(R.id.speed);\r\n                Speed.setText(String.valueOf((int)wheelAngle));\r\n            }\r\n            @Override\r\n            public void onFinish() {\r\n            }\r\n        }.start();\r\n\r\n        //下拉单选按钮\r\n        Video_Modul_Spinner = (Spinner)findViewById(R.id.Spinner_VIdeo_Model);\r\n        Video_Modul_Spinner.setSelection(0);//进入不会自动播放\r\n        Video_Modul_Spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){\r\n            @Override\r\n            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\r\n                    String result = parent.getItemAtPosition(position).toString();\r\n                    Toast.makeText(RemoteControl.this, result, Toast.LENGTH_SHORT).show();\r\n                    switch (position) {\r\n                        case 0: {\r\n                            /**前摄像*/\r\n                            list = new ArrayList<VideoijkBean>();\r\n                            String url1 = \"http://ivi.bupt.edu.cn/hls/cctv13.m3u8\";\r\n                            String url2 = \"rtmp://150.158.176.170/live/test_vin_1\";\r\n                            VideoijkBean m1 = new VideoijkBean();\r\n                            m1.setStream(\"原始视频\");\r\n                            m1.setUrl(url1);\r\n                            VideoijkBean m2 = new VideoijkBean();\r\n                            m2.setStream(\"融合视频\");\r\n                            m2.setUrl(url2);\r\n                            list.add(m1);\r\n                            list.add(m2);\r\n                            player = new PlayerView(mActivity, rootView)\r\n                                    .setProcessDurationOrientation(PlayStateParams.PROCESS_PORTRAIT)\r\n                                    .setScaleType(PlayStateParams.fillparent) //视频界面剪裁设置\r\n                                    .forbidTouch(false)\r\n                                    .hideSteam(false)\r\n                                    .hideMenu(false)\r\n                                    .hideCenterPlayer(true)\r\n                                    .hideBack(false)\r\n                                    .setOnlyFullScreen(true)\r\n                                    .setNetWorkTypeTie(false)\r\n                                    .hideRotation(true)\r\n                                    .hideFullscreen(true)\r\n                                    .setChargeTie(true, 480)//设置最长播放时间\r\n                                    .showThumbnail(new OnShowThumbnailListener() {\r\n                                        @Override\r\n                                        public void onShowThumbnail(ImageView ivThumbnail) {\r\n//                                 加载前显示的缩略图\r\n                                            Glide.with(mContext)\r\n                                                    .load(R.drawable.pic_before_video)\r\n                                                    .placeholder(R.drawable.pic_before_video) //加载成功之前占位图\r\n                                                    .error(R.color.cl_error)//加载错误之后的错误图\r\n                                                    .into(ivThumbnail);\r\n                                        }\r\n                                    })\r\n                                    .setPlayerBackListener(new OnPlayerBackListener() {\r\n                            @Override\r\n                            public void onPlayerBack() {\r\n                                //对话框\r\n                                AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                builder.setIcon(R.drawable.shangbackground);\r\n                                builder.setTitle(\"结束挪车\");//设置对话框的标题\r\n                                builder.setMessage(\"您已确定车辆已经抵达目标位置并结束挪车操作吗？\");//设置对话框的内容\r\n                                builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        finish();\r\n                                        Intent intent=new Intent(RemoteControl.this, MainActivity.class);\r\n                                        startActivity(intent);\r\n                                    }\r\n                                });\r\n                                builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        Toast.makeText(RemoteControl.this, \"取消成功\",Toast.LENGTH_SHORT).show();\r\n                                        player.startPlay();\r\n                                    }\r\n                                });\r\n                                AlertDialog b=builder.create();\r\n                                b.show();\r\n                                player.onPause();\r\n\r\n                            }\r\n                        })\r\n                                    .setPlayerStartOrPauseListener(new OnPlayerStartOrPauseListener() {\r\n                                        @Override\r\n                                        public void onStartOrPause() {\r\n                                            //对话框\r\n                                            AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                            builder.setIcon(R.drawable.shangbackground);\r\n                                            builder.setTitle(\"暂停挪车\");//设置对话框的标题\r\n                                            builder.setMessage(\"挪车已暂停，是否继续挪车？\");//设置对话框的内容\r\n                                            builder.setPositiveButton(\"继续\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    player.startPlay();\r\n                                                }\r\n                                            });\r\n                                            builder.setNegativeButton(\"结束\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    finish();\r\n                                                    Intent intent=new Intent(RemoteControl.this,MainActivity.class);\r\n                                                    startActivity(intent);\r\n                                                }\r\n                                            });\r\n                                            AlertDialog b=builder.create();\r\n                                            b.show();\r\n                                        }\r\n                                    })\r\n                                    .setPlaySource(list)\r\n                                    .startPlay();\r\n                        }\r\n                        break;\r\n\r\n                        case 1: {\r\n                            /**后摄像*/\r\n                            String url3 = \"http://ivi.bupt.edu.cn/hls/cctv2.m3u8\";\r\n                            playVideoUrl(url3);\r\n                        }\r\n                        break;\r\n\r\n                        case 2: {\r\n                            /**左摄像*/\r\n                            String url4 = \"http://ivi.bupt.edu.cn/hls/cctv3.m3u8\";\r\n                            playVideoUrl(url4);\r\n                        }\r\n                        break;\r\n\r\n                        case 3: {\r\n                            /**右摄像*/\r\n                            String url5 = \"http://ivi.bupt.edu.cn/hls/cctv4.m3u8\";\r\n                            playVideoUrl(url5);\r\n\r\n                        }\r\n                        break;\r\n\r\n                        case 4: {\r\n                            /**上帝*/\r\n                            String url6 = \"http://ivi.bupt.edu.cn/hls/cctv13.m3u8\";\r\n                            playVideoUrl(url6);\r\n                        }\r\n                        break;\r\n\r\n                        default:\r\n                            break;\r\n                    }\r\n\r\n            }\r\n            @Override\r\n            public void onNothingSelected(AdapterView<?> parent) { }\r\n        });\r\n\r\n    }\r\n\r\n    //后四个视频播放器播放\r\n    public  void playVideoUrl( String url){\r\n        player = new PlayerView(mActivity, rootView)\r\n                .setProcessDurationOrientation(PlayStateParams.PROCESS_PORTRAIT)\r\n                .setScaleType(PlayStateParams.fillparent) //视频界面剪裁设置\r\n                .forbidTouch(false)\r\n                .hideSteam(true)\r\n                .hideMenu(true)\r\n                .hideCenterPlayer(true)\r\n                .hideBack(false)\r\n                .setOnlyFullScreen(true)\r\n                .setNetWorkTypeTie(false)\r\n                .hideRotation(true)\r\n                .hideFullscreen(true)\r\n                .setChargeTie(true, 480)//设置最长播放时间\r\n                .showThumbnail(new OnShowThumbnailListener() {\r\n                    @Override\r\n                    public void onShowThumbnail(ImageView ivThumbnail) {\r\n//                                 加载前显示的缩略图\r\n                        Glide.with(mContext)\r\n                                .load(R.drawable.pic_before_video)\r\n                                .placeholder(R.drawable.pic_before_video) //加载成功之前占位图\r\n                                .error(R.color.cl_error)//加载错误之后的错误图\r\n                                .into(ivThumbnail);\r\n                    }\r\n                })\r\n                .setPlayerBackListener(new OnPlayerBackListener() {\r\n                    @Override\r\n                    public void onPlayerBack() {\r\n                        //对话框\r\n                        AlertDialog.Builder builder = new AlertDialog.Builder(mContext);\r\n                        builder.setIcon(R.drawable.shangbackground);\r\n                        builder.setTitle(\"结束挪车\");//设置对话框的标题\r\n                        builder.setMessage(\"您已确定车辆已经抵达目标位置并结束挪车操作吗？\");//设置对话框的内容\r\n                        builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                            @Override\r\n                            public void onClick(DialogInterface arg0, int arg1) {\r\n                                finish();\r\n                                Intent intent = new Intent(RemoteControl.this, MainActivity.class);\r\n                                startActivity(intent);\r\n                            }\r\n                        });\r\n                        builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                            @Override\r\n                            public void onClick(DialogInterface arg0, int arg1) {\r\n                                Toast.makeText(RemoteControl.this, \"取消成功\", Toast.LENGTH_SHORT).show();\r\n                                player.startPlay();\r\n                            }\r\n                        });\r\n                        AlertDialog b = builder.create();\r\n                        b.show();\r\n                        player.onPause();\r\n                    }\r\n                })\r\n                .setPlayerStartOrPauseListener(new OnPlayerStartOrPauseListener() {\r\n                    @Override\r\n                    public void onStartOrPause() {\r\n                        //对话框\r\n                        AlertDialog.Builder builder = new AlertDialog.Builder(mContext);\r\n                        builder.setIcon(R.drawable.shangbackground);\r\n                        builder.setTitle(\"暂停挪车\");//设置对话框的标题\r\n                        builder.setMessage(\"挪车已暂停，是否继续挪车？\");//设置对话框的内容\r\n                        builder.setPositiveButton(\"继续\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                            @Override\r\n                            public void onClick(DialogInterface arg0, int arg1) {\r\n                                player.startPlay();\r\n                            }\r\n                        });\r\n                        builder.setNegativeButton(\"结束\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                            @Override\r\n                            public void onClick(DialogInterface arg0, int arg1) {\r\n                                finish();\r\n                                Intent intent = new Intent(RemoteControl.this, MainActivity.class);\r\n                                startActivity(intent);\r\n                            }\r\n                        });\r\n                        AlertDialog b = builder.create();\r\n                        b.show();\r\n                    }\r\n                })\r\n                .setPlaySource(url)\r\n                .startPlay();\r\n    }\r\n\r\n\r\n    /**\r\n    1表示手刹释放，0表示手刹锁定\r\n     **/\r\n\r\n    private void shiftHandbrake(int handbrakeToSet) {\r\n        if(handbrakeToSet!=handBrakeStatus){\r\n            for(int i=0;i<5;i++){\r\n                Handbrake mHandbrake = new Handbrake();\r\n                mHandbrake.setTimestamp(System.currentTimeMillis());\r\n                mHandbrake.setStatus(handbrakeToSet);\r\n                mHandbrake.setType(14);\r\n                mHandbrake.setTaskid(\"6D\");\r\n                // 需先在腾讯云控制台，增加自定义主题: data，用于更新自定义数据\r\n                mqttSample.publishTopic(\"data\", JSON.toJSONString(mHandbrake));\r\n                Log.d(TAG, \"onClick: 手刹\"+JSON.toJSONString(mHandbrake));\r\n                sleep(50);\r\n            }\r\n            handBrakeStatus=handbrakeToSet;}\r\n        else return;\r\n    }\r\n\r\n    /**\r\n    1,2,3,4分別對應P,R,N,D四個檔位\r\n     **/\r\n    private void shiftGear(final int gear){\r\n        if(speed==0){\r\n        for(int i=0;i<10;i++){\r\n                Gears mGear = new Gears();\r\n                mGear.setTimestamp(System.currentTimeMillis());\r\n                Log.d(TAG, \"onClick: \"+System.currentTimeMillis());\r\n                mGear.setGear(gear);\r\n                mGear.setType(13);\r\n                mGear.setTaskid(\"手機挂\"+gear+\"档\");\r\n                // 需先在腾讯云控制台，增加自定义主题: data，用于更新自定义数据\r\n                mqttSample.publishTopic(\"data\", JSON.toJSONString(mGear));\r\n                Log.d(TAG, \"onClick: \"+JSON.toJSONString(mGear));\r\n                sleep(50);\r\n        }\r\n        gearGlobal=gear;}\r\n        else {\r\n            moveVehicle(-0.3,0.0,0.0);\r\n            shiftGear(gear);\r\n        }\r\n    }\r\n\r\n    /**\r\n\r\n     @videoType\r\n     1为前方原始视频流，2为后方原始视频流，3为左侧原始视频流，4为右侧原始视频流，5为感知融合视频流，6为上帝视角视频流\r\n     @videoStatus\r\n     1为打开，0为关闭\r\n     */\r\n    private void shiftVideoType(int videoType,int videoStatus){\r\n        Video mVideo = new Video();\r\n        mVideo.setTimestamp(System.currentTimeMillis());\r\n        mVideo.setVideo_type(videoType);\r\n        mVideo.setOperation(videoStatus);\r\n        mVideo.setType(12);\r\n        // 需先在腾讯云控制台，增加自定义主题: data，用于更新自定义数据\r\n        mqttSample.publishTopic(\"data\", JSON.toJSONString(mVideo));\r\n        Log.d(TAG, \"onClick: \"+JSON.toJSONString(mVideo));\r\n    }\r\n\r\n    /**\r\n     * @acceleration 加速度，正是加速，負的是減速\r\n     * @speed 目標速度\r\n     * @wheelAngle 方向盤轉角\r\n     */\r\n    private void moveVehicle(Double acceleration,Double speed,Double wheelAngle){\r\n        Control mMove = new Control();\r\n        mMove.setTimestamp(System.currentTimeMillis());\r\n        mMove.setAcceleration(acceleration);\r\n        mMove.setSpeed(speed);\r\n        mMove.setType(11);\r\n        mMove.setWheel_angle(wheelAngle);\r\n        // 需先在腾讯云控制台，增加自定义主题: data，用于更新自定义数据\r\n        //mqttSample.publishTopic(\"data\", JSON.toJSONString(mMove));\r\n        //Log.d(TAG, \"onClick: 上传刹车\"+JSON.toJSONString(mMove));\r\n    }\r\n\r\n    @Override\r\n    protected void onPostCreate(Bundle savedInstanceState) {\r\n        super.onPostCreate(savedInstanceState);\r\n    }\r\n\r\n\r\n\r\n\r\n    //ms为需要休眠的时长\r\n    public static void sleep(long ms)\r\n    {\r\n        //uptimeMillis() Returns milliseconds since boot, not counting time spent in deep sleep.\r\n        long start = uptimeMillis();\r\n        long duration = ms;\r\n        boolean interrupted = false;\r\n        do {\r\n            try {\r\n                Thread.sleep(duration);\r\n            }\r\n            catch (InterruptedException e) {\r\n                interrupted = true;\r\n            }\r\n            duration = start + ms - uptimeMillis();\r\n        } while (duration > 0);\r\n\r\n        if (interrupted) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 实现TXMqttActionCallBack回调接口\r\n     */\r\n    private class SelfMqttActionCallBack extends TXMqttActionCallBack {\r\n\r\n        @Override\r\n        public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {\r\n            String userContextInfo = \"\";\r\n            if (userContext instanceof MQTTRequest) {\r\n                userContextInfo = userContext.toString();\r\n            }\r\n            String logInfo = String.format(\"onConnectCompleted, status[%s], reconnect[%b], userContext[%s], msg[%s]\",\r\n                    status.name(), reconnect, userContextInfo, msg);\r\n            Log.d(TAG, \"onConnectCompleted: \"+logInfo);\r\n            if(status==Status.OK){\r\n             mIsConnected = true;}\r\n        }\r\n\r\n        @Override\r\n        public void onConnectionLost(Throwable cause) {\r\n            String logInfo = String.format(\"onConnectionLost, cause[%s]\", cause.toString());\r\n            Log.d(TAG, \"onConnectCompleted: \"+logInfo);\r\n        }\r\n\r\n        @Override\r\n        public void onDisconnectCompleted(Status status, Object userContext, String msg) {\r\n            String userContextInfo = \"\";\r\n            if (userContext instanceof MQTTRequest) {\r\n                userContextInfo = userContext.toString();\r\n            }\r\n            String logInfo = String.format(\"onDisconnectCompleted, status[%s], userContext[%s], msg[%s]\", status.name(), userContextInfo, msg);\r\n            Log.d(TAG, \"onConnectCompleted: \"+logInfo);\r\n            mIsConnected = false;\r\n        }\r\n\r\n        @Override\r\n        public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {\r\n            String userContextInfo = \"\";\r\n            if (userContext instanceof MQTTRequest) {\r\n                userContextInfo = userContext.toString();\r\n            }\r\n            String logInfo = String.format(\"onPublishCompleted, status[%s], topics[%s],  userContext[%s], errMsg[%s]\",\r\n                    status.name(), Arrays.toString(token.getTopics()), userContextInfo, errMsg);\r\n            Log.d(TAG, \"onConnectCompleted: \"+logInfo);\r\n        }\r\n\r\n        @Override\r\n        public void onSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {\r\n            String userContextInfo = \"\";\r\n            if (userContext instanceof MQTTRequest) {\r\n                userContextInfo = userContext.toString();\r\n            }\r\n            String logInfo = String.format(\"onSubscribeCompleted, status[%s], topics[%s], userContext[%s], errMsg[%s]\",\r\n                    status.name(), Arrays.toString(asyncActionToken.getTopics()), userContextInfo, errMsg);\r\n            if (Status.ERROR == status) {\r\n                Log.d(TAG, \"onConnectCompleted: \"+logInfo);\r\n            } else {\r\n                Log.d(TAG, \"onConnectCompleted: \"+logInfo);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void onUnSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {\r\n            String userContextInfo = \"\";\r\n            if (userContext instanceof MQTTRequest) {\r\n                userContextInfo = userContext.toString();\r\n            }\r\n            String logInfo = String.format(\"onUnSubscribeCompleted, status[%s], topics[%s], userContext[%s], errMsg[%s]\",\r\n                    status.name(), Arrays.toString(asyncActionToken.getTopics()), userContextInfo, errMsg);\r\n            Log.d(TAG, \"onConnectCompleted: \"+logInfo);\r\n        }\r\n\r\n        @Override\r\n        public void onMessageReceived(final String topic, final MqttMessage message) {\r\n            String logInfo = String.format(\"receive command, topic[%s], message[%s]\", topic, message.toString());\r\n            Log.d(TAG, \"onConnectCompleted: \"+logInfo);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 实现TXMqttLogCallBack回调接口\r\n     */\r\n    private class SelfMqttLogCallBack extends TXMqttLogCallBack {\r\n\r\n        @Override\r\n        public String setSecretKey() {\r\n            String secertKey;\r\n            if (mDevPSK != null && mDevPSK.length() != 0) {  //密钥认证\r\n                secertKey = mDevPSK;\r\n                secertKey = secertKey.length() > 24 ? secertKey.substring(0,24) : secertKey;\r\n                return secertKey;\r\n            } else {\r\n                BufferedReader cert;\r\n\r\n                if (mDevCert != null && mDevCert.length() != 0) { //动态注册,从DevCert中读取\r\n                    cert = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(mDevCert.getBytes(Charset.forName(\"utf8\"))), Charset.forName(\"utf8\")));\r\n\r\n                } else { //证书认证，从证书文件中读取\r\n                    AssetManager assetManager = mParent.getAssets();\r\n                    if (assetManager == null) {\r\n                        return null;\r\n                    }\r\n                    try {\r\n                        cert=new BufferedReader(new InputStreamReader(assetManager.open(mDevCertName)));\r\n                    } catch (IOException e) {\r\n//                        mParent.printLogInfo(TAG, \"getSecertKey failed, cannot open CRT Files.\",mLogInfoText);\r\n                        return null;\r\n                    }\r\n                }\r\n                //获取密钥\r\n                try {\r\n                    if (cert.readLine().contains(\"-----BEGIN\")) {\r\n                        secertKey = cert.readLine();\r\n                        secertKey = secertKey.length() > 24 ? secertKey.substring(0,24) : secertKey;\r\n                    } else {\r\n                        secertKey = null;\r\n//                        mParent.printLogInfo(TAG,\"Invaild CRT Files.\", mLogInfoText);\r\n                    }\r\n                    cert.close();\r\n                } catch (IOException e) {\r\n                    TXLog.e(TAG, \"getSecertKey failed.\", e);\r\n//                    mParent.printLogInfo(TAG,\"getSecertKey failed.\", mLogInfoText);\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            return secertKey;\r\n        }\r\n\r\n        @Override\r\n        public void printDebug(String message){\r\n//            mParent.printLogInfo(TAG, message, mLogInfoText);\r\n            //TXLog.d(TAG,message);\r\n        }\r\n\r\n        @Override\r\n        public boolean saveLogOffline(String log){\r\n            //判断SD卡是否可用\r\n            if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {\r\n//                mParent.printLogInfo(TAG, \"saveLogOffline not ready\", mLogInfoText);\r\n                return false;\r\n            }\r\n\r\n            String logFilePath = mLogPath + mProductID + mDevName + \".log\";\r\n\r\n            TXLog.i(TAG, \"Save log to %s\", logFilePath);\r\n\r\n            try {\r\n                BufferedWriter wLog = new BufferedWriter(new FileWriter(new File(logFilePath), true));\r\n                wLog.write(log);\r\n                wLog.flush();\r\n                wLog.close();\r\n                return true;\r\n            } catch (IOException e) {\r\n                String logInfo = String.format(\"Save log to [%s] failed, check the Storage permission!\", logFilePath);\r\n//                mParent.printLogInfo(TAG,logInfo, mLogInfoText);\r\n                e.printStackTrace();\r\n                return false;\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public String readOfflineLog(){\r\n            //判断SD卡是否可用\r\n            if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {\r\n//                mParent.printLogInfo(TAG, \"readOfflineLog not ready\", mLogInfoText);\r\n                return null;\r\n            }\r\n\r\n            String logFilePath = mLogPath + mProductID + mDevName + \".log\";\r\n\r\n            TXLog.i(TAG, \"Read log from %s\", logFilePath);\r\n\r\n            try {\r\n                BufferedReader logReader = new BufferedReader(new FileReader(logFilePath));\r\n                StringBuilder offlineLog = new StringBuilder();\r\n                int data;\r\n                while (( data = logReader.read()) != -1 ) {\r\n                    offlineLog.append((char)data);\r\n                }\r\n                logReader.close();\r\n                return offlineLog.toString();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n                return null;\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public boolean delOfflineLog(){\r\n\r\n            //判断SD卡是否可用\r\n            if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {\r\n//                mParent.printLogInfo(TAG, \"delOfflineLog not ready\", mLogInfoText);\r\n                return false;\r\n            }\r\n\r\n            String logFilePath = mLogPath + mProductID + mDevName + \".log\";\r\n\r\n            File file = new File(logFilePath);\r\n            if (file.exists() && file.isFile()) {\r\n                if (file.delete()) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    class\r\n    CompentOnTouch implements View.OnTouchListener {\r\n\r\n        public boolean isOnLongClick=false;\r\n        int i = 0;\r\n\r\n        @Override\r\n        public boolean onTouch(View view, MotionEvent motionEvent) {\r\n\r\n            switch (view.getId()) {\r\n// 这是btnMius下的一个层，为了增强易点击性\r\n                case R.id.backward:\r\n                    onTouchChange(\"backward\", motionEvent.getAction());\r\n                    break;\r\n// 这里也写，是为了增强易点击性\r\n                case R.id.forward:\r\n                    onTouchChange(\"forward\", motionEvent.getAction());\r\n                    break;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        private void onTouchChange(String methodName, int eventAction) {\r\n            Log.d(TAG, \"onTouchChange: \"+methodName+eventAction);\r\n            braking =false;\r\n// 按下松开分别对应启动停止前进方法\r\n            if (\"backward\".equals(methodName)) {\r\n                if(gearGlobal!=2){\r\n                shiftGear(2);}\r\n                MiusThread miusThread = null;\r\n                if (eventAction == MotionEvent.ACTION_DOWN) {\r\n                    miusThread = new MiusThread();\r\n                    isOnLongClick = true;\r\n                    miusThread.start();\r\n                } else if (eventAction == MotionEvent.ACTION_UP) {\r\n                    isOnLongClick=false;\r\n                    braking =true;\r\n                    Log.d(TAG, \"onTouchChange: 松开手指\"+ braking);\r\n//                    Log.d(TAG, \"onTouchChange: isOnLongClick=false\"+miusThread.isInterrupted());\r\n                    if (miusThread != null) {\r\n                        miusThread.interrupt();\r\n                        Log.d(TAG, \"onTouchChange: 终止线程\");\r\n                        isOnLongClick = false;\r\n                    }\r\n                } else if (eventAction == MotionEvent.ACTION_MOVE) {\r\n                    if (miusThread != null) {\r\n                        isOnLongClick = true;\r\n                    }\r\n                }\r\n            }\r\n// 按下松开分别对应启动停止加线程方法\r\n            else if (\"forward\".equals(methodName)) {\r\n                if(gearGlobal!=4){\r\n                shiftGear(4);}\r\n                PlusThread plusThread = null;\r\n                if (eventAction == MotionEvent.ACTION_DOWN) {\r\n                    plusThread = new PlusThread();\r\n                    isOnLongClick = true;\r\n                    plusThread.start();\r\n                } else if (eventAction == MotionEvent.ACTION_UP) {\r\n                    Log.d(TAG, \"onTouchChange: 松开手指\");\r\n                    isOnLongClick=false;\r\n                    braking =true;\r\n                    if (plusThread != null) {\r\n                        isOnLongClick = false;\r\n                    }\r\n                } else if (eventAction == MotionEvent.ACTION_MOVE) {\r\n                    if (plusThread != null) {\r\n                        isOnLongClick = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // 后退操作\r\n        class MiusThread extends Thread {\r\n            @Override\r\n            public void run() {\r\n                while (isOnLongClick) {\r\n                    try {\r\n                        Thread.sleep(40);\r\n                        myHandler.sendEmptyMessage(2);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    super.run();\r\n                }\r\n//                while (!isOnLongClick) {\r\n//                    try {\r\n//                        Thread.sleep(100);\r\n//                        myHandler.sendEmptyMessage(3);\r\n//                    } catch (InterruptedException e) {\r\n//                        e.printStackTrace();\r\n//                    }\r\n//                    super.run();\r\n//                }\r\n            }\r\n        }\r\n\r\n\r\n        // 前进操作\r\n        class PlusThread extends Thread {\r\n            @Override\r\n            public void run() {\r\n                while (isOnLongClick) {\r\n                    try {\r\n                        Thread.sleep(40);\r\n                        myHandler.sendEmptyMessage(1);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    super.run();\r\n                }\r\n//                while (!isOnLongClick) {\r\n//                    try {\r\n//                        Thread.sleep(100);\r\n//                        myHandler.sendEmptyMessage(3);\r\n//                    } catch (InterruptedException e) {\r\n//                        e.printStackTrace();\r\n//                    }\r\n//                    super.run();\r\n//                }\r\n            }\r\n        }\r\n\r\n        Handler myHandler = new Handler() {\r\n            public void handleMessage(Message msg) {\r\n                switch (msg.what) {\r\n                    case 1:\r\n                        //前进操作\r\n//                        Control mForward = new Control(5.0,0.1,wheelAngle);\r\n//                        mqttSample.publishTopic(\"data\", JSON.toJSONString(mForward));\r\n//                        Log.d(TAG, \"第 \"+(i++)+\"次上传\\n\"+JSON.toJSONString(mForward));\r\n                        moveVehicle(0.1,5.0,wheelAngle);\r\n                        break;\r\n                    case 2:\r\n//                        Control mBackward = new Control(-5.0,0.1,wheelAngle);\r\n//                        mqttSample.publishTopic(\"data\", JSON.toJSONString(mBackward));\r\n//                        Log.d(TAG, \"第 \"+(i++)+\"次上传\\n\"+JSON.toJSONString(mBackward));\r\n                        moveVehicle(0.1,-5.0,wheelAngle);\r\n                        Log.d(\"TAG\",\"Backward:\"+i--);\r\n                        break;\r\n                    case 3:\r\n                        Control mBreak = new Control(0.0,-0.1,wheelAngle);\r\n                        mqttSample.publishTopic(\"data\", JSON.toJSONString(mBreak));\r\n                        Log.d(TAG, \"第 \"+(i++)+\"次上传\\n\"+JSON.toJSONString(mBreak));\r\n                        break;\r\n                }\r\n            };\r\n        };\r\n    }\r\n\r\n    @Override\r\n    protected void onPause() {\r\n        super.onPause();\r\n        if (player != null) {\r\n            player.onPause();\r\n        }\r\n        /**demo的内容，恢复系统其它媒体的状态*/\r\n        MediaUtils.muteAudioFocus(mContext, true);\r\n    }\r\n\r\n\r\n    @Override\r\n    protected void onResume() {\r\n        super.onResume();\r\n        if (player != null) {\r\n            player.onResume();\r\n        }\r\n        /**demo的内容，暂停系统其它媒体的状态*/\r\n        MediaUtils.muteAudioFocus(mContext, false);\r\n        /**demo的内容，激活设备常亮状态*/\r\n        if (wakeLock != null) {\r\n            wakeLock.acquire();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void onDestroy() {\r\n        super.onDestroy();\r\n        if (player != null) {\r\n            for(int i=1;i<7;i++){\r\n            shiftVideoType(i,0);}\r\n            player.onDestroy();\r\n        }\r\n        if(speed!=0){moveVehicle(-0.3,0.0,0.0);}\r\n        if(braking){braking=false;}\r\n        if(gearGlobal!=1){shiftGear(1);}\r\n        if(handBrakeStatus==1){shiftHandbrake(0);}\r\n        if(mIsConnected){mqttSample.disconnect();}\r\n\r\n        Log.d(TAG, \"onDestroy: 斷開視頻以及MQTT連接\");\r\n    }\r\n\r\n    @Override\r\n    public void onConfigurationChanged(Configuration newConfig) {\r\n        super.onConfigurationChanged(newConfig);\r\n        if (player != null) {\r\n            player.onConfigurationChanged(newConfig);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onBackPressed() {\r\n        if (player != null && player.onBackPressed()) {\r\n            return;\r\n        }\r\n        super.onBackPressed();\r\n        /**demo的内容，恢复设备亮度状态*/\r\n        if (wakeLock != null) {\r\n            wakeLock.release();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/dou361/jjdxm_ijkplayer/remotecontrol/RemoteControl.java	(revision d2145b2e60a213e962bd4c4bdbc527cedbf64ea5)
+++ app/src/main/java/com/dou361/jjdxm_ijkplayer/remotecontrol/RemoteControl.java	(date 1608799611253)
@@ -169,7 +169,6 @@
                  while (true) {
                      if(braking){
                     try {
-
                         moveVehicle(-0.1,0.0,wheelAngle);
                         sleep(50);
                     } catch (Exception e) {
@@ -193,18 +192,10 @@
         sImgView = findViewById(R.id.steering_wheel);
 
         //方向盘角度在速度处显示
-        new Thread(new Runnable() {
+        countDownTimer=new CountDownTimer(1000000,200) {
             @Override
-            public void run() {
-                while(true){
-                    wheelAngle = sImgView.getmDegree();
-                }
-            }
-        }).start();
-
-        countDownTimer=new CountDownTimer(100000,200) {
-            @Override
-            public void onTick(long millisUntilFinished) {
+            public void onTick(long millisUntilFinished) {
+                wheelAngle = sImgView.getmDegree();
                 Speed = findViewById(R.id.speed);
                 Speed.setText(String.valueOf((int)wheelAngle));
             }
Index: app/src/main/java/com/dou361/jjdxm_ijkplayer/remotecontrol/RemoteControlInitial.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.dou361.jjdxm_ijkplayer.remotecontrol;\r\n\r\nimport android.app.Activity;\r\nimport android.app.AlertDialog;\r\nimport android.content.Context;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.os.CountDownTimer;\r\nimport android.view.View;\r\nimport android.view.WindowManager;\r\nimport android.widget.Button;\r\nimport android.widget.ImageButton;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport com.dou361.jjdxm_ijkplayer.R;\r\n\r\npublic class RemoteControlInitial extends Activity {\r\n\r\n    private Context mContext;\r\n    private Button StartRemove;\r\n    private ImageButton imageButton_forward,imageButton_backward;\r\n    private TextView speedTextView;\r\n    private double wheelAngle=0.0;\r\n\r\n\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\r\n\r\n        //一直连接Iothub\r\n\r\n\r\n\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_remote_controlinitial);\r\n        this.mContext = this;\r\n        CountDownTimer countDownTimer = new CountDownTimer(100000, 200) {\r\n            @Override\r\n            public void onTick(long millisUntilFinished) {\r\n                speedTextView = findViewById(R.id.speed);\r\n                speedTextView.setText(String.valueOf((int) wheelAngle));\r\n            }\r\n\r\n            @Override\r\n            public void onFinish() {\r\n            }\r\n        }.start();\r\n\r\n\r\n        StartRemove= (Button)findViewById(R.id.startRemove);\r\n        StartRemove.setOnClickListener(new View.OnClickListener(){\r\n            @Override\r\n            public void onClick(View V){\r\n\r\n                        //IotHub连接成功弹出对话框，否则提示当前连接车辆失败\r\n                        AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                        builder.setIcon(R.drawable.shangbackground);\r\n                        builder.setTitle(\"开始挪车\");//设置对话框的标题\r\n                        builder.setMessage(\"挪车功能提供用户通过手机遥控移动车辆的功能请问您要开始挪车吗？\");//设置对话框的内容\r\n                        builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                            @Override\r\n                            public void onClick(DialogInterface arg0, int arg1) {\r\n                                Intent intent=new Intent(RemoteControlInitial.this, RemoteControl.class);\r\n                                startActivity(intent);\r\n                            }\r\n                        });\r\n                        builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                            @Override\r\n                            public void onClick(DialogInterface arg0, int arg1) {\r\n                                Toast.makeText(RemoteControlInitial.this, \"取消成功\",Toast.LENGTH_SHORT).show();\r\n                            }\r\n                        });\r\n                        AlertDialog b=builder.create();\r\n                        b.show();\r\n                    }\r\n                 });\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/dou361/jjdxm_ijkplayer/remotecontrol/RemoteControlInitial.java	(revision d2145b2e60a213e962bd4c4bdbc527cedbf64ea5)
+++ app/src/main/java/com/dou361/jjdxm_ijkplayer/remotecontrol/RemoteControlInitial.java	(date 1608799611260)
@@ -23,6 +23,8 @@
     private ImageButton imageButton_forward,imageButton_backward;
     private TextView speedTextView;
     private double wheelAngle=0.0;
+    ScalableImageView sImgView ;
+
 
 
 
@@ -30,16 +32,16 @@
     protected void onCreate(Bundle savedInstanceState) {
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
 
-        //一直连接Iothub
-
-
-
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_remote_controlinitial);
         this.mContext = this;
-        CountDownTimer countDownTimer = new CountDownTimer(100000, 200) {
+
+        sImgView = findViewById(R.id.steering_wheel);
+
+        CountDownTimer countDownTimer = new CountDownTimer(1000000, 200) {
             @Override
             public void onTick(long millisUntilFinished) {
+                wheelAngle=sImgView.getmDegree();
                 speedTextView = findViewById(R.id.speed);
                 speedTextView.setText(String.valueOf((int) wheelAngle));
             }
Index: app/src/main/java/com/dou361/jjdxm_ijkplayer/remotecontrol/ScalableImageView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.dou361.jjdxm_ijkplayer.remotecontrol;\r\n\r\nimport android.content.Context;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.Point;\r\nimport android.graphics.PointF;\r\nimport android.util.AttributeSet;\r\nimport android.util.Log;\r\nimport android.view.MotionEvent;\r\nimport android.view.animation.RotateAnimation;\r\n\r\nimport com.dou361.jjdxm_ijkplayer.R;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport static android.content.ContentValues.TAG;\r\n\r\n\r\n/**\r\n * Fixed on 2020/9/17,which is a happy day!\r\n */\r\npublic class ScalableImageView extends androidx.appcompat.widget.AppCompatImageView{\r\n\r\n\r\n    private static final double MAX_DEGREE = 600.0;//方向盘最大转角\r\n    private Matrix matrix;\r\n    private Matrix cacheMatrix;  //缓存的matrix ，同时记录上一次滑动的位置\r\n    private float mPointDistinct = 1f;\r\n    private  double mDegree=0.0;// 旋转的ScalableImageView角度\r\n    double radius0 =0.0;\r\n\r\n\r\n    private Bitmap bitmap;\r\n\r\n    public  Double getmDegree() {\r\n        return mDegree;\r\n\r\n    }\r\n\r\n    List<Double> angleList= new ArrayList<>();//For story the angle data\r\n    List<PointF> pointFList = new ArrayList<>();\r\n    PointF point2store=new PointF();\r\n    int circle =0;\r\n    double degree0 = 0.0;//按下角度\r\n    double degree = 0.0;//转动角度\r\n    double radiusLast;\r\n    double degreeLast;\r\n    double radiusNow;\r\n    double degreeNow;\r\n    double delta_degree;\r\n\r\n    enum Mode {\r\n        NONE, DOWN, MOVE\r\n    }\r\n\r\n    private Mode mode; //当前mode\r\n    private Context mContext;\r\n\r\n    private PointF mStart = new PointF();\r\n\r\n    public ScalableImageView(Context context) {\r\n        this(context, null);\r\n    }\r\n\r\n    public ScalableImageView(Context context, AttributeSet attrs) {\r\n        this(context, attrs, 0);\r\n    }\r\n\r\n    public ScalableImageView(Context context, AttributeSet attrs, int defStyleAttr) {\r\n        super(context, attrs, defStyleAttr);\r\n        this.mContext = context;\r\n        init();\r\n    }\r\n\r\n    private void init() {\r\n        circle = 0;\r\n        degree = 0.0;\r\n        degree0 = 0.0;\r\n        mDegree = 0.0;\r\n        radius0 = 0.0;\r\n        matrix = new Matrix();\r\n        cacheMatrix = new Matrix();\r\n        pointFList.clear();\r\n        mode = Mode.NONE;\r\n        bitmap= BitmapFactory.decodeResource(getResources(), R.drawable.steering_wheel);  //避免OOM\r\n        setImageBitmap(bitmap);\r\n    }\r\n\r\n    @Override\r\n    public boolean onTouchEvent(MotionEvent event) {\r\n        switch (event.getAction() & MotionEvent.ACTION_MASK) {\r\n            case MotionEvent.ACTION_DOWN:\r\n            case MotionEvent.ACTION_POINTER_DOWN:\r\n                cacheMatrix.set(matrix); //先拷贝一份到缓存\r\n                float delta_x0 = (event.getX()- bitmap.getWidth()/2);\r\n                float delta_y0 = (event.getY() - bitmap.getHeight()/ 2);\r\n                radius0 = Math.atan2(delta_y0,delta_x0);\r\n                degree0= (Double) Math.toDegrees(radius0);\r\n                Log.d(TAG, \"onTouchEvent: 初始角度\"+degree0);\r\n                mode = Mode.DOWN;\r\n                mStart.set(delta_x0, delta_y0);\r\n                pointFList.add(mStart);\r\n                break;\r\n\r\n            case MotionEvent.ACTION_MOVE:\r\n                //单点触控的时候\r\n                if (mode == Mode.DOWN) {\r\n                    matrix.set(cacheMatrix);\r\n                    float delta_x = (event.getX()- bitmap.getWidth()/2);\r\n                    float delta_y = (event.getY() - bitmap.getHeight()/ 2);\r\n\r\n                    pointFList.add(new PointF(delta_x,delta_y));\r\n                    if(pointFList.size()>5){\r\n                        for(int i=0;i<pointFList.size()-5;i++){\r\n                            pointFList.remove(i);\r\n                        }\r\n                    }\r\n                    if(pointFList.size()>=2){\r\n                        for(int i=0;i<pointFList.size();i++){\r\n                            Log.d(TAG, \"onTouchEvent: \\n第\"+i+\"个点：\"+pointFList.get(i).x+\",\"+pointFList.get(i).y+\"\\n\");\r\n                        }\r\n                         radiusLast = Math.atan2(pointFList.get(pointFList.size()-2).y,pointFList.get(pointFList.size()-2).x);\r\n                         degreeLast = Math.toDegrees(radiusLast);\r\n                         radiusNow = Math.atan2(pointFList.get(pointFList.size()-1).y,pointFList.get(pointFList.size()-1).x);\r\n                         degreeNow = Math.toDegrees(radiusNow);\r\n                         delta_degree = degreeNow - degreeLast;\r\n                        if(delta_degree<=0&&Math.abs(delta_degree)<180){\r\n                            mDegree=mDegree-Math.abs(delta_degree);\r\n                        }else if(delta_degree<=0&&Math.abs(delta_degree)>=180){\r\n                            mDegree= mDegree+360-Math.abs(delta_degree);\r\n                        }else if(delta_degree>0&&Math.abs(delta_degree)<180){\r\n                            mDegree= mDegree+Math.abs(delta_degree);\r\n                        }else if(delta_degree>0&&Math.abs(delta_degree)>=180){\r\n                            mDegree= mDegree-360+Math.abs(delta_degree);\r\n                        }\r\n                        Log.d(TAG, \"onTouchEvent: 現在角度\"+mDegree);\r\n                    }\r\n                    if(mDegree>MAX_DEGREE) {mDegree = MAX_DEGREE;}\r\n                    if(mDegree<-MAX_DEGREE){mDegree =-MAX_DEGREE;}\r\n\r\n                    /*double radius = Math.atan2(delta_y,delta_x);\r\n                    Log.d(TAG, \"onTouchEvent: pass弧度\"+(radius-radius0));\r\n                    //向量叉乘判斷正負\r\n                    if(event.getY()-mStart.y>0){\r\n                        Log.d(TAG, \"onTouchEvent: 順時針\"+Math.atan2(1,-1));\r\n//                        degree=degree+360;\r\n                    }else {\r\n                        Log.d(TAG, \"onTouchEvent: 逆時針\"+Math.atan2(-1,1));\r\n                    }\r\n\r\n                    Log.d(TAG, \"onTouchEvent: 現在弧度\"+radius);\r\n                    Log.d(TAG, \"onTouchEvent: 現在角度\"+Math.toDegrees(radius));\r\n                    degree= (Double) Math.toDegrees(radius)-degree0;\r\n                    Log.d(TAG, \"onTouchEvent: 旋轉角度\"+degree);\r\n                    angleList.add(degree);\r\n                    if(angleList.size()>5){\r\n                        for(int i=0;i<angleList.size()-5;i++){\r\n                            angleList.remove(i);\r\n                        }\r\n                    }\r\n                    if(angleList.size()>2) {\r\n                        //\r\n                        Log.d(TAG, \"onTouchEvent: \\n當前角度\"+angleList.get(angleList.size() - 1)+\"上次角度\"+angleList.get(angleList.size() - 2));\r\n                        if (angleList.get(angleList.size() - 1) - angleList.get(angleList.size() - 2) > 300)\r\n                        {\r\n//                            circle--;\r\n                        Log.d(TAG, \"onTouchEvent: 減了一圈\"+circle);}\r\n                        if (angleList.get(angleList.size() - 1) - angleList.get(angleList.size() - 2) < -300)\r\n                        {\r\n//                            circle++;\r\n                        Log.d(TAG, \"onTouchEvent: 加了一圈\"+circle);}\r\n                        degree = degree + 360 * circle;\r\n\r\n                        if(degree>MAX_DEGREE) {degree = MAX_DEGREE;}\r\n                        if(degree<-MAX_DEGREE){degree =-MAX_DEGREE;}\r\n                    }\r\n                    Log.d(\"赋值Degree\",mDegree+\"\");\r\n                    mDegree = degree;*/\r\n\r\n//                    final RotateAnimation rotateAnimation = new RotateAnimation(0f, (float)degree, bitmap.getWidth() / 2, bitmap.getHeight() / 2);\r\n                    matrix.postRotate((float) mDegree,bitmap.getWidth()/2, bitmap.getHeight()/ 2);\r\n                }\r\n                break;\r\n            case MotionEvent.ACTION_UP:\r\n                init();\r\n            case MotionEvent.ACTION_POINTER_UP:\r\n            case MotionEvent.ACTION_CANCEL:\r\n                mode = Mode.NONE;\r\n                break;\r\n        }\r\n        setImageMatrix(matrix);\r\n        return true;\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/dou361/jjdxm_ijkplayer/remotecontrol/ScalableImageView.java	(revision d2145b2e60a213e962bd4c4bdbc527cedbf64ea5)
+++ app/src/main/java/com/dou361/jjdxm_ijkplayer/remotecontrol/ScalableImageView.java	(date 1608799854637)
@@ -28,8 +28,7 @@
     private static final double MAX_DEGREE = 600.0;//方向盘最大转角
     private Matrix matrix;
     private Matrix cacheMatrix;  //缓存的matrix ，同时记录上一次滑动的位置
-    private float mPointDistinct = 1f;
-    private  double mDegree=0.0;// 旋转的ScalableImageView角度
+    private double mDegree=0.0;// 旋转的ScalableImageView角度
     double radius0 =0.0;
 
 
@@ -40,12 +39,10 @@
 
     }
 
-    List<Double> angleList= new ArrayList<>();//For story the angle data
-    List<PointF> pointFList = new ArrayList<>();
+    List<PointF> pointFList = new ArrayList<>();//儲存最近劃過的幾個點
     PointF point2store=new PointF();
-    int circle =0;
+
     double degree0 = 0.0;//按下角度
-    double degree = 0.0;//转动角度
     double radiusLast;
     double degreeLast;
     double radiusNow;
@@ -59,8 +56,6 @@
     private Mode mode; //当前mode
     private Context mContext;
 
-    private PointF mStart = new PointF();
-
     public ScalableImageView(Context context) {
         this(context, null);
     }
@@ -76,8 +71,6 @@
     }
 
     private void init() {
-        circle = 0;
-        degree = 0.0;
         degree0 = 0.0;
         mDegree = 0.0;
         radius0 = 0.0;
@@ -101,8 +94,7 @@
                 degree0= (Double) Math.toDegrees(radius0);
                 Log.d(TAG, "onTouchEvent: 初始角度"+degree0);
                 mode = Mode.DOWN;
-                mStart.set(delta_x0, delta_y0);
-                pointFList.add(mStart);
+                pointFList.add(new PointF(delta_x0,delta_y0));
                 break;
 
             case MotionEvent.ACTION_MOVE:
@@ -119,9 +111,6 @@
                         }
                     }
                     if(pointFList.size()>=2){
-                        for(int i=0;i<pointFList.size();i++){
-                            Log.d(TAG, "onTouchEvent: \n第"+i+"个点："+pointFList.get(i).x+","+pointFList.get(i).y+"\n");
-                        }
                          radiusLast = Math.atan2(pointFList.get(pointFList.size()-2).y,pointFList.get(pointFList.size()-2).x);
                          degreeLast = Math.toDegrees(radiusLast);
                          radiusNow = Math.atan2(pointFList.get(pointFList.size()-1).y,pointFList.get(pointFList.size()-1).x);
@@ -141,46 +130,6 @@
                     if(mDegree>MAX_DEGREE) {mDegree = MAX_DEGREE;}
                     if(mDegree<-MAX_DEGREE){mDegree =-MAX_DEGREE;}
 
-                    /*double radius = Math.atan2(delta_y,delta_x);
-                    Log.d(TAG, "onTouchEvent: pass弧度"+(radius-radius0));
-                    //向量叉乘判斷正負
-                    if(event.getY()-mStart.y>0){
-                        Log.d(TAG, "onTouchEvent: 順時針"+Math.atan2(1,-1));
-//                        degree=degree+360;
-                    }else {
-                        Log.d(TAG, "onTouchEvent: 逆時針"+Math.atan2(-1,1));
-                    }
-
-                    Log.d(TAG, "onTouchEvent: 現在弧度"+radius);
-                    Log.d(TAG, "onTouchEvent: 現在角度"+Math.toDegrees(radius));
-                    degree= (Double) Math.toDegrees(radius)-degree0;
-                    Log.d(TAG, "onTouchEvent: 旋轉角度"+degree);
-                    angleList.add(degree);
-                    if(angleList.size()>5){
-                        for(int i=0;i<angleList.size()-5;i++){
-                            angleList.remove(i);
-                        }
-                    }
-                    if(angleList.size()>2) {
-                        //
-                        Log.d(TAG, "onTouchEvent: \n當前角度"+angleList.get(angleList.size() - 1)+"上次角度"+angleList.get(angleList.size() - 2));
-                        if (angleList.get(angleList.size() - 1) - angleList.get(angleList.size() - 2) > 300)
-                        {
-//                            circle--;
-                        Log.d(TAG, "onTouchEvent: 減了一圈"+circle);}
-                        if (angleList.get(angleList.size() - 1) - angleList.get(angleList.size() - 2) < -300)
-                        {
-//                            circle++;
-                        Log.d(TAG, "onTouchEvent: 加了一圈"+circle);}
-                        degree = degree + 360 * circle;
-
-                        if(degree>MAX_DEGREE) {degree = MAX_DEGREE;}
-                        if(degree<-MAX_DEGREE){degree =-MAX_DEGREE;}
-                    }
-                    Log.d("赋值Degree",mDegree+"");
-                    mDegree = degree;*/
-
-//                    final RotateAnimation rotateAnimation = new RotateAnimation(0f, (float)degree, bitmap.getWidth() / 2, bitmap.getHeight() / 2);
                     matrix.postRotate((float) mDegree,bitmap.getWidth()/2, bitmap.getHeight()/ 2);
                 }
                 break;
