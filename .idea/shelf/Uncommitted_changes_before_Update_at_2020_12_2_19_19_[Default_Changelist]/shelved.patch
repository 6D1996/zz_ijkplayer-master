Index: settings.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>include ':app','jjdxm-ijkplayer'\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- settings.gradle	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ settings.gradle	(date 1606840879290)
@@ -1,1 +1,1 @@
-include ':app','jjdxm-ijkplayer'
+include ':app','jjdxm-ijkplayer','iot_core','iot_service','hub-device-java'
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>apply plugin: 'com.android.application'\r\n\r\nProperties props = new Properties()\r\nprops.load(new FileInputStream(file(rootProject.file(\"signing.properties\"))))\r\n\r\nandroid {\r\n\r\n    signingConfigs {\r\n        release {\r\n            keyAlias props['signing.alias']\r\n            keyPassword props['signing.password']\r\n            storeFile file(rootProject.file(\"debug.keystore\"))\r\n            storePassword props['signing.password']\r\n        }\r\n\r\n        debug {\r\n            keyAlias props['signing.jjdxm_alias']\r\n            keyPassword props['signing.jjdxm_password']\r\n            storeFile file(rootProject.file(\"debug.keystore\"))\r\n            storePassword props['signing.jjdxm_password']\r\n        }\r\n    }\r\n\r\n    compileSdkVersion 30\r\n    buildToolsVersion rootProject.ext.buildToolsVersion\r\n\r\n    defaultConfig {\r\n        applicationId \"com.dou361.jjdxm_ijkplayer\"\r\n        minSdkVersion rootProject.ext.minSdkVersion\r\n        targetSdkVersion rootProject.ext.targetSdkVersion\r\n        versionCode rootProject.ext.versionCode\r\n        versionName rootProject.ext.versionName\r\n//        ndk {\r\n//            abiFilters \"armeabi-v7a\"  // 指定要ndk需要兼容的架构(这样其他依赖包里mips,x86,armeabi,arm-v8之类的so会被过滤掉)\r\n//        }\r\n    }\r\n    buildTypes {\r\n\r\n        debug {\r\n            signingConfig signingConfigs.debug\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\r\n        }\r\n\r\n        release {\r\n            signingConfig signingConfigs.release\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n}\r\n\r\ndependencies {\r\n    implementation fileTree(include: ['*.jar'], dir: 'libs')\r\n    implementation 'androidx.appcompat:appcompat:1.2.0'\r\n    implementation 'com.android.support.constraint:constraint-layout:1.1.3'\r\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\r\n\r\n\r\n    testImplementation 'junit:junit:4.13.1'\r\n    implementation rootProject.ext.jjdxm_v7\r\n    implementation 'com.jakewharton:butterknife:7.0.1'\r\n    implementation 'com.github.bumptech.glide:glide:3.7.0'\r\n    implementation project(':jjdxm-ijkplayer')\r\n\r\n//    根据需要支持去拓展，在jjdxm-ijkplayer中默认加入了armv7a的了\r\n    implementation 'tv.danmaku.ijk.media:ijkplayer-java:0.8.8'\r\n    implementation 'tv.danmaku.ijk.media:ijkplayer-armv7a:0.8.8'\r\n    implementation 'tv.danmaku.ijk.media:ijkplayer-arm64:0.8.8'\r\n    implementation 'tv.danmaku.ijk.media:ijkplayer-x86:0.8.8'\r\n    implementation 'tv.danmaku.ijk.media:ijkplayer-x86_64:0.8.8'\r\n\r\n\r\n    //网络获取直播视频\r\n    implementation 'com.squareup.retrofit2:retrofit:2.0.0-beta4'\r\n    implementation 'com.squareup.retrofit2:converter-scalars:2.0.0'\r\n    implementation 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'\r\n    implementation 'com.squareup.okhttp3:okhttp:4.9.0'\r\n    implementation 'com.alibaba:fastjson:1.2.14'\r\n\r\n    implementation 'com.tencent.iot.hub:hub-device-android-core:3.2.0'\r\n    implementation 'com.tencent.iot.hub:hub-device-android-service:3.2.0'\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/build.gradle	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ app/build.gradle	(date 1606843653057)
@@ -5,6 +5,12 @@
 
 android {
 
+    // Fix: More than one file was found
+    packagingOptions {
+        pickFirst 'lib/armeabi-v7a/libnms.so'
+    }
+
+
     signingConfigs {
         release {
             keyAlias props['signing.alias']
@@ -21,7 +27,7 @@
         }
     }
 
-    compileSdkVersion 30
+    compileSdkVersion 25
     buildToolsVersion rootProject.ext.buildToolsVersion
 
     defaultConfig {
@@ -78,8 +84,14 @@
     implementation 'com.squareup.okhttp3:okhttp:4.9.0'
     implementation 'com.alibaba:fastjson:1.2.14'
 
-    implementation 'com.tencent.iot.hub:hub-device-android-core:3.2.0'
-    implementation 'com.tencent.iot.hub:hub-device-android-service:3.2.0'
+//    implementation 'com.tencent.iot.hub:hub-device-android-core:3.2.0'
+//    implementation 'com.tencent.iot.hub:hub-device-android-service:3.2.0'
+//    implementation 'com.tencent.iot.hub:hub-device-java:1.0.0'
+
+    implementation "org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.3"
+    implementation project(':hub-device-java')
+    implementation project(':iot_core')
+    implementation project(':iot_service')
 
 
 
Index: app/src/main/java/com/dou361/jjdxm_ijkplayer/RemoteControl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.dou361.jjdxm_ijkplayer;\r\n\r\nimport android.annotation.SuppressLint;\r\nimport android.app.Activity;\r\nimport android.app.AlertDialog;\r\nimport android.content.Context;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.res.AssetManager;\r\nimport android.os.Bundle;\r\nimport android.os.PowerManager;\r\nimport android.util.Log;\r\nimport android.view.MotionEvent;\r\nimport android.view.View;\r\nimport android.widget.AdapterView;\r\nimport android.widget.Button;\r\nimport android.widget.ImageButton;\r\nimport android.widget.ImageView;\r\nimport android.widget.Spinner;\r\nimport android.widget.Toast;\r\n\r\nimport com.bumptech.glide.Glide;\r\nimport com.dou361.ijkplayer.bean.VideoijkBean;\r\nimport com.dou361.ijkplayer.listener.OnPlayerBackListener;\r\nimport com.dou361.ijkplayer.listener.OnPlayerStartOrPauseListener;\r\nimport com.dou361.ijkplayer.listener.OnShowThumbnailListener;\r\nimport com.dou361.ijkplayer.widget.PlayStateParams;\r\nimport com.dou361.ijkplayer.widget.PlayerView;\r\n\r\n\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.nio.charset.Charset;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\nimport static android.os.SystemClock.uptimeMillis;\r\n\r\n\r\n//I added a line here by Github\r\n//I added this line by Android Studio\r\n\r\n/**\r\n * An example full-screen activity that shows and hides the system UI (i.e.\r\n * status bar and navigation/system bar) by style.xml.\r\n */\r\npublic class RemoteControl extends Activity {\r\n\r\n\r\n    private RemoteControlInitial mParent;\r\n\r\n    private PlayerView player;\r\n    private Context mContext;\r\n    private List<VideoijkBean> list;\r\n    private PowerManager.WakeLock wakeLock;\r\n    private View rootView;\r\n    private Activity mActivity;\r\n\r\n    private static final String TAG = \"FullscreenActivity\";\r\n    private boolean Flag = false;\r\n    private int flagmove = 1;\r\n    private int flagget = 1;\r\n    private Button LlightingButton;\r\n    private ImageButton imageButton_forward,imageButton_backward;\r\n    private ImageView app_video_play;\r\n    private Spinner Video_Modul_Spinner;\r\n\r\n    private String mBrokerURL = \"ssl://fawtsp-mqtt-public-dev.faw.cn:8883\";  //传入null，即使用腾讯云物联网通信默认地址 \"${ProductId}.iotcloud.tencentdevices.com:8883\"  https://cloud.tencent.com/document/product/634/32546\r\n    private String mProductID = \"2N8PWJAI0V\";\r\n    private String mDevName = \"android_test_phone\";\r\n    private String mDevPSK  = \"KdV+RSnHAlmEpM75aWZQZg==\"; //若使用证书验证，设为null\r\n    private String mSubProductID = null; // If you wont test gateway, let this to be null\r\n    private String mSubDevName = null;\r\n    private String mSubDevPsk = \"BuildConfig.SUB_DEVICE_PSK\";\r\n    private String mTestTopic = \"2N8PWJAI0V/android_test_phone/data\";    // productID/DeviceName/TopicName\r\n    private String mDevCertName = \"YOUR_DEVICE_NAME_cert.crt\";\r\n    private String mDevKeyName  = \"YOUR_DEVICE_NAME_private.key\";\r\n    private String mProductKey = \"BuildConfig.PRODUCT_KEY\";        // Used for dynamic register\r\n    private String mDevCert = \"\";           // Cert String\r\n    private String mDevPriv = \"\";           // Priv String\r\n\r\n    private volatile boolean mIsConnected=false;\r\n\r\n    private final static String BROKER_URL = \"broker_url\";\r\n    private final static String PRODUCT_ID = \"product_id\";\r\n    private final static String DEVICE_NAME = \"dev_name\";\r\n    private final static String DEVICE_PSK = \"dev_psk\";\r\n    private final static String SUB_PRODUCID = \"sub_prodid\";\r\n    private final static String SUB_DEVNAME = \"sub_devname\";\r\n    private final static String TEST_TOPIC  = \"test_topic\";\r\n\r\n    private final static String DEVICE_CERT = \"dev_cert\";\r\n    private final static String DEVICE_PRIV  = \"dev_priv\";\r\n    private final static String PRODUCT_KEY  = \"product_key\";\r\n    private final static String SUB_DEVICE_PSK = \"sub_dev_psk\";\r\n\r\n    @SuppressLint(\"InvalidWakeLockTag\")\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        Log.d(TAG, \"onCreate: \");\r\n        super.onCreate(savedInstanceState);\r\n        this.mContext = this;\r\n        this.mActivity = this;\r\n        rootView = getLayoutInflater().from(this).inflate(R.layout.activity_remote_control, null);\r\n        setContentView(rootView);\r\n\r\n\r\n        if (!mIsConnected) {\r\n            Log.d(TAG, \"onCreate: Connecting Mqtt\");\r\n            //轮询连接push\r\n            sleep(2000);\r\n        } else {\r\n            //执行其余操作\r\n        }\r\n\r\n\r\n        /**常亮*/\r\n        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);\r\n        wakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, \"liveTAG\");\r\n        wakeLock.acquire();\r\n\r\n\r\n        imageButton_forward=findViewById(R.id.forward);\r\n        imageButton_forward.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View view) {\r\n                Log.d(TAG, \"onClick: Forward\");\r\n                //发送挂挡及前进指令\r\n            }\r\n        });\r\n\r\n        imageButton_backward=findViewById(R.id.backward);\r\n        imageButton_backward.setOnTouchListener(new View.OnTouchListener() {\r\n            @Override\r\n            public boolean onTouch(View view, MotionEvent motionEvent) {\r\n                switch (motionEvent.getAction()){\r\n                    case MotionEvent.ACTION_DOWN:\r\n                        Log.d(TAG, \"onTouch: backwarDown\");\r\n                    case MotionEvent.ACTION_POINTER_DOWN:\r\n                        Log.d(TAG, \"onTouch: backward\");\r\n                    case MotionEvent.ACTION_MOVE:\r\n                        Log.d(TAG, \"onTouch: backwarding\");\r\n                    case MotionEvent.ACTION_UP:\r\n                        Log.d(TAG, \"onTouch: Up\");\r\n                }\r\n                return true;\r\n            }\r\n        });\r\n\r\n\r\n\r\n        //下拉单选按钮\r\n        Video_Modul_Spinner = (Spinner)findViewById(R.id.Spinner_VIdeo_Model);\r\n        Video_Modul_Spinner.setSelection(0);//进入不会自动播放\r\n        Video_Modul_Spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){\r\n            @Override\r\n            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\r\n//                    String result = parent.getItemAtPosition(position).toString();\r\n//                    Toast.makeText(RemoteControl.this, result, Toast.LENGTH_SHORT).show();\r\n                    switch (position) {\r\n                        case 0: {\r\n                            /**前摄像*/\r\n                            list = new ArrayList<VideoijkBean>();\r\n                            //有部分视频加载有问题，这个视频是有声音显示不出图像的，没有解决http://fzkt-biz.oss-cn-hangzhou.aliyuncs.com/vedio/2f58be65f43946c588ce43ea08491515.mp4\r\n                            //这里模拟一个本地视频的播放，视频需要将testvideo文件夹的视频放到安卓设备的内置sd卡根目录中\r\n                            String url1 = \"rtmp://202.69.69.180:443/webcast/bshdlive-pc\";\r\n                            String url2 = \"http://ivi.bupt.edu.cn/hls/cctv1.m3u8\";\r\n                            VideoijkBean m1 = new VideoijkBean();\r\n                            m1.setStream(\"原始视频\");\r\n                            m1.setUrl(url1);\r\n                            VideoijkBean m2 = new VideoijkBean();\r\n                            m2.setStream(\"融合视频\");\r\n                            m2.setUrl(url2);\r\n                            list.add(m1);\r\n                            list.add(m2);\r\n                            player = new PlayerView(mActivity, rootView)\r\n                                    .setProcessDurationOrientation(PlayStateParams.PROCESS_PORTRAIT)\r\n                                    .setScaleType(PlayStateParams.fillparent) //视频界面剪裁设置\r\n                                    .forbidTouch(false)\r\n                                    .hideSteam(false)\r\n                                    .hideMenu(false)\r\n                                    .hideCenterPlayer(true)\r\n                                    .hideBack(false)\r\n                                    .setOnlyFullScreen(true)\r\n                                    .setNetWorkTypeTie(false)\r\n                                    .hideRotation(true)\r\n                                    .hideFullscreen(true)\r\n                                    .setChargeTie(true, 480)//设置最长播放时间\r\n                                    .showThumbnail(new OnShowThumbnailListener() {\r\n                                        @Override\r\n                                        public void onShowThumbnail(ImageView ivThumbnail) {\r\n//                                 加载前显示的缩略图\r\n                                            Glide.with(mContext)\r\n                                                    .load(\"http://pic2.nipic.com/20090413/406638_125424003_2.jpg\")\r\n                                                    .placeholder(R.color.cl_default) //加载成功之前占位图\r\n                                                    .error(R.color.cl_error)//加载错误之后的错误图\r\n                                                    .into(ivThumbnail);\r\n                                        }\r\n                                    })\r\n                                    .setPlayerBackListener(new OnPlayerBackListener() {\r\n                            @Override\r\n                            public void onPlayerBack() {\r\n                                //对话框\r\n                                AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                builder.setIcon(R.drawable.shangbackground);\r\n                                builder.setTitle(\"结束挪车\");//设置对话框的标题\r\n                                builder.setMessage(\"您已确定车辆已经抵达目标位置并结束挪车操作吗？\");//设置对话框的内容\r\n                                builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        finish();\r\n                                        Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                        startActivity(intent);\r\n                                    }\r\n                                });\r\n                                builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        Toast.makeText(RemoteControl.this, \"取消成功\",Toast.LENGTH_SHORT).show();\r\n                                        player.startPlay();\r\n                                    }\r\n                                });\r\n                                AlertDialog b=builder.create();\r\n                                b.show();\r\n                                player.onPause();\r\n\r\n                            }\r\n                        })\r\n                                    .setPlayerStartOrPauseListener(new OnPlayerStartOrPauseListener() {\r\n                                        @Override\r\n                                        public void onStartOrPause() {\r\n                                            //对话框\r\n                                            AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                            builder.setIcon(R.drawable.shangbackground);\r\n                                            builder.setTitle(\"暂停挪车\");//设置对话框的标题\r\n                                            builder.setMessage(\"挪车已暂停，是否继续挪车？\");//设置对话框的内容\r\n                                            builder.setPositiveButton(\"继续\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    player.startPlay();\r\n                                                }\r\n                                            });\r\n                                            builder.setNegativeButton(\"结束\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    finish();\r\n                                                    Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                                    startActivity(intent);\r\n                                                }\r\n                                            });\r\n                                            AlertDialog b=builder.create();\r\n                                            b.show();\r\n                                        }\r\n                                    })\r\n                                    .setPlaySource(list)\r\n                                    .startPlay();\r\n                        }\r\n                        break;\r\n\r\n                        case 1: {\r\n                            /**后摄像*/\r\n                            String url3 = \"http://ivi.bupt.edu.cn/hls/cctv2.m3u8\";\r\n                            player = new PlayerView(mActivity, rootView)\r\n                                    .setProcessDurationOrientation(PlayStateParams.PROCESS_PORTRAIT)\r\n                                    .setScaleType(PlayStateParams.fillparent) //视频界面剪裁设置\r\n                                    .forbidTouch(false)\r\n                                    .hideSteam(true)\r\n                                    .hideMenu(false)\r\n                                    .hideCenterPlayer(true)\r\n                                    .hideBack(false)\r\n                                    .setOnlyFullScreen(true)\r\n                                    .setNetWorkTypeTie(false)\r\n                                    .hideRotation(true)\r\n                                    .hideFullscreen(true)\r\n                                    .setChargeTie(true, 480)//设置最长播放时间\r\n                                    .showThumbnail(new OnShowThumbnailListener() {\r\n                                        @Override\r\n                                        public void onShowThumbnail(ImageView ivThumbnail) {\r\n//                                 加载前显示的缩略图\r\n                                            Glide.with(mContext)\r\n                                                    .load(\"http://pic2.nipic.com/20090413/406638_125424003_2.jpg\")\r\n                                                    .placeholder(R.color.cl_default) //加载成功之前占位图\r\n                                                    .error(R.color.cl_error)//加载错误之后的错误图\r\n                                                    .into(ivThumbnail);\r\n                                        }\r\n                                    })\r\n                                    .setPlayerBackListener(new OnPlayerBackListener() {\r\n                            @Override\r\n                            public void onPlayerBack() {\r\n                                //对话框\r\n                                AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                builder.setIcon(R.drawable.shangbackground);\r\n                                builder.setTitle(\"结束挪车\");//设置对话框的标题\r\n                                builder.setMessage(\"您已确定车辆已经抵达目标位置并结束挪车操作吗？\");//设置对话框的内容\r\n                                builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        finish();\r\n                                        Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                        startActivity(intent);\r\n                                    }\r\n                                });\r\n                                builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        Toast.makeText(RemoteControl.this, \"取消成功\",Toast.LENGTH_SHORT).show();\r\n                                        player.startPlay();\r\n                                    }\r\n                                });\r\n                                AlertDialog b=builder.create();\r\n                                b.show();\r\n                                player.onPause();\r\n                            }\r\n                        })\r\n                                    .setPlayerStartOrPauseListener(new OnPlayerStartOrPauseListener() {\r\n                                        @Override\r\n                                        public void onStartOrPause() {\r\n                                            //对话框\r\n                                            AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                            builder.setIcon(R.drawable.shangbackground);\r\n                                            builder.setTitle(\"暂停挪车\");//设置对话框的标题\r\n                                            builder.setMessage(\"挪车已暂停，是否继续挪车？\");//设置对话框的内容\r\n                                            builder.setPositiveButton(\"继续\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    player.startPlay();\r\n                                                }\r\n                                            });\r\n                                            builder.setNegativeButton(\"结束\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    finish();\r\n                                                    Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                                    startActivity(intent);\r\n                                                }\r\n                                            });\r\n                                            AlertDialog b=builder.create();\r\n                                            b.show();\r\n                                        }\r\n                                    })\r\n                                    .setPlaySource(url3)\r\n                                    .startPlay();\r\n\r\n                        }\r\n                        break;\r\n\r\n                        case 2: {\r\n                            /**左摄像*/\r\n                            //有部分视频加载有问题，这个视频是有声音显示不出图像的，没有解决http://fzkt-biz.oss-cn-hangzhou.aliyuncs.com/vedio/2f58be65f43946c588ce43ea08491515.mp4\r\n                            //这里模拟一个本地视频的播放，视频需要将testvideo文件夹的视频放到安卓设备的内置sd卡根目录中\r\n                            String url4 = \"http://ivi.bupt.edu.cn/hls/cctv3.m3u8\";\r\n                            player = new PlayerView(mActivity, rootView)\r\n                                    .setProcessDurationOrientation(PlayStateParams.PROCESS_PORTRAIT)\r\n                                    .setScaleType(PlayStateParams.fillparent) //视频界面剪裁设置\r\n                                    .forbidTouch(false)\r\n                                    .hideSteam(true)\r\n                                    .hideMenu(false)\r\n                                    .hideCenterPlayer(true)\r\n                                    .hideBack(false)\r\n                                    .setOnlyFullScreen(true)\r\n                                    .setNetWorkTypeTie(false)\r\n                                    .hideRotation(true)\r\n                                    .hideFullscreen(true)\r\n                                    .setChargeTie(true, 480)//设置最长播放时间\r\n                                    .showThumbnail(new OnShowThumbnailListener() {\r\n                                        @Override\r\n                                        public void onShowThumbnail(ImageView ivThumbnail) {\r\n//                                 加载前显示的缩略图\r\n                                            Glide.with(mContext)\r\n                                                    .load(\"http://pic2.nipic.com/20090413/406638_125424003_2.jpg\")\r\n                                                    .placeholder(R.color.cl_default) //加载成功之前占位图\r\n                                                    .error(R.color.cl_error)//加载错误之后的错误图\r\n                                                    .into(ivThumbnail);\r\n                                        }\r\n                                    })\r\n                                    .setPlayerBackListener(new OnPlayerBackListener() {\r\n                            @Override\r\n                            public void onPlayerBack() {\r\n                                //对话框\r\n                                AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                builder.setIcon(R.drawable.shangbackground);\r\n                                builder.setTitle(\"结束挪车\");//设置对话框的标题\r\n                                builder.setMessage(\"您已确定车辆已经抵达目标位置并结束挪车操作吗？\");//设置对话框的内容\r\n                                builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        finish();\r\n                                        Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                        startActivity(intent);\r\n                                    }\r\n                                });\r\n                                builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        Toast.makeText(RemoteControl.this, \"取消成功\",Toast.LENGTH_SHORT).show();\r\n                                        player.startPlay();\r\n                                    }\r\n                                });\r\n                                AlertDialog b=builder.create();\r\n                                b.show();\r\n                                player.onPause();\r\n                            }\r\n                        })\r\n                                    .setPlayerStartOrPauseListener(new OnPlayerStartOrPauseListener() {\r\n                                        @Override\r\n                                        public void onStartOrPause() {\r\n                                            //对话框\r\n                                            AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                            builder.setIcon(R.drawable.shangbackground);\r\n                                            builder.setTitle(\"暂停挪车\");//设置对话框的标题\r\n                                            builder.setMessage(\"挪车已暂停，是否继续挪车？\");//设置对话框的内容\r\n                                            builder.setPositiveButton(\"继续\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    player.startPlay();\r\n                                                }\r\n                                            });\r\n                                            builder.setNegativeButton(\"结束\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    finish();\r\n                                                    Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                                    startActivity(intent);\r\n                                                }\r\n                                            });\r\n                                            AlertDialog b=builder.create();\r\n                                            b.show();\r\n                                        }\r\n                                    })\r\n                                    .setPlaySource(url4)\r\n                                    .startPlay();\r\n                        }\r\n                        break;\r\n\r\n                        case 3: {\r\n                            /**右摄像*/\r\n                            String url5 = \"http://ivi.bupt.edu.cn/hls/cctv4.m3u8\";\r\n                            player = new PlayerView(mActivity, rootView)\r\n                                    .setProcessDurationOrientation(PlayStateParams.PROCESS_PORTRAIT)\r\n                                    .setScaleType(PlayStateParams.fillparent) //视频界面剪裁设置\r\n                                    .forbidTouch(false)\r\n                                    .hideSteam(true)\r\n                                    .hideMenu(false)\r\n                                    .hideCenterPlayer(true)\r\n                                    .hideBack(false)\r\n                                    .setOnlyFullScreen(true)\r\n                                    .setNetWorkTypeTie(false)\r\n                                    .hideRotation(true)\r\n                                    .hideFullscreen(true)\r\n                                    .setChargeTie(true, 480)//设置最长播放时间\r\n                                    .showThumbnail(new OnShowThumbnailListener() {\r\n                                        @Override\r\n                                        public void onShowThumbnail(ImageView ivThumbnail) {\r\n//                                 加载前显示的缩略图\r\n                                            Glide.with(mContext)\r\n                                                    .load(\"http://pic2.nipic.com/20090413/406638_125424003_2.jpg\")\r\n                                                    .placeholder(R.color.cl_default) //加载成功之前占位图\r\n                                                    .error(R.color.cl_error)//加载错误之后的错误图\r\n                                                    .into(ivThumbnail);\r\n                                        }\r\n                                    })\r\n                                    .setPlayerBackListener(new OnPlayerBackListener() {\r\n                            @Override\r\n                            public void onPlayerBack() {\r\n                                //对话框\r\n                                AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                builder.setIcon(R.drawable.shangbackground);\r\n                                builder.setTitle(\"结束挪车\");//设置对话框的标题\r\n                                builder.setMessage(\"您已确定车辆已经抵达目标位置并结束挪车操作吗？\");//设置对话框的内容\r\n                                builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        finish();\r\n                                        Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                        startActivity(intent);\r\n                                    }\r\n                                });\r\n                                builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        Toast.makeText(RemoteControl.this, \"取消成功\",Toast.LENGTH_SHORT).show();\r\n                                        player.startPlay();\r\n                                    }\r\n                                });\r\n                                AlertDialog b=builder.create();\r\n                                b.show();\r\n                                player.onPause();\r\n                            }\r\n                        })\r\n                                    .setPlayerStartOrPauseListener(new OnPlayerStartOrPauseListener() {\r\n                                        @Override\r\n                                        public void onStartOrPause() {\r\n                                            //对话框\r\n                                            AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                            builder.setIcon(R.drawable.shangbackground);\r\n                                            builder.setTitle(\"暂停挪车\");//设置对话框的标题\r\n                                            builder.setMessage(\"挪车已暂停，是否继续挪车？\");//设置对话框的内容\r\n                                            builder.setPositiveButton(\"继续\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    player.startPlay();\r\n                                                }\r\n                                            });\r\n                                            builder.setNegativeButton(\"结束\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    finish();\r\n                                                    Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                                    startActivity(intent);\r\n                                                }\r\n                                            });\r\n                                            AlertDialog b=builder.create();\r\n                                            b.show();\r\n                                        }\r\n                                    })\r\n\r\n                                    .setPlaySource(url5)\r\n                                    .startPlay();\r\n\r\n                        }\r\n                        break;\r\n\r\n                        case 4: {\r\n                            /**上帝*/\r\n\r\n                            String url6 = \"http://ivi.bupt.edu.cn/hls/cctv13.m3u8\";\r\n                            player = new PlayerView(mActivity, rootView)\r\n                                    .setProcessDurationOrientation(PlayStateParams.PROCESS_PORTRAIT)\r\n                                    .setScaleType(PlayStateParams.fillparent) //视频界面剪裁设置\r\n                                    .forbidTouch(false)\r\n                                    .hideSteam(true)\r\n                                    .hideMenu(false)\r\n                                    .hideCenterPlayer(true)\r\n                                    .hideBack(false)\r\n                                    .setOnlyFullScreen(true)\r\n                                    .setNetWorkTypeTie(false)\r\n                                    .hideRotation(true)\r\n                                    .hideFullscreen(true)\r\n                                    .setChargeTie(true, 480)//设置最长播放时间\r\n                                    .showThumbnail(new OnShowThumbnailListener() {\r\n                                        @Override\r\n                                        public void onShowThumbnail(ImageView ivThumbnail) {\r\n//                                 加载前显示的缩略图\r\n                                            Glide.with(mContext)\r\n                                                    .load(\"http://pic2.nipic.com/20090413/406638_125424003_2.jpg\")\r\n                                                    .placeholder(R.color.cl_default) //加载成功之前占位图\r\n                                                    .error(R.color.cl_error)//加载错误之后的错误图\r\n                                                    .into(ivThumbnail);\r\n                                        }\r\n                                    })\r\n                                    .setPlayerBackListener(new OnPlayerBackListener() {\r\n                            @Override\r\n                            public void onPlayerBack() {\r\n                                //对话框\r\n                                AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                builder.setIcon(R.drawable.shangbackground);\r\n                                builder.setTitle(\"结束挪车\");//设置对话框的标题\r\n                                builder.setMessage(\"您已确定车辆已经抵达目标位置并结束挪车操作吗？\");//设置对话框的内容\r\n                                builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        finish();\r\n                                        Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                        startActivity(intent);\r\n                                    }\r\n                                });\r\n                                builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                    @Override\r\n                                    public void onClick(DialogInterface arg0, int arg1) {\r\n                                        Toast.makeText(RemoteControl.this, \"取消成功\",Toast.LENGTH_SHORT).show();\r\n                                        player.startPlay();\r\n                                    }\r\n                                });\r\n                                AlertDialog b=builder.create();\r\n                                b.show();\r\n                                player.onPause();\r\n                            }\r\n                        })\r\n                                    .setPlayerStartOrPauseListener(new OnPlayerStartOrPauseListener() {\r\n                                        @Override\r\n                                        public void onStartOrPause() {\r\n                                            //对话框\r\n                                            AlertDialog.Builder builder=new AlertDialog.Builder(mContext);\r\n                                            builder.setIcon(R.drawable.shangbackground);\r\n                                            builder.setTitle(\"暂停挪车\");//设置对话框的标题\r\n                                            builder.setMessage(\"挪车已暂停，是否继续挪车？\");//设置对话框的内容\r\n                                            builder.setPositiveButton(\"继续\", new DialogInterface.OnClickListener() {  //这个是设置确定按钮\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    player.startPlay();\r\n                                                }\r\n                                            });\r\n                                            builder.setNegativeButton(\"结束\", new DialogInterface.OnClickListener() {  //取消按钮\r\n\r\n                                                @Override\r\n                                                public void onClick(DialogInterface arg0, int arg1) {\r\n                                                    finish();\r\n                                                    Intent intent=new Intent(RemoteControl.this,VideoMonitoring.class);\r\n                                                    startActivity(intent);\r\n                                                }\r\n                                            });\r\n                                            AlertDialog b=builder.create();\r\n                                            b.show();\r\n                                        }\r\n                                    })\r\n                                    .setPlaySource(url6)\r\n                                    .startPlay();\r\n\r\n                        }\r\n                        break;\r\n\r\n                        default:\r\n                            break;\r\n                    }\r\n\r\n            }\r\n            @Override\r\n            public void onNothingSelected(AdapterView<?> parent) { }\r\n        });\r\n\r\n    }\r\n\r\n    @Override\r\n    protected void onPostCreate(Bundle savedInstanceState) {\r\n        super.onPostCreate(savedInstanceState);\r\n    }\r\n\r\n\r\n    //ms为需要休眠的时长\r\n    public static void sleep(long ms)\r\n    {\r\n        //uptimeMillis() Returns milliseconds since boot, not counting time spent in deep sleep.\r\n        long start = uptimeMillis();\r\n        long duration = ms;\r\n        boolean interrupted = false;\r\n        do {\r\n            try {\r\n                Thread.sleep(duration);\r\n            }\r\n            catch (InterruptedException e) {\r\n                interrupted = true;\r\n            }\r\n            duration = start + ms - uptimeMillis();\r\n        } while (duration > 0);\r\n\r\n        if (interrupted) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/dou361/jjdxm_ijkplayer/RemoteControl.java	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ app/src/main/java/com/dou361/jjdxm_ijkplayer/RemoteControl.java	(date 1606824362006)
@@ -26,7 +26,8 @@
 import com.dou361.ijkplayer.listener.OnShowThumbnailListener;
 import com.dou361.ijkplayer.widget.PlayStateParams;
 import com.dou361.ijkplayer.widget.PlayerView;
-
+import com.tencent.iot.hub.device.java.main.mqtt.MQTTSample;
+import com.tencent.iot.hub.device.java.main.shadow.SelfMqttActionCallBack;
 
 
 import java.io.BufferedReader;
@@ -52,6 +53,7 @@
 
 
     private RemoteControlInitial mParent;
+    private MQTTSample mMQTTSample;
 
     private PlayerView player;
     private Context mContext;
@@ -75,11 +77,11 @@
     private String mDevPSK  = "KdV+RSnHAlmEpM75aWZQZg=="; //若使用证书验证，设为null
     private String mSubProductID = null; // If you wont test gateway, let this to be null
     private String mSubDevName = null;
-    private String mSubDevPsk = "BuildConfig.SUB_DEVICE_PSK";
+    private String mSubDevPsk = null;
     private String mTestTopic = "2N8PWJAI0V/android_test_phone/data";    // productID/DeviceName/TopicName
-    private String mDevCertName = "YOUR_DEVICE_NAME_cert.crt";
-    private String mDevKeyName  = "YOUR_DEVICE_NAME_private.key";
-    private String mProductKey = "BuildConfig.PRODUCT_KEY";        // Used for dynamic register
+    private String mDevCertName = null;
+    private String mDevKeyName  = null;
+    private String mProductKey = null;        // Used for dynamic register
     private String mDevCert = "";           // Cert String
     private String mDevPriv = "";           // Priv String
 
@@ -111,7 +113,9 @@
 
         if (!mIsConnected) {
             Log.d(TAG, "onCreate: Connecting Mqtt");
-            //轮询连接push
+            //轮询连接
+            mMQTTSample=new MQTTSample(new SelfMqttActionCallBack(),mBrokerURL,mProductID,mDevName,mDevPSK,mSubProductID,mSubDevName,mTestTopic);
+            mMQTTSample.connect();
             sleep(2000);
         } else {
             //执行其余操作
Index: iot_core/src/androidTest/java/com/qcloud/iot/ExampleInstrumentedTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/androidTest/java/com/qcloud/iot/ExampleInstrumentedTest.java	(date 1606400383013)
+++ iot_core/src/androidTest/java/com/qcloud/iot/ExampleInstrumentedTest.java	(date 1606400383013)
@@ -0,0 +1,26 @@
+package com.qcloud.iot;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumentation test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() throws Exception {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getTargetContext();
+
+        assertEquals("com.qcloud.iot.test", appContext.getPackageName());
+    }
+}
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\n\r\nbuildscript {\r\n    repositories {\r\n        maven {\r\n            url 'https://maven.google.com'\r\n        }\r\n        maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'}\r\n        jcenter()\r\n//        google()\r\n    }\r\n    dependencies {\r\n        classpath 'com.android.tools.build:gradle:4.1.0'\r\n        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'\r\n        classpath \"com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5\"\r\n        // NOTE: Do not place your application dependencies here; they belong\r\n        // in the individual module build.gradle files\r\n    }\r\n}\r\n\r\nallprojects {\r\n    repositories {\r\n        maven {\r\n            url 'https://maven.google.com'\r\n        }\r\n        maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'}\r\n        jcenter()\r\n    }\r\n}\r\n\r\n\r\next {\r\n    compileSdkVersion = 30\r\n    buildToolsVersion = '30.0.2'\r\n\r\n    targetSdkVersion = 30\r\n    //涓荤▼搴忕増鏈�\r\n    minSdkVersion = 21\r\n    versionCode = 1\r\n    versionName = \"1.0.0.01\"\r\n    //library鐗堟湰\r\n    jjdxm_minSdkVersion = 21\r\n    jjdxm_versionCode = 1\r\n    jjdxm_versionName = \"1.0.0\"\r\n    jjdxm_v4 = 'com.android.support:support-v4:23.3.0'\r\n    jjdxm_v7 = 'com.android.support:appcompat-v7:23.3.0'\r\n}\r\n\r\ntask clean(type: Delete) {\r\n    delete rootProject.buildDir\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- build.gradle	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ build.gradle	(date 1606843549326)
@@ -10,7 +10,7 @@
 //        google()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:4.1.0'
+        classpath 'com.android.tools.build:gradle:4.1.1'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
         classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5"
         // NOTE: Do not place your application dependencies here; they belong
@@ -30,15 +30,15 @@
 
 
 ext {
-    compileSdkVersion = 30
-    buildToolsVersion = '30.0.2'
+    compileSdkVersion = 28
+    buildToolsVersion = '28.0.3'
 
-    targetSdkVersion = 30
-    //涓荤▼搴忕増鏈�
+    targetSdkVersion = 28
+    //主程序版本
     minSdkVersion = 21
     versionCode = 1
-    versionName = "1.0.0.01"
-    //library鐗堟湰
+    versionName = "1.0"
+    //library版本
     jjdxm_minSdkVersion = 21
     jjdxm_versionCode = 1
     jjdxm_versionName = "1.0.0"
Index: gradle/wrapper/gradle-wrapper.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#Tue Dec 01 14:23:33 CST 2020\r\ndistributionBase=GRADLE_USER_HOME\r\ndistributionPath=wrapper/dists\r\nzipStoreBase=GRADLE_USER_HOME\r\nzipStorePath=wrapper/dists\r\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-6.5.1-bin.zip\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- gradle/wrapper/gradle-wrapper.properties	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ gradle/wrapper/gradle-wrapper.properties	(date 1606843315730)
@@ -3,4 +3,4 @@
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-6.5.1-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-6.6.1-all.zip
Index: hub-device-java/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/build.gradle	(date 1606400383036)
+++ hub-device-java/build.gradle	(date 1606400383036)
@@ -0,0 +1,116 @@
+apply plugin: 'java-library'
+apply plugin: 'maven-publish'
+apply plugin: 'signing'
+
+
+task sourceJar(type: Jar, dependsOn: classes) {
+    classifier 'sources'
+    from sourceSets.main.allSource
+}
+
+task javadocJar(type: Jar, dependsOn: javadoc) {
+    classifier = 'javadoc'
+    from javadoc.destinationDir
+}
+
+def libVersion = '1.0.1-SNAPSHOT'
+ext.isReleaseVersion = !libVersion.endsWith("SNAPSHOT")
+publishing {
+    publications {
+        jar(MavenPublication) {
+            groupId 'com.tencent.iot.hub'
+            artifactId 'hub-device-java'
+            version libVersion
+
+            artifact(sourceJar)
+            artifact(javadocJar)
+            artifact file('build/libs/hub-device-java.jar')
+            pom {
+                name = 'hub device java'
+                description = 'Hub Device Java library'
+                url = 'https://github.com/tencentyun/iot-device-java/tree/master/hub-device-java'
+                licenses {
+                    license {
+                        name = 'Tencent Binary License'
+                        url = 'https://github.com/tencentyun/iot-device-java/blob/master/hub-device-android/LICENSE'
+                    }
+                }
+                developers {
+                    developer {
+                        id = 'tencent_archurtan'
+                        name = 'Tencent archurtan'
+                        email = 'archurtan@tencent.com'
+                    }
+                }
+                scm {
+                    url = 'scm:git@github.com:tencentyun/iot-device-java.git'
+                    connection = 'scm:git@github.com:tencentyun/iot-device-java.git'
+                    developerConnection = 'scm:git@github.com:tencentyun/iot-device-java.git'
+                }
+            }
+            pom.withXml {
+                def dependenciesNode = asNode().appendNode('dependencies')
+                configurations.implementation.allDependencies.withType(ModuleDependency) { ModuleDependency dp ->
+                    if (dp.version != "unspecified") {
+                        def dependencyNode = dependenciesNode.appendNode('dependency')
+                        dependencyNode.appendNode('groupId', dp.group)
+                        dependencyNode.appendNode('artifactId', dp.name)
+                        dependencyNode.appendNode('version', dp.version)
+
+                        // for exclusions
+                        if (dp.excludeRules.size() > 0) {
+                            def exclusions = dependencyNode.appendNode('exclusions')
+                            dp.excludeRules.each { ExcludeRule ex ->
+                                def exclusion = exclusions.appendNode('exclusion')
+                                exclusion.appendNode('groupId', ex.group)
+                                exclusion.appendNode('artifactId', ex.module)
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    repositories {
+        maven {
+            def releasesRepoUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2"
+            def snapshotsRepoUrl = "https://oss.sonatype.org/content/repositories/snapshots"
+            url = libVersion.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
+            credentials {
+                username = System.getenv("IOT_SONATYPE_USERNAME")
+                password = System.getenv("IOT_SONATYPE_PASSWORD")
+            }
+        }
+    }
+}
+
+javadoc {
+    if(JavaVersion.current().isJava8Compatible()) {
+        allprojects {
+            tasks.withType(Javadoc) {
+                options.addStringOption('Xdoclint:none', '-quiet')
+            }
+        }
+    }
+}
+
+dependencies {
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    implementation 'log4j:log4j:1.2.17'
+    implementation 'org.slf4j:slf4j-log4j12:1.8.0-beta0'
+    implementation 'org.slf4j:slf4j-api:1.8.0-beta0'
+    implementation 'org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.3'
+    implementation 'org.json:json:20190722'
+    implementation 'org.bouncycastle:bcprov-jdk15on:1.65'
+    implementation 'org.bouncycastle:bcpkix-jdk15on:1.65'
+    testImplementation 'junit:junit:4.13'
+}
+
+signing {
+    if (isReleaseVersion) {
+        sign publishing.publications.jar
+    }
+}
+
+sourceCompatibility = "7"
+targetCompatibility = "7"
Index: hub-device-java/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/.gitignore	(date 1606400383036)
+++ hub-device-java/.gitignore	(date 1606400383036)
@@ -0,0 +1,2 @@
+/build
+/data
Index: hub-device-java/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/README.md	(date 1606400383036)
+++ hub-device-java/README.md	(date 1606400383036)
@@ -0,0 +1,239 @@
+* [腾讯云物联网通信设备端 IoT Hub Java-SDK](#腾讯云物联网通信设备端-IoT-Hub-Java-SDK)
+  * [前提条件](#前提条件)
+  * [工程配置](#工程配置)
+  * [下载IoT Hub Java-SDK Demo示例代码](#下载IoT-Hub-Java-SDK-Demo示例代码)
+  * [认证连接](#认证连接)
+  * [子设备管理](#子设备管理)
+  * [设备影子](#设备影子)
+  * [API接口说明](#API接口说明)
+  * [自建服务器接入](#自建服务器接入)
+  * [Demo示例体验-设备互通](#Demo示例体验-设备互通)
+  * [Demo示例体验-设备状态上报与状态设置](#Demo示例体验-设备状态上报与状态设置)
+  * [Demo示例体验-网关子设备固件升级](#Demo示例体验-网关子设备固件升级)
+  * [常见问题](#常见问题)
+
+# 腾讯云物联网通信设备端 IoT Hub Java-SDK
+欢迎使用腾讯云物联网通信设备端 IoT Hub Java-SDK 。
+
+腾讯云物联网通信设备端 IoT Hub Java-SDK， 依靠安全且性能强大的数据通道，为物联网领域开发人员提供终端(如传感器, 执行器, 嵌入式设备或智能家电等等)和云端的双向通信能力。此文档将介绍如何获取 IoT Hub Java-SDK 并开始调用。 如果您在使用 IoT Hub Java-SDK 的过程中遇到任何问题，[欢迎在当前 GitHub 提交 Issues](https://github.com/tencentyun/iot-device-java/issues/new)。
+
+## 前提条件
+* 您需要创建一个腾讯云账号，在腾讯云控制台中开通物联网通信产品。
+* 在控制台上创建物联网产品和设备，获取产品ID、设备名称、设备证书（证书认证）、设备私钥（证书认证）、设备密钥（密钥认证），设备与云端认证连接时需要用到以上信息。具体步骤请参考官网 [控制台使用手册-设备接入准备](https://cloud.tencent.com/document/product/634/14442)。
+* 理解Topic权限，当在控制台中成功创建产品后，该产品默认有三条权限。订阅：${productId}/${deviceName}/control，订阅和发布：${productId}/${deviceName}/data，发布：${productId}/${deviceName}/event。请参考官网 [控制台使用手册-权限列表](https://cloud.tencent.com/document/product/634/14444) 操作Topic权限。
+
+## 工程配置
+
+**引用方式**
+
+-  gradle 工程 正式版SDK 远程构建
+
+    如果您想通过jar引用方式进行项目开发，可在module目录下的build.gradle中添加依赖，如下依赖：
+    ```
+    dependencies {
+        ...
+        implementation 'com.tencent.iot.hub:hub-device-java:1.0.0'
+    }
+    ```
+
+-  maven 工程 正式版SDK 远程构建
+
+    在工程根目录的pom.xml中添加：
+    ```
+    <dependencies>
+        <dependency>
+            <groupId>com.tencent.iot.hub</groupId>
+            <artifactId>hub-device-java</artifactId>
+            <version>1.0.0</version>
+        </dependency>
+    </dependencies>
+    ```
+
+-  gradle 工程 snapshot版SDK 远程构建
+
+    > 建议使用正式版SDK，SNAPSHOT版本会静默更新，使用存在风险
+
+    在工程的build.gradle中配置仓库url
+    ``` gr
+    allprojects {
+        repositories {
+            google()
+            jcenter()
+            maven {
+                url "https://oss.sonatype.org/content/repositories/snapshots"
+            }
+        }
+    }
+    ```
+    在应用模块的build.gradle中配置
+    ``` gr
+    dependencies {
+        implementation 'com.tencent.iot.hub:hub-device-java:1.0.1-SNAPSHOT'
+    }
+    ```
+
+-  maven 工程 snapshot版SDK 远程构建
+
+    > 建议使用正式版SDK，SNAPSHOT版本会静默更新，使用存在风险
+
+    在工程根目录的pom.xml中添加：
+    ```
+    <dependencies>
+        <dependency>
+            <groupId>com.tencent.iot.hub</groupId>
+            <artifactId>hub-device-java</artifactId>
+            <version>1.0.1-SNAPSHOT</version>
+        </dependency>
+    </dependencies>
+    <repositories>
+        <repository>
+            <id>snapshots</id>
+            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
+        </repository>
+    </repositories>
+    ```
+
+**Java Sdk源码**
+
+如果您想通过代码集成方式进行项目开发，可访问[Github](https://github.com/tencentyun/iot-device-java/tree/master/hub-device-java)下载Java Sdk源码。
+
+## 下载IoT Hub Java-SDK Demo示例代码
+下载[仓库](https://github.com/tencentyun/iot-device-java)下完整代码，IoT Hub Java-SDK Demo示例代码在 [hub-device-java](https://github.com/tencentyun/iot-device-java/tree/master/hub-device-java) 的module下。
+
+
+## 认证连接
+设备的身份认证支持两种方法，密钥认证和证书认证：
+- 若使用密钥认证方式，需ProductID，DevName和DevPSK；
+- 若使用证书认证方式，需ProductID，DevName，CertFile和PrivateKeyFile通过输入流解析构造双向认证SSLSocketFactory；
+```
+    String mProductID = "YOUR_PRODUCT_ID";
+    String mDevName = "YOUR_DEVICE_NAME";
+    String mDevPSK = "YOUR_DEV_PSK";
+    String mSubProductID = "YOUR_SUB_PRODUCT_ID";
+    String mSubDevName = "YOUR_SUB_DEV_NAME";
+    String mSubDevProductKey = "YOUR_SUB_DEV_PSK";
+    String mTestTopic = "YOUR_TEST_TOPIC";
+    String mCertFilePath = null;
+    String mPrivKeyFilePath = null;
+
+    TXMqttConnection mqttconnection = new TXMqttConnection(mProductID, mDevName, mDevPSK, new callBack());
+    options = new MqttConnectOptions();
+    options.setAutomaticReconnect(true);  //是否自动重连
+    if (mDevPSK != null) {
+        options.setSocketFactory(AsymcSslUtils.getSocketFactory());
+    } else {
+        options.setSocketFactory(AsymcSslUtils.getSocketFactoryByFile(workDir + mCertFilePath, workDir + mPrivKeyFilePath));
+    }
+    mqttconnection.connect(options, null);
+    try {
+            Thread.sleep(20000);
+    } catch (InterruptedException e) {
+        // TODO Auto-generated catch block
+        e.printStackTrace();
+    }
+    mqttconnection.disConnect(null);
+```
+
+## 子设备管理
+如果当前设备是一个网关，且该网关下的子设备需接入平台从而可以通过平台对子设备进行控制与管理，此时需要使用子设备管理功能。
+网关子设备管理提供了绑定子设备、解绑子设备、子设备上线、子设备下线、代理子设备数据上下行的能力。
+
+```
+  mqttconnection.gatewayBindSubdev(mSubProductID, mSubDevName, mDevPSK);
+  //mqttconnection.gatewayUnbindSubdev(mSubProductID, mSubDevName);
+
+  mqttconnection.gatewaySubdevOnline(mSubProductID, mSubDevName);
+  //mqttconnection.gatewaySubdevOffline(mSubProductID, mSubDevName);
+```
+
+## 设备影子
+为降低设备功耗和通信流量，设备通过设备影子功能，在平台缓存设备状态信息，方便其他业务使用；同时平台可通过设备影子离线配置设备，当设备上线后会更新设备影子中数据给设备，实现对设备进行配置。
+```
+  //mShadowConnection.get(null);
+  //mShadowConnection.reportNullDesiredInfo();
+
+  DeviceProperty deviceProperty = new DeviceProperty("temperature", "27", TXShadowConstants.JSONDataType.INT);
+  List<DeviceProperty> devicePropertyList = new ArrayList<>() ;
+  devicePropertyList.add(deviceProperty);
+  mShadowConnection.update(devicePropertyList, null);
+```
+
+## API接口说明
+
+### MQTT接口 ###
+MQTT的相关接口定义在[TXMqttConnection](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttConnection.java)类中，支持发布和订阅功能；如果需支持设备影子功能，则需使用TXShadowConnection类及其方法，TXMqttConnection类的接口介绍如下：
+
+| 方法名               | 说明                                                         |
+| ------------------ | ------------------------------------------------------------ |
+| connect     | MQTT连接                                         |
+| reconnect | MQTT重连                               |
+| disConnect     | 断开MQTT连接                                   |
+| publish      | 发布MQTT消息                        |
+| subscribe           | 订阅MQTT主题                                  |
+| unSubscribe   | 取消订阅MQTT主题 |
+| getConnectStatus               | 获取MQTT连接状态                      |
+| setBufferOpts      | 设置断连状态buffer缓冲区                                 |
+| initOTA      | 初始化OTA功能                                 |
+| reportCurrentFirmwareVersion      | 上报设备当前版本信息到后台服务器                      |
+| reportOTAState      | 上报设备升级状态到后台服务器                      |
+                              
+
+### MQTT网关接口 ###
+
+对于不具备直接接入以太网网络的设备，可先接入本地网关设备的网络，利用网关设备的通信功能，代理设备接入腾讯云物联网通信IoT Hub平台。对于局域网中加入或退出网络的子设备，需通过平台进行绑定或解绑操作。
+注：当子设备发起过上线，后续只要网关链接成功，后台就会显示子设备在线，除非设备发起下线操作。
+MQTT网关的相关接口定义在[TXGatewayConnection](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/gateway/TXGatewayConnection.java)类中，介绍如下：
+
+| 方法名               | 说明                                                         |
+| ------------------ | ------------------------------------------------------------ |
+| connect     | 网关MQTT连接                                         |
+| reconnect | 网关MQTT重连                               |
+| disConnect     | 断开网关MQTT连接                                   |
+| publish      | 发布MQTT消息                        |
+| subscribe           | 订阅MQTT主题                                  |
+| unSubscribe   | 取消订阅MQTT主题 |
+| getConnectStatus               | 获取MQTT连接状态                      |
+| setBufferOpts      | 设置断连状态buffer缓冲区                                 |
+| gatewaySubdevOffline           | 子设备下线                                 |
+| gatewaySubdevOnline   | 子设备上线 |
+| gatewayBindSubdev               | 子设备绑定                      |
+| gatewayUnbindSubdev      | 子设备解绑                                 |      
+| getSubdevStatus      | 获取子设备状态                                 |       
+| setSubdevStatus      | 设置子设备状态                                 |      
+| gatewayGetSubdevRelation      | 获取网关拓扑关系                                 |                
+
+### 设备影子接口 ###
+
+如果需要支持设备影子功能，需使用[TXShadowConnection](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowConnection.java)类中的方法，介绍如下：
+
+| 方法名               | 说明                                                         |
+| ------------------ | ------------------------------------------------------------ |
+| connect     | MQTT连接                                         |
+| disConnect     | 断开MQTT连接                                   |
+| publish      | 发布MQTT消息                        |
+| subscribe           | 订阅MQTT主题                                  |
+| update               | 更新设备影子文档                     |
+| get      | 获取设备影子文档                                 |
+| reportNullDesiredInfo           | 更新delta信息后，上报空的desired信息                                 |
+| setBufferOpts   | 设置断连状态buffer缓冲区 |
+| getMqttConnection               | 获取TXMqttConnection实例                      |
+| getConnectStatus      | 获取mqtt连接状态                                 |  
+| registerProperty      | 注册当前设备的设备属性                                 |  
+| unRegisterProperty      | 取消注册当前设备的指定属性                                 |  
+
+
+## 自建服务器接入
+自建服务器接入，请参考 [自建服务器接入.md](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/docs/自建服务器接入.md)
+
+## Demo示例体验-设备互通
+官网上假设的一个示例场景，请参考 [设备互通.md](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/docs/设备互通.md)
+
+## Demo示例体验-设备状态上报与状态设置
+官网上假设的一个示例场景，请参考 [设备状态上报与状态设置.md](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/docs/设备状态上报与状态设置.md)
+
+## Demo示例体验-网关子设备固件升级
+网关子设备固件升级Demo，请参考 [网关子设备固件升级.md](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/docs/网关子设备固件升级.md)
+
+## 常见问题
+
+常见问题请参考docs目录下的[常见问题java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/docs/常见问题java.md)
Index: app/src/main/java/com/dou361/jjdxm_ijkplayer/shadow/ShadowRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/dou361/jjdxm_ijkplayer/shadow/ShadowRequest.java	(date 1606840854459)
+++ app/src/main/java/com/dou361/jjdxm_ijkplayer/shadow/ShadowRequest.java	(date 1606840854459)
@@ -0,0 +1,22 @@
+package com.dou361.jjdxm_ijkplayer.shadow;
+
+
+
+public class ShadowRequest {
+
+    private int mRequestId;
+
+    public ShadowRequest() {
+    }
+
+    public ShadowRequest(int mRequestId) {
+        this.mRequestId = mRequestId;
+    }
+
+    @Override
+    public String toString() {
+        return "ShadowRequest{" +
+                "mRequestId=" + mRequestId +
+                '}';
+    }
+}
Index: app/src/main/java/com/dou361/jjdxm_ijkplayer/mqtt/MQTTSample.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/dou361/jjdxm_ijkplayer/mqtt/MQTTSample.java	(date 1606840418301)
+++ app/src/main/java/com/dou361/jjdxm_ijkplayer/mqtt/MQTTSample.java	(date 1606840418301)
@@ -0,0 +1,380 @@
+package com.dou361.jjdxm_ijkplayer.mqtt;
+
+import android.content.Context;
+import android.os.Environment;
+import android.util.Log;
+
+import com.tencent.iot.hub.device.android.core.gateway.TXGatewayConnection;
+import com.tencent.iot.hub.device.android.core.log.TXMqttLogCallBack;
+import com.tencent.iot.hub.device.android.core.util.AsymcSslUtils;
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTACallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTAConstansts;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+
+import java.io.ByteArrayInputStream;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class MQTTSample {
+
+    private static final String TAG = "TXMQTT";
+    // Default Value, should be changed in testing
+    private String mBrokerURL = null;  //传入null，即使用腾讯云物联网通信默认地址 "${ProductId}.iotcloud.tencentdevices.com:8883"  https://cloud.tencent.com/document/product/634/32546
+    private String mProductID = "PRODUCT-ID";
+    private String mDevName = "DEVICE-NAME";
+    private String mDevPSK = "DEVICE-SECRET";
+
+    private String mDevCertName = "DEVICE_CERT-NAME ";
+    private String mDevKeyName  = "DEVICE_KEY-NAME ";
+
+    private String mSubProductID = "SUBDEV_PRODUCT-ID";
+    private String mSubDevName = "SUBDEV_DEV-NAME";
+    private String mSubDevPsk = "SUBDEV_DEVICE-SECRET";
+    private String mTestTopic = "TEST_TOPIC_WITH_SUB_PUB";
+    private String mDevCert;
+    private String mDevPriv;
+
+    private boolean mMqttLogFlag;
+    private TXMqttLogCallBack mMqttLogCallBack;
+	
+    private Context mContext;
+    private String path2Store = "";
+
+    private TXMqttActionCallBack mMqttActionCallBack;
+
+    /**
+     * MQTT连接实例
+     */
+    private TXGatewayConnection mMqttConnection;
+
+    /**
+     * 请求ID
+     */
+    private static AtomicInteger requestID = new AtomicInteger(0);
+
+    public MQTTSample(Context context, TXMqttLogCallBack logCallBack, TXMqttActionCallBack callBack) {
+        mContext = context;
+        mMqttActionCallBack = callBack;
+    }
+
+    public MQTTSample(Context context, TXMqttActionCallBack callBack, String brokerURL, String productId,
+                      String devName, String devPSK, String subProductID, String subDevName, String testTopic, String devCertName, String devKeyName,
+                      Boolean mqttLogFlag, TXMqttLogCallBack logCallBack) {
+        mBrokerURL = brokerURL;
+        mProductID = productId;
+        mDevName = devName;
+        mDevPSK = devPSK;
+        mSubProductID = subProductID;
+        mSubDevName = subDevName;
+        mTestTopic = testTopic;
+        mDevCertName = devCertName;
+        mDevKeyName = devKeyName;
+
+        mMqttLogFlag = mqttLogFlag;
+        mMqttLogCallBack = logCallBack;
+
+        mContext = context;
+        mMqttActionCallBack = callBack;
+   }
+
+    public MQTTSample(Context context, TXMqttActionCallBack callBack, String brokerURL, String productId,
+                      String devName, String devPsk, String devCert, String devPriv, String subProductID, String subDevName, String testTopic, String devCertName, String devKeyName,
+                      Boolean mqttLogFlag, TXMqttLogCallBack logCallBack) {
+        mBrokerURL = brokerURL;
+        mProductID = productId;
+        mDevName = devName;
+        mDevPSK = devPsk;
+        mDevCert = devCert;
+        mDevPriv = devPriv;
+        mSubProductID = subProductID;
+        mSubDevName = subDevName;
+        mTestTopic = testTopic;
+        mDevCertName = devCertName;
+        mDevKeyName = devKeyName;
+
+        mMqttLogFlag = mqttLogFlag;
+        mMqttLogCallBack = logCallBack;
+
+        mContext = context;
+        mMqttActionCallBack = callBack;
+        path2Store = mContext.getCacheDir().getAbsolutePath();
+    }
+
+    public MQTTSample(Context context, TXMqttActionCallBack callBack, String brokerURL, String productId,
+                      String devName, String devPsk, String devCert, String devPriv, String subProductID, String subDevName, String subDevPsk, String testTopic, String devCertName, String devKeyName,
+                      Boolean mqttLogFlag, TXMqttLogCallBack logCallBack) {
+        this(context, callBack, brokerURL, productId, devName, devPsk, devCert, devPriv, subProductID, subDevName, testTopic, devCertName, devKeyName, mqttLogFlag, logCallBack);
+        mSubDevPsk = subDevPsk;
+    }
+
+    public void setSubDevPsk(String val) {
+        mSubDevPsk = val;
+    }
+
+
+    public MQTTSample(Context context, TXMqttActionCallBack callBack, String brokerURL, String productId,
+                      String devName, String devPSK, String subProductID, String subDevName, String testTopic) {
+        mBrokerURL = brokerURL;
+        mProductID = productId;
+        mDevName = devName;
+        mDevPSK = devPSK;
+        mSubProductID = subProductID;
+        mSubDevName = subDevName;
+        mTestTopic = testTopic;
+
+        mContext = context;
+        mMqttActionCallBack = callBack;
+    }
+
+    private TXOTACallBack oTACallBack = new TXOTACallBack() {
+
+        @Override
+        public void onReportFirmwareVersion(int resultCode, String version, String resultMsg) {
+
+        }
+
+        @Override
+        public boolean onLastestFirmwareReady(String url, String md5, String version) {
+            System.out.println("onLastestFirmwareReady url=" + url + " version " + version);
+            mMqttConnection.gatewayDownSubdevApp(url, path2Store + "/" + md5, md5, version);
+            return true; // false 自动触发下载升级文件  true 需要手动触发下载升级文件
+        }
+
+        @Override
+        public void onDownloadProgress(int percent, String version) {
+            mMqttConnection.gatewaySubdevReportProgress(percent, version);
+        }
+
+        @Override
+        public void onDownloadCompleted(String outputFile, String version) {
+            mMqttConnection.gatewaySubdevReportStart(version);
+            mMqttConnection.gatewaySubdevReportSuccess(version);
+        }
+
+        @Override
+        public void onDownloadFailure(int errCode, String version) {
+            mMqttConnection.gatewaySubdevReportFail(errCode, "", version);
+        }
+    };
+
+     /**
+     * 建立MQTT连接
+     */
+    public void connect() {
+        mMqttConnection = new TXGatewayConnection(mContext, mBrokerURL, mProductID, mDevName, mDevPSK,null,null ,mMqttLogFlag, mMqttLogCallBack, mMqttActionCallBack);
+        mMqttConnection.setSubDevName(mSubDevName);
+        mMqttConnection.setSubDevProductKey(mSubDevPsk);
+        mMqttConnection.setSubProductID(mSubProductID);
+        MqttConnectOptions options = new MqttConnectOptions();
+        options.setConnectionTimeout(8);
+        options.setKeepAliveInterval(240);
+        options.setAutomaticReconnect(true);
+
+        if (mDevPriv != null && mDevCert != null && mDevPriv.length() != 0 && mDevCert.length() != 0) {
+            TXLog.i(TAG, "Using cert stream " + mDevPriv + "  " + mDevCert);
+            options.setSocketFactory(AsymcSslUtils.getSocketFactoryByStream(new ByteArrayInputStream(mDevCert.getBytes()), new ByteArrayInputStream(mDevPriv.getBytes())));
+        } else if (mDevPSK != null && mDevPSK.length() != 0){
+            TXLog.i(TAG, "Using PSK");
+            options.setSocketFactory(AsymcSslUtils.getDefaultSLLContext().getSocketFactory());
+        } else {
+            TXLog.i(TAG, "Using cert assets file");
+            options.setSocketFactory(AsymcSslUtils.getSocketFactoryByAssetsFile(mContext, mDevCertName, mDevKeyName));
+        }
+
+        MQTTRequest mqttRequest = new MQTTRequest("connect", requestID.getAndIncrement());
+        mMqttConnection.connect(options, mqttRequest);
+
+        DisconnectedBufferOptions bufferOptions = new DisconnectedBufferOptions();
+        bufferOptions.setBufferEnabled(true);
+        bufferOptions.setBufferSize(1024);
+        bufferOptions.setDeleteOldestMessages(true);
+        mMqttConnection.setBufferOpts(bufferOptions);
+    }
+
+    /**
+     * 断开MQTT连接
+     */
+    public void disconnect() {
+        MQTTRequest mqttRequest = new MQTTRequest("disconnect", requestID.getAndIncrement());
+        mMqttConnection.disConnect(mqttRequest);
+    }
+
+    public void setSubdevOnline() {
+        // set subdev online
+        mMqttConnection.gatewaySubdevOnline(mSubProductID, mSubDevName);
+    }
+
+    public void setSubDevOffline() {
+        mMqttConnection.gatewaySubdevOffline(mSubProductID, mSubDevName);
+    }
+
+    public void setSubDevBinded() {
+        mMqttConnection.gatewayBindSubdev(mSubProductID, mSubDevName, mSubDevPsk);
+    }
+
+    public void setSubDevUnbinded() {
+        mMqttConnection.gatewayUnbindSubdev(mSubProductID, mSubDevName);
+    }
+
+    public void checkSubdevRelation() {
+        mMqttConnection.getGatewaySubdevRealtion();
+    }
+
+    public void getRemoteConfig() {
+        mMqttConnection.getRemoteConfig();
+    }
+
+    public void concernRemoteConfig() {
+        mMqttConnection.concernConfig();
+    }
+
+    public void reportSubDevVersion(String version) {
+        mMqttConnection.gatewaySubdevReportVer(version);
+    }
+
+    public void initOTA() {
+        TXLog.e(TAG, "path2Store " + path2Store);
+        mMqttConnection.initOTA(path2Store, oTACallBack);
+    }
+
+    /**
+     * 订阅广播主题
+     */
+    public void subscribeBroadCastTopic() {
+        // 用户上下文（请求实例）
+        MQTTRequest mqttRequest = new MQTTRequest("subscribeTopic", requestID.getAndIncrement());
+        // 订阅广播主题
+        mMqttConnection.subscribeBroadcastTopic(TXMqttConstants.QOS1, mqttRequest);
+    }
+
+    /**
+     * 订阅主题
+     *
+     */
+    public void subscribeTopic() {
+        // 主题
+        String topic = mTestTopic;
+        // QOS等级
+        int qos = TXMqttConstants.QOS1;
+        // 用户上下文（请求实例）
+        MQTTRequest mqttRequest = new MQTTRequest("subscribeTopic", requestID.getAndIncrement());
+
+        Log.d(TAG, "sub topic is " + topic);
+
+        // 订阅主题
+        mMqttConnection.subscribe(topic, qos, mqttRequest);
+
+    }
+
+    /**
+     * 取消订阅主题
+     *
+     */
+    public void unSubscribeTopic() {
+        // 主题
+        String topic = mTestTopic;
+        // 用户上下文（请求实例）
+        MQTTRequest mqttRequest = new MQTTRequest("unSubscribeTopic", requestID.getAndIncrement());
+        Log.d(TAG, "Start to unSubscribe" + topic);
+        // 取消订阅主题
+        mMqttConnection.unSubscribe(topic, mqttRequest);
+    }
+
+    /**
+     * 发布主题
+     */
+    public void publishTopic(String topicName, String data) {
+        // 主题
+        String topic = mTestTopic;
+        // MQTT消息
+        MqttMessage message = new MqttMessage();
+
+
+        message.setQos(TXMqttConstants.QOS1);
+        message.setPayload(data.getBytes());
+
+        // 用户上下文（请求实例）
+        MQTTRequest mqttRequest = new MQTTRequest("publishTopic", requestID.getAndIncrement());
+
+        Log.d(TAG, "pub topic " + topic + message);
+        // 发布主题
+        mMqttConnection.publish(topic, message, mqttRequest);
+
+    }
+
+    /**
+     * 订阅RRPC主题
+     *
+     */
+    public void subscribeRRPCTopic() {
+        // 用户上下文（请求实例）
+        MQTTRequest mqttRequest = new MQTTRequest("subscribeTopic", requestID.getAndIncrement());
+        // 订阅主题
+        mMqttConnection.subscribeRRPCTopic(TXMqttConstants.QOS0, mqttRequest);
+
+    }
+
+    /**
+     * 生成一条日志
+     * @param logLevel 日志级别：
+     *                 错误：TXMqttLogConstants.LEVEL_ERROR
+     *                 警告：TXMqttLogConstants.LEVEL_WARN
+     *                 通知：TXMqttLogConstants.LEVEL_INFO
+     *                 调试：TXMqttLogConstants.LEVEL_DEBUG
+     * @param tag
+     * @param format
+     * @param obj
+     */
+    public void mLog(int logLevel, final String tag, final String format, final Object... obj) {
+        if (mMqttLogFlag)
+            mMqttConnection.mLog(logLevel, tag, format, obj);
+    }
+
+    /**
+     * 发起一次日志上传
+     */
+    public void uploadLog() {
+        mMqttConnection.uploadLog();
+    }
+
+    public void checkFirmware() {
+
+        mMqttConnection.initOTA(Environment.getExternalStorageDirectory().getAbsolutePath(), new TXOTACallBack() {
+            @Override
+            public void onReportFirmwareVersion(int resultCode, String version, String resultMsg) {
+                TXLog.e(TAG, "onReportFirmwareVersion:" + resultCode + ", version:" + version + ", resultMsg:" + resultMsg);
+            }
+
+            @Override
+            public boolean onLastestFirmwareReady(String url, String md5, String version) {
+                TXLog.e(TAG, "MQTTSample onLastestFirmwareReady");
+                return false;
+            }
+
+            @Override
+            public void onDownloadProgress(int percent, String version) {
+                TXLog.e(TAG, "onDownloadProgress:" + percent);
+            }
+
+            @Override
+            public void onDownloadCompleted(String outputFile, String version) {
+                TXLog.e(TAG, "onDownloadCompleted:" + outputFile + ", version:" + version);
+
+                mMqttConnection.reportOTAState(TXOTAConstansts.ReportState.DONE, 0, "OK", version);
+            }
+
+            @Override
+            public void onDownloadFailure(int errCode, String version) {
+                TXLog.e(TAG, "onDownloadFailure:" + errCode);
+
+                mMqttConnection.reportOTAState(TXOTAConstansts.ReportState.FAIL, errCode, "FAIL", version);
+            }
+        });
+        mMqttConnection.reportCurrentFirmwareVersion("0.0.1");
+    }
+}
Index: app/src/main/java/com/dou361/jjdxm_ijkplayer/scenarized/Door.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/dou361/jjdxm_ijkplayer/scenarized/Door.java	(date 1606840854467)
+++ app/src/main/java/com/dou361/jjdxm_ijkplayer/scenarized/Door.java	(date 1606840854467)
@@ -0,0 +1,157 @@
+package com.dou361.jjdxm_ijkplayer.scenarized;
+
+import android.content.Context;
+
+import com.tencent.iot.hub.device.android.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.android.core.util.AsymcSslUtils;
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+
+public class Door {
+
+    public static final String TAG = "iot.scenarized.Door";
+
+    /**
+     * 产品ID
+     */
+    private static final String PRODUCT_ID = "YOUR_PRODUCT_ID";
+
+    /**
+     * 设备名称
+     */
+    private static final String DEVICE_NAME = "YOUR_DEVICE_NAME";
+
+    /**
+     * 密钥
+     */
+    private static final String SECRET_KEY = "YOUR_SECRET_KEY";
+	
+    /**
+     * 设备证书名
+     */
+    private static final String DEVICE_CERT_NAME = "YOUR_DEVICE_NAME_cert.crt";
+
+    /**
+     * 设备私钥文件名
+     */
+    private static final String DEVICE_KEY_NAME = "YOUR_DEVICE_NAME_private.key";
+
+    private static final String COME_HOME_MESSAGE = "{\"action\": \"come_home\", \"targetDevice\": \"" + Airconditioner.DEVICE_NAME + "\"}";
+    private static final String LEAVE_HOME_MESSAGE = "{\"action\": \"leave_home\", \"targetDevice\": \"" + Airconditioner.DEVICE_NAME + "\"}";
+
+    private Context mContext;
+
+    private TXMqttConnection mqttConnection;
+
+    private MqttConnectOptions options;
+
+    public Door(Context context) {
+        this.mContext = context;
+    }
+
+
+    /**
+     * 进门
+     */
+    public void enterRoom() {
+        if (mqttConnection == null) {
+            mqttConnection = new TXMqttConnection(mContext, PRODUCT_ID, DEVICE_NAME, SECRET_KEY, new DoorMqttActionCallBack());
+
+            options = new MqttConnectOptions();
+            options.setConnectionTimeout(8);
+            options.setKeepAliveInterval(240);
+            options.setAutomaticReconnect(true);
+            options.setSocketFactory(AsymcSslUtils.getSocketFactoryByAssetsFile(mContext, DEVICE_CERT_NAME, DEVICE_KEY_NAME));
+
+            mqttConnection.connect(options, null);
+            DisconnectedBufferOptions bufferOptions = new DisconnectedBufferOptions();
+            bufferOptions.setBufferEnabled(true);
+            bufferOptions.setBufferSize(1024);
+            bufferOptions.setDeleteOldestMessages(true);
+            mqttConnection.setBufferOpts(bufferOptions);
+        }
+
+        if (mqttConnection.getConnectStatus().equals(TXMqttConstants.ConnectStatus.kConnected)) {
+            MqttMessage message = new MqttMessage();
+            message.setPayload(COME_HOME_MESSAGE.getBytes());
+            String topic = String.format("%s/%s/%s", PRODUCT_ID, DEVICE_NAME, "event");
+            mqttConnection.publish(topic, message, null);
+        } else {
+            //mqttConnection.connect(options, null);
+        }
+    }
+
+    /**
+     * 出门
+     */
+    public void leaveRoom() {
+        if (null == mqttConnection) {
+            TXLog.e(TAG, "please enter room first!");
+            return;
+        }
+        MqttMessage message = new MqttMessage();
+        message.setPayload(LEAVE_HOME_MESSAGE.getBytes());
+        String topic = String.format("%s/%s/%s", PRODUCT_ID, DEVICE_NAME, "event");
+        mqttConnection.publish(topic, message, null);
+
+        closeConnection();
+    }
+
+    public void closeConnection() {
+        if (null != mqttConnection) {
+            mqttConnection.disConnect(null);
+            mqttConnection = null;
+        }
+    }
+
+    private class DoorMqttActionCallBack extends TXMqttActionCallBack {
+
+        @Override
+        public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {
+            TXLog.i(TAG, "onConnectCompleted：" + msg);
+
+            if (status.equals(Status.OK)) {
+                if (!reconnect) {
+                    MqttMessage message = new MqttMessage();
+                    message.setPayload(COME_HOME_MESSAGE.getBytes());
+                    String topic = String.format("%s/%s/%s", PRODUCT_ID, DEVICE_NAME, "event");
+                    mqttConnection.publish(topic, message, null);
+                }
+            }
+        }
+
+        @Override
+        public void onConnectionLost(Throwable cause) {
+            String logInfo = String.format("onConnectionLost, cause[%s]", cause.toString());
+            TXLog.i(TAG, logInfo);
+        }
+
+        @Override
+        public void onDisconnectCompleted(Status status, Object userContext, String msg) {
+            String logInfo = String.format("onDisconnectCompleted, status[%s], msg[%s]", status.name(), msg);
+            TXLog.i(TAG, logInfo);
+        }
+
+        @Override
+        public void onSubscribeCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+            String logInfo = String.format("onSubscribeCompleted, status[%s], message[%s]", status.name(), msg);
+            if (Status.ERROR == status) {
+                TXLog.e(TAG, logInfo);
+            } else {
+                TXLog.i(TAG, logInfo);
+            }
+        }
+
+        @Override
+        public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+            super.onPublishCompleted(status, token, userContext, msg);
+        }
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXOTAImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXOTAImpl.java	(date 1606400383046)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXOTAImpl.java	(date 1606400383046)
@@ -0,0 +1,675 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.RandomAccessFile;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.security.MessageDigest;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.device.CA;
+
+public class TXOTAImpl {
+	private static final String TAG = TXOTAImpl.class.getName();
+	private static final Logger LOG = LoggerFactory.getLogger(TXOTAImpl.class);
+	
+	private TXMqttConnection mConnection;
+	private TXOTACallBack mCallback;
+
+	private final String OTA_UPDATE_TOPIC;
+	private final String OTA_REPORT_TOPIC;
+	private final String OTA_SUB_DEV_UPDATE_TOPIC;
+	private final String OTA_SUB_DEV_REPORT_TOPIC;
+	private final String mStoragePath;
+
+	private static boolean mDownloadThreadRunning = false;
+	private static Thread mDownloadThread = null;
+
+	private boolean mSubscribedState = false;
+
+	private final int DEFAULT_CONNECT_TIMEOUT = 10000; // 毫秒
+	private final int DEFAULT_READ_TIMEOUT = 10000; // 毫秒
+	private final int MAX_TRY_TIMES = 3;
+	private static List<X509Certificate> serverCertList = null;
+	private static String[] mCosServerCaCrtList = CA.cosServerCaCrtList;
+
+	// 加载服务器证书
+	private static void prepareOTAServerCA() {
+		if (serverCertList == null) {
+			serverCertList = new ArrayList<>();
+			for (String certStr : mCosServerCaCrtList) {
+				ByteArrayInputStream caInput = null;
+				try {
+					CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+					caInput = new ByteArrayInputStream(certStr.getBytes());
+
+					X509Certificate certificate = (X509Certificate) certificateFactory.generateCertificate(caInput);
+					if (certificate != null) {
+						// TXLog.i(TAG, "add certificate:" + certificate);
+						serverCertList.add(certificate);
+					}
+				} catch (Exception e) {
+					LOG.error("{}", "prepareOTAServerCA error:", e);
+				} finally {
+					if (caInput != null) {
+						try {
+							caInput.close();
+						} catch (Exception e) {
+
+						}
+					}
+				}
+			}
+		}
+	}
+
+	/**
+	 * 构造OTA对象
+	 *
+	 * @param connection MQTT连接
+	 * @param storagePath 用于保存固件的路径（调用者须保证目录已存在，并具有写权限）
+	 * @param cosServerCaCrtList OTA升级包下载服务器的CA证书链
+	 * @param callback OTA事件回调
+	 */
+	public TXOTAImpl(TXMqttConnection connection, String storagePath, String[] cosServerCaCrtList, TXOTACallBack callback) {
+		this.mConnection = connection;
+		this.mStoragePath = storagePath;
+		this.mCallback = callback;
+
+		OTA_UPDATE_TOPIC = "$ota/update/" + mConnection.mProductId + "/" + mConnection.mDeviceName;
+		OTA_REPORT_TOPIC = "$ota/report/" + mConnection.mProductId + "/" + mConnection.mDeviceName;
+
+		OTA_SUB_DEV_UPDATE_TOPIC = "$ota/update/" + mConnection.getSubProductID() + "/" + mConnection.getSubDevName();
+		OTA_SUB_DEV_REPORT_TOPIC = "$ota/report/" + mConnection.getSubProductID() + "/" + mConnection.getSubDevName();
+
+		if (cosServerCaCrtList != null && cosServerCaCrtList.length > 0) {
+			mCosServerCaCrtList = cosServerCaCrtList;
+		}
+
+		prepareOTAServerCA();
+
+		subscribeTopic();  // 提前订阅话题
+		if (mConnection.getSubProductID() != null) { // 设置子设备时
+			subscribeSubDevTopic();  //网关子设备订阅
+		}
+	}
+
+	/**
+	 * 构造OTA对象
+	 *
+	 * @param connection MQTT连接
+	 * @param storagePath 用于保存固件的路径（调用者须保证目录已存在，并具有写权限）
+	 * @param callback OTA事件回调
+	 */
+	public TXOTAImpl(TXMqttConnection connection, String storagePath, TXOTACallBack callback) {
+		this(connection, storagePath, null, callback);
+	}
+
+	/**
+	 * 设置OTA TOPIC订阅是否成功的标记
+	 *
+	 * @param state
+	 *            true：表示订阅成功； false: 表示订阅失败
+	 */
+	public void setSubscribedState(boolean state) {
+		this.mSubscribedState = state;
+	}
+
+	/**
+	 * 处理从服务器收到的MQTT应答消息，如果OTA订阅成功的应答消息则处理，不是OTA消息则忽略
+	 *
+	 * @param status
+	 * @param token
+	 * @param userContext
+	 * @param msg
+	 */
+	public void onSubscribeCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+		System.out.println("onSubscribeCompleted status " + status);
+		if (status == Status.OK) {
+			String[] topics = token.getTopics();
+			if (topics != null) {
+				for (int i = 0; i < topics.length; i++) {
+					System.out.println("onSubscribeCompleted topic " + topics[i]);
+					if (topics[i].startsWith("$ota/")) {
+						mSubscribedState = true;
+					}
+				}
+			}
+		}
+	}
+
+	/**
+	 * 处理从服务器收到的MQTT消息，如果是OTA消息则处理，不是OTA消息则忽略
+	 *
+	 * @param topic
+	 *            来自哪个TOPIC的消息
+	 * @param message
+	 *            MQTT消息
+	 * @return 返回true, 表示此消息已由OTA模块处理；返回false，表示些消息不是OTA消息；
+	 */
+	public boolean processMessage(String topic, MqttMessage message) {
+		if (!topic.startsWith("$ota/")) {
+			return false;
+		}
+
+		try {
+			byte[] payload = message.getPayload();
+			JSONObject jsonObject = new JSONObject(new String(payload));
+
+			String type = jsonObject.getString("type");
+			if (type.equalsIgnoreCase("update_firmware")) {
+				String firmwareURL = jsonObject.getString("url");
+				String md5Sum = jsonObject.getString("md5sum");
+				String version = jsonObject.getString("version");
+
+				System.out.println("mStoragePath=" + mStoragePath);
+
+				if (!mCallback.onLastestFirmwareReady(firmwareURL, md5Sum, version)) {
+					downloadFirmware(firmwareURL, mStoragePath + "/" + md5Sum, md5Sum, version);
+				}
+			} else if (type.equalsIgnoreCase("report_version_rsp")) {
+				String resultCode = jsonObject.getString("result_code");
+				String resultMsg = jsonObject.getString("result_msg");
+				String version = jsonObject.getString("version");
+
+				if (mCallback != null) {
+					mCallback.onReportFirmwareVersion(Integer.valueOf(resultCode), version, resultMsg);
+				}
+			}
+
+		} catch (JSONException e) {
+
+		}
+
+		return true;
+	}
+
+	/**
+	 * 上报设备当前版本信息到后台服务器。
+	 *
+	 * @param currentFirmwareVersion
+	 *            设备当前版本信息
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status reportCurrentFirmwareVersion(String currentFirmwareVersion) {
+		return reportDevVersion(OTA_REPORT_TOPIC, currentFirmwareVersion);
+	}
+
+	public Status gatewaySubdevReportVer(String currentVersion) {
+		return reportDevVersion(OTA_SUB_DEV_REPORT_TOPIC, currentVersion);
+	}
+
+	/**
+	 * 上报设备当前版本信息到后台服务器。
+	 *
+	 * @param currentVersion
+	 *            设备当前版本信息
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status reportDevVersion(String topic, String currentVersion) {
+		if (!mSubscribedState) {
+			subscribeTopic(10000);
+		}
+
+		MqttMessage message = new MqttMessage();
+
+		JSONObject jsonObject = new JSONObject();
+		try {
+			jsonObject.put("type", "report_version");
+
+			JSONObject obj = new JSONObject();
+			obj.put("version", currentVersion);
+
+			jsonObject.put("report", obj);
+		} catch (JSONException e) {
+			e.printStackTrace();
+		}
+
+		message.setPayload(jsonObject.toString().getBytes());
+
+		Status status = mConnection.publish(topic, message, null);
+		System.out.println("reportDevVersion status " + status);
+
+		return status;
+	}
+
+	/**
+	 * 上报设备升级状态到后台服务器。
+	 *
+	 * @param state
+	 * @param resultCode
+	 * @param resultMsg
+	 * @param version
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status reportUpdateFirmwareState(String state, int resultCode, String resultMsg, String version) {
+		return reportMessage(OTA_REPORT_TOPIC, "report_progress", state, resultCode, resultMsg, version);
+	}
+
+	public Status reportFailedMessage(int errorCode, String errorMsg, String version) {
+		return reportMessage(OTA_SUB_DEV_REPORT_TOPIC, "report_progress", "fail", errorCode, errorMsg, version);
+	}
+
+	public Status reportSuccessMessage(String version) {
+		return reportMessage(OTA_SUB_DEV_REPORT_TOPIC, "report_progress", "done", 0, "", version);
+	}
+
+	public Status reportBurnngMessage(String version) {
+		return reportMessage(OTA_SUB_DEV_REPORT_TOPIC, "report_progress", "burning", 0, "", version);
+	}
+
+	/**
+	 * 上报设备升级状态到后台服务器。
+	 *
+	 * @param type
+	 * @param state
+	 * @param resultCode
+	 * @param resultMsg
+	 * @param version
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	private Status reportMessage(String topic, String type, String state, int resultCode, String resultMsg, String version) {
+		MqttMessage message = new MqttMessage();
+
+		JSONObject jsonObject = new JSONObject();
+		try {
+			jsonObject.put("type", type);
+
+			JSONObject reportJsonObject = new JSONObject();
+			JSONObject progressJsonObject = new JSONObject();
+
+			progressJsonObject.put("state", state);
+			progressJsonObject.put("result_code", String.valueOf(resultCode));
+			progressJsonObject.put("result_msg", resultMsg);
+
+			reportJsonObject.put("progress", progressJsonObject);
+			reportJsonObject.put("version", version);
+
+			jsonObject.put("report", reportJsonObject);
+		} catch (JSONException e) {
+
+		}
+
+		message.setQos(0);
+		message.setPayload(jsonObject.toString().getBytes());
+
+		Status status = mConnection.publish(topic, message, null);
+		return status;
+	}
+
+	/**
+	 * 上报下载进度消息到后台服务器。
+	 *
+	 * @param percent
+	 * @param version
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	private Status reportProgressMessage(String topic, int percent, String version) {
+		MqttMessage message = new MqttMessage();
+
+		JSONObject jsonObject = new JSONObject();
+		try {
+			jsonObject.put("type", "report_progress");
+
+			JSONObject reportJsonObject = new JSONObject();
+			JSONObject progressJsonObject = new JSONObject();
+
+			progressJsonObject.put("state", "downloading");
+			progressJsonObject.put("percent", String.valueOf(percent));
+			progressJsonObject.put("result_code", "0");
+			progressJsonObject.put("result_msg", "");
+			reportJsonObject.put("progress", progressJsonObject);
+			reportJsonObject.put("version", version);
+
+			jsonObject.put("report", reportJsonObject);
+
+		} catch (JSONException e) {
+
+		}
+
+		message.setQos(0);
+		message.setPayload(jsonObject.toString().getBytes());
+
+		Status status = mConnection.publish(topic, message, null);
+		return status;
+	}
+
+	/**
+	 * 订阅用于OTA升级的TOPIC
+	 *
+	 * @param timeout
+	 *            超时时间(必须大于0); 单位：毫秒
+	 * @return Status.OK：表示订阅成功时; 其它返回值表示订阅失败；
+	 */
+	private Status subscribeTopic(int timeout) {
+		Status tag = mConnection.subscribe(OTA_UPDATE_TOPIC, TXMqttConstants.QOS1, null);
+		System.out.println("tag " + tag);
+		long beginTime = System.currentTimeMillis();
+//		while (!mSubscribedState) {
+//
+//			try {
+//				Thread.sleep(100);
+//			} catch (Exception e) {
+//			}
+//
+//			if (System.currentTimeMillis() - beginTime > timeout)
+//				break;
+//		}
+
+		if (mSubscribedState) {
+			return Status.OK;
+		}
+
+		return Status.ERROR_TOPIC_UNSUBSCRIBED;
+	}
+
+	public Status subscribeTopic() {
+		return mConnection.subscribe(OTA_UPDATE_TOPIC, TXMqttConstants.QOS1, null);
+	}
+
+	public Status subscribeSubDevTopic() {
+		return mConnection.subscribe(OTA_SUB_DEV_UPDATE_TOPIC, TXMqttConstants.QOS1, null);
+	}
+
+	/**
+	 * 根据URL创建对应的HTTP或HTTPS连接对象
+	 *
+	 * @param firmwareURL
+	 *            固件URL
+	 * @return HttpURLConnection或HttpsURLConnection对象
+	 */
+	private HttpURLConnection createURLConnection(String firmwareURL) throws Exception {
+
+		if (firmwareURL.toLowerCase().startsWith("https://")) {
+			URL url = new URL(firmwareURL);
+
+			HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
+			SSLContext sslContext = SSLContext.getInstance("SSL");
+			TrustManager[] tm = { new X509TrustManager() {
+				@Override
+				public void checkClientTrusted(X509Certificate[] x509Certificates, String s)
+						throws CertificateException {
+					// Do nothing. We only want to check server side
+					// certificate.
+					LOG.warn("checkClientTrusted");
+				}
+
+				@Override
+				public void checkServerTrusted(X509Certificate[] x509Certificates, String s)
+						throws CertificateException {
+
+					if (x509Certificates == null) {
+						throw new CertificateException("check OTA server x509Certificates is null");
+					}
+
+					if (x509Certificates.length <= 0) {
+						throw new CertificateException("check OTA server x509Certificates is empty");
+					}
+
+					int match = 0;
+					for (X509Certificate cert : x509Certificates) {
+
+						try {
+							cert.checkValidity();
+
+							for (X509Certificate c : serverCertList) {
+								if (cert.equals(c))
+									match++;
+							}
+						} catch (Exception e) {
+							e.printStackTrace();
+						}
+					}
+
+					if (match > 0 && match == mCosServerCaCrtList.length) {
+						LOG.info("checkServerTrusted OK!!!");
+						return;
+					}
+
+					throw new CertificateException("check OTA server x509Certificates failed");
+				}
+
+				@Override
+				public X509Certificate[] getAcceptedIssuers() {
+					return new X509Certificate[0];
+				}
+			} };
+			sslContext.init(null, tm, new java.security.SecureRandom());
+
+			SSLSocketFactory ssf = sslContext.getSocketFactory();
+			conn.setSSLSocketFactory(ssf);
+
+			return conn;
+		}
+
+		URL url = new URL(firmwareURL);
+
+		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+
+		return conn;
+	}
+
+	public void gatewayDownSubdevApp(String firmwareURL, String outputFile, String md5Sum, String version) {
+		downloadFirmware(firmwareURL, outputFile, md5Sum, version);
+	}
+
+	public Status gatewaySubdevReportProgress(int percent, String version) {
+		return reportProgressMessage(OTA_SUB_DEV_REPORT_TOPIC, percent, version);
+	}
+
+	/**
+	 * 开启线程下载固件
+	 *
+	 * @param firmwareURL
+	 *            固件URL
+	 * @param outputFile
+	 *            固件要保存的全路径及文件名
+	 * @param md5Sum
+	 *            用于下载完成后做校验的MD5
+	 */
+	private void downloadFirmware(final String firmwareURL, final String outputFile, final String md5Sum,
+			final String version) {
+
+		if (mDownloadThreadRunning) {
+			return;
+		}
+
+		mDownloadThreadRunning = true;
+		mDownloadThread = new Thread(new Runnable() {
+			@Override
+			public void run() {
+
+				int tryTimes = 0;
+
+				do {
+					RandomAccessFile fos = null;
+					InputStream stream = null;
+
+					try {
+						tryTimes++;
+
+						fos = new RandomAccessFile(outputFile, "rw");
+						LOG.debug("fileLength " + fos.length() + " bytes");
+
+						long downloadBytes = 0;
+						int lastPercent = 0;
+
+						if (downloadBytes > 0) {
+							fos.seek(downloadBytes);
+						}
+
+						LOG.debug("connect: " + firmwareURL);
+						HttpURLConnection conn = createURLConnection(firmwareURL);
+
+						conn.setConnectTimeout(DEFAULT_CONNECT_TIMEOUT);
+						conn.setReadTimeout(DEFAULT_READ_TIMEOUT);
+						conn.setRequestProperty("Range", "bytes=" + downloadBytes + "-");
+
+						conn.connect();
+
+						int totalLength = conn.getContentLength();
+						LOG.debug("totalLength " + totalLength + " bytes");
+
+						stream = conn.getInputStream();
+						byte buffer[] = new byte[1024 * 1024];
+
+						while (downloadBytes < totalLength) {
+							int len = stream.read(buffer);
+							if (len < 0) {
+								break;
+							}
+							downloadBytes += len;
+
+							fos.write(buffer, 0, len);
+
+							int percent = (int) (((float) downloadBytes / (float) totalLength) * 100);
+
+							if (percent != lastPercent) {
+								lastPercent = percent;
+
+								if (mCallback != null) {
+									mCallback.onDownloadProgress(percent, version);
+								}
+
+								LOG.debug("download " + downloadBytes + " bytes. percent:" + percent);
+								reportProgressMessage(OTA_REPORT_TOPIC, percent, version);
+							}
+						}
+
+						if (fos != null) {
+							fos.close();
+						}
+						if (stream != null) {
+							stream.close();
+						}
+
+						String calcMD5 = fileToMD5(outputFile);
+
+						if (!calcMD5.equalsIgnoreCase(md5Sum)) {
+							LOG.error("{}", "md5 checksum not match!!!" + " calculated md5:" + calcMD5);
+
+							if (mCallback != null) {
+								mCallback.onDownloadFailure(-4, version); // 校验失败
+//								reportFailedMessage(-4, "MD5不匹配", version);
+							}
+
+							new File(outputFile).delete(); // delete
+
+							continue; // try again
+						} else {
+							if (mCallback != null) {
+//								reportSuccessMessage(version);
+								mCallback.onDownloadCompleted(outputFile, version);
+							}
+
+							break; // quit loop
+						}
+					} catch (CertificateException e) {
+						if (mCallback != null) {
+							mCallback.onDownloadFailure(-4, version); // 校验失败
+//							reportFailedMessage(-4, "MD5不匹配", version);
+						}
+					} catch (Exception e) {
+						e.printStackTrace();
+
+					} finally {
+						if (fos != null) {
+							try {
+								fos.close();
+							} catch (Exception e) {
+
+							}
+						}
+
+						if (stream != null) {
+							try {
+								stream.close();
+							} catch (Exception e) {
+
+							}
+						}
+					}
+				} while (tryTimes <= MAX_TRY_TIMES);
+				mDownloadThreadRunning = false;
+			}
+		});
+
+		mDownloadThread.start();
+	}
+
+	/**
+	 * 计算文件的MD5摘要值
+	 *
+	 * @param filePath
+	 *            全路径文件名
+	 * @return 以16进制字符表示的摘要字符串
+	 */
+	private static String fileToMD5(String filePath) {
+		InputStream inputStream = null;
+
+		try {
+			inputStream = new FileInputStream(filePath);
+
+			byte[] buffer = new byte[1024];
+			MessageDigest digest = MessageDigest.getInstance("MD5");
+
+			int numRead = 0;
+			while (numRead != -1) {
+				numRead = inputStream.read(buffer);
+				if (numRead > 0) {
+					digest.update(buffer, 0, numRead);
+				}
+			}
+
+			byte[] md5Bytes = digest.digest();
+			return convertHashToString(md5Bytes);
+		} catch (Exception e) {
+			return "";
+		} finally {
+			if (inputStream != null) {
+				try {
+					inputStream.close();
+				} catch (Exception e) {
+				}
+			}
+		}
+	}
+
+	/**
+	 * 转换摘要值为字符串形式
+	 *
+	 * @param digestBytes
+	 *            二进制摘要值
+	 * @return 以16进制字符表示的摘要字符串
+	 */
+	private static String convertHashToString(byte[] digestBytes) {
+		String returnVal = "";
+
+		for (int i = 0; i < digestBytes.length; i++) {
+			returnVal += Integer.toString((digestBytes[i] & 0xff) + 0x100, 16).substring(1);
+		}
+
+		return returnVal.toLowerCase();
+	}
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXOTAConstansts.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXOTAConstansts.java	(date 1606400383045)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXOTAConstansts.java	(date 1606400383045)
@@ -0,0 +1,10 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+
+public interface TXOTAConstansts {
+    enum ReportState {
+        BURNING,    //正在升级
+        FAIL,       //升级失败
+        DONE,       //升级完成
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttConstants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttConstants.java	(date 1606400383044)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttConstants.java	(date 1606400383044)
@@ -0,0 +1,97 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+
+public interface TXMqttConstants {
+
+    /**
+     * sdk版本号
+     */
+    String APPID = "12020126";
+
+    /**
+     * 腾讯云唯一连接地址
+     */
+    String PREFIX = "ssl://";
+
+    /**
+     * 腾讯云连接地址
+     */
+    String QCLOUD_IOT_MQTT_DIRECT_DOMAIN = ".iotcloud.tencentdevices.com:";
+
+    /**
+     * 腾讯云证书认证端口
+     */
+    String MQTT_SERVER_PORT_TLS = "8883";
+
+    /**
+     * 腾讯云密钥认证端口
+     */
+    String MQTT_SERVER_PORT_NOTLS = "1883";
+
+    /**
+     * 云端保留主题的最大长度
+     */
+    int MAX_SIZE_OF_CLOUD_TOPIC = 128;
+
+    /**
+     * 连接标识字符串最大长度
+     */
+    int MAX_CONN_ID_LEN = 5;
+
+    /**
+     * 当前MQTT连接状态
+     */
+    enum ConnectStatus {
+
+        kConnectIdle,
+
+        kConnecting,
+
+        kConnected,
+
+        kConnectFailed,
+
+        kDisconnected
+    }
+
+    /**
+     * PingReq alarm action name
+     */
+    String PING_SENDER = TXAlarmPingSender.TAG + ".pingSender.";
+
+    /**
+     * Constant for wakelock
+     */
+    String PING_WAKELOCK = TXAlarmPingSender.TAG + ".client.";
+
+    /**
+     * MQTT Command Type
+     */
+    int PUBLISH = 0;
+
+    int SUBSCRIBE = 1;
+
+    int UNSUBSCRIBE = 2;
+
+    /**
+     * QOS等级
+     */
+    int QOS0 = 0;
+
+    int QOS1 = 1;
+
+    int QOS2 = 2;
+
+    /**
+     * 消息回调信息成功信息
+     */
+    String PUBLISH_SUCCESS = "publish success";
+
+    String SUBSCRIBE_SUCCESS = "subscribe success";
+
+    String SUBSCRIBE_FAIL = "subscribe fail";
+
+    String UNSUBSCRIBE_SUCCESS = "unsubscribe success";
+
+    String MQTT_SDK_VER = "1.2.3";
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/ConnectionState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/ConnectionState.java	(date 1606400383043)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/ConnectionState.java	(date 1606400383043)
@@ -0,0 +1,15 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+public enum ConnectionState {
+    CONNECTING(0),      // 连接中
+    CONNECTED(1),   // 连接上/上线
+    CONNECTION_LOST(2), // 网络波动造成的掉线（被动触发）
+    DISCONNECTING(3),   // 断开连接中（主动触发）
+    DISCONNECTED(4);    // 断开连接（主动触发）
+
+    private int value;
+
+    ConnectionState(int value) {
+        this.value = value;
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXOTACallBack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXOTACallBack.java	(date 1606400383045)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXOTACallBack.java	(date 1606400383045)
@@ -0,0 +1,44 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+public interface TXOTACallBack {
+    /**
+     * 上报固件版本回调
+     *
+     * @param resultCode  上报结果码；0：成功；其它：失败
+     * @param version  版本；
+     * @param resultMsg  上报结果码描述
+     */
+    void onReportFirmwareVersion(int resultCode, String version, String resultMsg);
+
+    /**
+     * OTA有新的版本可以升级
+     *
+     * @param url  文件 url 用于下载最新版本
+     * @param md5  md5 值用于校验
+     * @param version  最新版本号
+     */
+    boolean onLastestFirmwareReady(String url, String md5, String version);
+
+    /**
+     * OTA升级包下载进度回调
+     *
+     * @param percent  下载进度（0 ~ 100）;
+     * @param version  版本；
+     */
+    void onDownloadProgress(int percent, String version);
+
+    /**
+     * OTA升级包下载完成回调
+     * @param outputFile  已下载完成的升级包文件名（包含全路径）；
+     * @param version  版本；
+     */
+    void onDownloadCompleted(String outputFile, String version);
+
+    /**
+     * OTA升级包下载失败回调
+     *
+     * @param errCode  失败错误码; -1: 下载超时; -2:文件不存在；-3:签名过期；-4:校验错误；-5:更新固件失败
+     * @param version  版本；
+     */
+    void onDownloadFailure(int errCode, String version);
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXWebSocketManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXWebSocketManager.java	(date 1606400383046)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXWebSocketManager.java	(date 1606400383046)
@@ -0,0 +1,78 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+
+import org.eclipse.paho.client.mqttv3.MqttException;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class TXWebSocketManager {
+
+    private String TAG = TXWebSocketManager.class.getSimpleName();
+
+    private static TXWebSocketManager instance;
+
+    private String defaultUriStr = ".iotcloud.tencentdevices.com:443";
+
+    private String PREFIX = "wss://";
+
+    private static Map<String, TXWebSocketClient> clients = new ConcurrentHashMap<>();
+
+    private TXWebSocketManager() { }
+
+    public synchronized static TXWebSocketManager getInstance() {
+        if (instance == null) {
+            instance = new TXWebSocketManager();
+        }
+        return instance;
+    }
+
+    public synchronized TXWebSocketClient getClient(String productId, String devicename) {
+        if (isEmpty(productId) || isEmpty(devicename)) {
+            System.out.println("productId or devicename empty");
+            return null;
+        }
+
+        String clientId = productId + devicename;
+
+        if (clients.containsKey(clientId) && clients.get(clientId) != null) {
+            // 集合内已经存在连接对象，不需要对连接对象做任何处理
+        } else {    // 集合内不存在连接对象，新创建一个连接对象
+            try {
+                String uriStr = PREFIX + productId + defaultUriStr;
+                TXWebSocketClient client = new TXWebSocketClient(uriStr, clientId);
+                clients.put(clientId, client);
+            } catch (MqttException e) {
+                e.printStackTrace();
+                System.out.println("e=" + e.toString());
+            }
+
+        }
+        return clients.get(clientId);
+    }
+
+    public synchronized void releaseClient(String productId, String devicename) {
+
+        // 移除对象默认关闭连接
+        String clientId = productId + devicename;
+        TXWebSocketClient clientRet = clients.remove(clientId);
+
+        // 不处于断开连接状态的对象需要被销毁
+        if (clientRet.getConnectionState() != ConnectionState.DISCONNECTED &&
+                clientRet.getConnectionState() != ConnectionState.DISCONNECTING) {
+            try {
+                clientRet.disconnect();
+            } catch (MqttException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private boolean isEmpty(String src) {
+        if (src == null || src.equals("")) {
+            return true;
+        }
+
+        return false;
+    }
+
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXWebSocketClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXWebSocketClient.java	(date 1606400383046)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXWebSocketClient.java	(date 1606400383046)
@@ -0,0 +1,204 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+import com.tencent.iot.hub.device.java.core.util.AsymcSslUtils;
+import com.tencent.iot.hub.device.java.core.util.Base64;
+import com.tencent.iot.hub.device.java.core.util.HmacSha256;
+
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttAsyncClient;
+import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttException;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.net.SocketFactory;
+
+
+public class TXWebSocketClient extends MqttAsyncClient implements MqttCallbackExtended {
+
+    private volatile TXWebSocketActionCallback connectListener;
+    private boolean automicReconnect = true;
+    private String clientId;
+    private String secretKey = null;
+    private MqttConnectOptions conOptions;
+    // 状态机
+    private AtomicReference<ConnectionState> state = new AtomicReference<>(ConnectionState.DISCONNECTED);
+
+    public TXWebSocketClient(String serverURI, String clientId) throws MqttException {
+        super(serverURI, clientId, new MemoryPersistence());
+        this.clientId = clientId;
+        setCallback(this);
+    }
+
+    // 连接接口
+    public IMqttToken connect() throws MqttException {
+        if (state.get() == ConnectionState.CONNECTED) { // 已经连接过
+            System.out.println("already connect");
+            throw new MqttException(MqttException.REASON_CODE_CLIENT_CONNECTED);
+        }
+        IMqttToken ret = super.connect(conOptions);
+        state.set(ConnectionState.CONNECTING);
+        return ret;
+    }
+
+    // 重连接口
+    public void reconnect() throws MqttException {
+        super.reconnect();
+    }
+
+    public void setSecretKey(String secretKey, SocketFactory socketFactory) {
+        this.secretKey = secretKey;
+
+        // 设置密钥之后可以进行 mqtt 连接
+        conOptions = new MqttConnectOptions();
+        String userName = generateUsername();
+        conOptions.setUserName(userName);
+        conOptions.setPassword(generatePwd(userName).toCharArray());
+        conOptions.setCleanSession(true);
+        conOptions.setSocketFactory(socketFactory);
+        conOptions.setAutomaticReconnect(true);
+        conOptions.setKeepAliveInterval(60);
+        conOptions.setMqttVersion(MqttConnectOptions.MQTT_VERSION_3_1_1);
+    }
+
+    public String getSecretKey() {
+        return secretKey;
+    }
+
+    public void setTXWebSocketActionCallback(TXWebSocketActionCallback connectListener) {
+        this.connectListener = connectListener;
+    }
+
+    public TXWebSocketActionCallback getTXWebSocketActionCallback() {
+        return this.connectListener;
+    }
+
+    // 主动断开连接
+    public synchronized IMqttToken disconnect() throws MqttException {
+        if (state.get() == ConnectionState.DISCONNECTED || state.get() == ConnectionState.DISCONNECTING) {      // 已经处于断开连接状态
+            throw new MqttException(MqttException.REASON_CODE_CLIENT_ALREADY_DISCONNECTED);
+        }
+
+        IMqttToken ret = this.disconnect(null, mActionListener);
+        state.set(ConnectionState.DISCONNECTING);   // 接口调用成功后重新设置状态
+        return ret;
+    }
+
+    private void onDisconnected() {
+        state.set(ConnectionState.DISCONNECTED);
+        if (connectListener != null) {
+            connectListener.onDisconnected();
+        }
+    }
+
+    IMqttActionListener mActionListener = new IMqttActionListener() {
+        @Override
+        public void onSuccess(IMqttToken asyncActionToken) {
+            System.out.println("disconnect onSuccess");
+            onDisconnected();
+        }
+
+        @Override
+        public void onFailure(IMqttToken asyncActionToken, Throwable cause) {
+            System.out.println("disconnect onFailure");
+            onDisconnected();
+        }
+    };
+
+    // 获取连接状态 true:上线 false:掉线
+    public ConnectionState getConnectionState() {
+        return state.get();
+    }
+
+    private String generatePwd(String userName) {
+        System.out.println("secretKey=" + secretKey);
+        if (secretKey != null) {
+            try {
+                String passWordStr = HmacSha256.getSignature(userName.getBytes(),
+                        Base64.decode(secretKey, Base64.DEFAULT)) + ";hmacsha256";
+                return passWordStr;
+            } catch (IllegalArgumentException e) {
+                System.out.println("Failed to set password");
+            }
+        }
+        return null;
+    }
+
+    private String generateUsername() {
+        Long timestamp;
+        if (automicReconnect) {
+            timestamp = (long) Integer.MAX_VALUE;
+        } else {
+            timestamp = System.currentTimeMillis() / 1000 + 600;
+        }
+
+        return clientId + ";" + TXMqttConstants.APPID + ";" + getConnectId() + ";" + timestamp;
+    }
+
+    protected String getConnectId() {
+        StringBuffer connectId = new StringBuffer();
+        for (int i = 0; i < TXMqttConstants.MAX_CONN_ID_LEN; i++) {
+            int flag = (int) (Math.random() * Integer.MAX_VALUE) % 3;
+            int randNum = (int) (Math.random() * Integer.MAX_VALUE);
+            switch (flag) {
+                case 0:
+                    connectId.append((char) (randNum % 26 + 'a'));
+                    break;
+                case 1:
+                    connectId.append((char) (randNum % 26 + 'A'));
+                    break;
+                case 2:
+                    connectId.append((char) (randNum % 10 + '0'));
+                    break;
+            }
+        }
+
+        return connectId.toString();
+    }
+
+    @Override
+    public void connectComplete(boolean reconnect, String serverURI) {
+        state.set(ConnectionState.CONNECTED);
+        System.out.println("connectComplete");
+        if (connectListener != null) {
+            connectListener.onConnected();
+        }
+
+        // 根据实际情况注释
+//        testPublish();
+    }
+
+    // 测试使用的自动发布消息
+    private void testPublish() {
+        MqttMessage msg = new MqttMessage();
+        msg.setPayload("str".getBytes());
+        msg.setQos(0);  // 最多发送一次，不做必达性保证
+        System.out.println("start send");
+        try {
+            this.publish("/", msg);
+        } catch (MqttException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void connectionLost(Throwable cause) {
+        System.out.println("connectionLost");
+        state.set(ConnectionState.CONNECTION_LOST);
+    }
+
+    @Override
+    public void messageArrived(String topic, MqttMessage message) throws Exception {
+        System.out.println("messageArrived");
+    }
+
+    @Override
+    public void deliveryComplete(IMqttDeliveryToken token) {
+        System.out.println("deliveryComplete");
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXAlarmPingSender.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXAlarmPingSender.java	(date 1606400383044)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXAlarmPingSender.java	(date 1606400383044)
@@ -0,0 +1,52 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+import org.eclipse.paho.client.mqttv3.MqttPingSender;
+import org.eclipse.paho.client.mqttv3.internal.ClientComms;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class TXAlarmPingSender implements MqttPingSender {
+	private static final Logger LOG = LoggerFactory.getLogger(TXMqttConnection.class);
+	public static final String TAG = "iot.TXAlarmPingSender";
+
+	private ClientComms mComms;
+
+	private TXAlarmPingSender that;
+	private volatile boolean hasStarted = false;
+
+	public TXAlarmPingSender() {
+		that = this;
+	}
+
+	@Override
+	public void init(ClientComms comms) {
+		this.mComms = comms;
+	}
+
+	@Override
+	public void start() {
+		String action = TXMqttConstants.PING_SENDER + mComms.getClient().getClientId();
+		System.out.println(TAG + "Register alarmreceiver to Context " + action);
+		schedule(mComms.getKeepAlive());
+		hasStarted = true;
+	}
+
+	@Override
+	public void stop() {
+		System.out.println(TAG + "Unregister alarmreceiver to Context " + mComms.getClient().getClientId());
+		if (hasStarted) {
+			hasStarted = false;
+			try {
+			} catch (IllegalArgumentException e) {
+				// Ignore unregister errors.
+			}
+		}
+	}
+
+	@Override
+	public void schedule(long delayInMilliseconds) {
+		long nextAlarmInMilliseconds = System.currentTimeMillis() + delayInMilliseconds;
+		System.out.println(TAG + "Schedule next alarm at " + nextAlarmInMilliseconds);
+	}
+
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttConnection.java	(date 1606400383044)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttConnection.java	(date 1606400383044)
@@ -0,0 +1,1009 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.device.CA;
+import com.tencent.iot.hub.device.java.core.util.Base64;
+import com.tencent.iot.hub.device.java.core.util.HmacSha256;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttAsyncClient;
+import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
+import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttException;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.eclipse.paho.client.mqttv3.internal.wire.MqttSuback;
+import org.eclipse.paho.client.mqttv3.internal.wire.MqttWireMessage;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.HashMap;
+import java.util.Iterator;
+
+
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.MQTT_SERVER_PORT_TLS;
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.PREFIX;
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.QCLOUD_IOT_MQTT_DIRECT_DOMAIN;
+
+public class TXMqttConnection implements MqttCallbackExtended {
+
+    private static final Logger LOG = LoggerFactory.getLogger(TXMqttConnection.class);
+	private static final String HMAC_SHA_256 = "HmacSHA256";
+	private static final String PRODUCT_CONFIG_PREFIX = "$config/operation/result/";
+	private String subDevVersion = "0.0";		// 未设置，则默认当前的版本是 0.0  用于上报版本号
+	/**
+	 * tcp://localhost:port ssl://localhost:port
+	 */
+	public String mServerURI;
+	public String mClientId;
+	public String mProductId;
+	public String mDeviceName;
+	public String mUserName;
+	public String mSecretKey;
+
+	private String mSubProductID;
+	private String mSubDevName;
+	private String mSubDevProductKey;
+
+	protected MqttClientPersistence mMqttPersist = null;
+	protected MqttConnectOptions mConnOptions = null;
+
+	protected MqttAsyncClient mMqttClient = null;
+
+	protected TXAlarmPingSender mPingSender = null;
+	protected TXMqttActionCallBack mActionCallBack = null;
+
+	protected HashMap<String, Integer> mSubscribedTopicMap = new HashMap<>();
+
+	private static int INVALID_MESSAGE_ID = -1;
+	protected int mLastReceivedMessageId = INVALID_MESSAGE_ID;
+
+	protected TXOTAImpl mOTAImpl = null;
+
+	public String getSubDevVersion() {
+		return subDevVersion;
+	}
+
+	public void setSubDevVersion(String version) {
+		this.subDevVersion = version;
+	}
+
+	public void setSubProductID(String subProductID) {
+		mSubProductID = subProductID;
+	}
+
+	public String getSubProductID() {
+		return mSubProductID;
+	}
+
+	public void setSubDevName(String subDevName) {
+		this.mSubDevName = subDevName;
+	}
+
+	public String getSubDevName() {
+		return mSubDevName;
+	}
+
+	public void setSubDevProductKey(String subDevProductKey) {
+		this.mSubDevProductKey = subDevProductKey;
+	}
+
+	public String getSubDevProductKey() {
+		return mSubDevProductKey;
+	}
+
+	/**
+	 * 断连状态下buffer缓冲区，当连接重新建立成功后自动将buffer中数据写出
+	 */
+	protected DisconnectedBufferOptions bufferOpts = null;
+
+	protected volatile TXMqttConstants.ConnectStatus mConnectStatus = TXMqttConstants.ConnectStatus.kConnectIdle;
+
+	/**
+	 * @param productID
+	 *            产品名
+	 * @param deviceName
+	 *            设备名，唯一
+	 * @param secretKey
+	 *            密钥
+	 * @param callBack
+	 *            连接、消息发布、消息订阅回调接口
+	 */
+	public TXMqttConnection(String productID, String deviceName, String secretKey,
+			TXMqttActionCallBack callBack) {
+		this( productID, deviceName, secretKey, null, callBack);
+	}
+	
+	public TXMqttConnection(String productID, String deviceName,
+			TXMqttActionCallBack callBack) {
+		this( productID, deviceName, null, null, callBack);
+	}
+
+	/**
+	 * @param productID
+	 *            产品名
+	 * @param deviceName
+	 *            设备名，唯一
+	 * @param secretKey
+	 *            密钥
+	 * @param bufferOpts
+	 *            发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+	 * @param callBack
+	 *            连接、消息发布、消息订阅回调接口
+	 */
+	public TXMqttConnection(String productID, String deviceName, String secretKey,
+			DisconnectedBufferOptions bufferOpts, TXMqttActionCallBack callBack) {
+		this(productID, deviceName, secretKey, bufferOpts, null, callBack);
+	}
+
+	/**
+	 * 使用腾讯云物联网通信默认地址 "${ProductId}.iotcloud.tencentdevices.com:8883"  https://cloud.tencent.com/document/product/634/32546
+	 *
+	 * @param productID
+	 *            产品名
+	 * @param deviceName
+	 *            设备名，唯一
+	 * @param secretKey
+	 *            密钥
+	 * @param bufferOpts
+	 *            发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+	 * @param clientPersistence
+	 *            消息永久存储
+	 * @param callBack
+	 *            连接、消息发布、消息订阅回调接口
+	 */
+	public TXMqttConnection(String productID, String deviceName, String secretKey,
+			DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence,
+			TXMqttActionCallBack callBack) {
+		this(null, productID, deviceName, secretKey, bufferOpts, clientPersistence, callBack);
+	}
+
+	/**
+	 * @param serverURI
+	 *            服务器URI
+	 * @param productID
+	 *            产品名
+	 * @param deviceName
+	 *            设备名，唯一
+	 * @param secretKey
+	 *            密钥
+	 * @param bufferOpts
+	 *            发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+	 * @param clientPersistence
+	 *            消息永久存储
+	 * @param callBack
+	 *            连接、消息发布、消息订阅回调接口
+	 */
+	public TXMqttConnection(String serverURI, String productID, String deviceName, String secretKey,
+			DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence,
+			TXMqttActionCallBack callBack) {
+
+		this.mSecretKey = secretKey;
+		if (serverURI == null) {
+			this.mServerURI = PREFIX + productID + QCLOUD_IOT_MQTT_DIRECT_DOMAIN + MQTT_SERVER_PORT_TLS;
+		} else {
+			this.mServerURI = serverURI;
+		}
+		this.mProductId = productID;
+		this.mClientId = productID + deviceName;
+		this.mDeviceName = deviceName;
+		this.mUserName = mClientId + ";" + TXMqttConstants.APPID;
+		this.bufferOpts = bufferOpts;
+		this.mMqttPersist = clientPersistence;
+
+		this.mActionCallBack = callBack;
+	}
+
+	/**
+	 * 设置断连状态buffer缓冲区
+	 *
+	 * @param bufferOpts
+	 */
+	public void setBufferOpts(DisconnectedBufferOptions bufferOpts) {
+		this.bufferOpts = bufferOpts;
+		mMqttClient.setBufferOpts(bufferOpts);
+	}
+
+	/**
+	 * 连接MQTT服务器，结果通过回调函数通知。
+	 *
+	 * @param options
+	 *            连接参数
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public synchronized Status connect(MqttConnectOptions options, Object userContext) {
+		if (mConnectStatus.equals(TXMqttConstants.ConnectStatus.kConnecting)) {
+			LOG.info("The client is connecting. Connect return directly.");
+			return Status.MQTT_CONNECT_IN_PROGRESS;
+		}
+
+		if (mConnectStatus.equals(TXMqttConstants.ConnectStatus.kConnected)) {
+			LOG.info("The client is already connected. Connect return directly.");
+			return Status.OK;
+		}
+
+		this.mConnOptions = options;
+		if (mConnOptions == null) {
+			LOG.error("Connect options == null, will not connect.");
+			return Status.PARAMETER_INVALID;
+		}
+
+		Long timestamp;
+		if (options.isAutomaticReconnect()) {
+			timestamp = (long) Integer.MAX_VALUE;
+		} else {
+			timestamp = System.currentTimeMillis() / 1000 + 600;
+		}
+		String userNameStr = mUserName + ";" + getConnectId() + ";" + timestamp;
+
+		mConnOptions.setUserName(userNameStr);
+
+		if (mSecretKey != null) {
+			try {
+				String passWordStr = HmacSha256.getSignature(userNameStr.getBytes(),
+						Base64.decode(mSecretKey, Base64.DEFAULT)) + ";hmacsha256";
+				mConnOptions.setPassword(passWordStr.toCharArray());
+			} catch (IllegalArgumentException e) {
+				LOG.debug("Failed to set password");
+			}
+		}
+
+		mConnOptions.setMqttVersion(MqttConnectOptions.MQTT_VERSION_3_1_1);
+
+		IMqttActionListener mActionListener = new IMqttActionListener() {
+			@Override
+			public void onSuccess(IMqttToken token) {
+				LOG.info("onSuccess!");
+				setConnectingState(TXMqttConstants.ConnectStatus.kConnected);
+				mActionCallBack.onConnectCompleted(Status.OK, false, token.getUserContext(),
+						"connected to " + mServerURI);
+			}
+
+			@Override
+			public void onFailure(IMqttToken token, Throwable exception) {
+				LOG.error(exception + "onFailure!");
+				setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+				mActionCallBack.onConnectCompleted(Status.ERROR, false, token.getUserContext(), exception.toString());
+			}
+		};
+
+		if (mMqttClient == null) {
+			try {
+				mMqttClient = new MqttAsyncClient(mServerURI, mClientId, mMqttPersist);
+				mMqttClient.setCallback(this);
+				mMqttClient.setBufferOpts(this.bufferOpts);
+				mMqttClient.setManualAcks(false);
+			} catch (Exception e) {
+				LOG.error("new MqttClient failed", e);
+				setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+				return Status.ERROR;
+			}
+		}
+
+		try {
+			IMqttToken token;
+			LOG.info("Start connecting to " + mServerURI);
+			setConnectingState(TXMqttConstants.ConnectStatus.kConnecting);
+			token = mMqttClient.connect(mConnOptions, userContext, mActionListener);
+			token.waitForCompletion(-1);
+			LOG.info("wait_for completion return");
+		} catch (Exception e) {
+			LOG.error("MqttClient connect failed", e);
+			setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+			return Status.ERROR;
+		}
+
+		return Status.OK;
+	}
+
+	/**
+	 * 重新连接, 结果通过回调函数通知。
+	 *
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public synchronized Status reconnect() {
+		if (mMqttClient == null) {
+			LOG.error("Reconnect myClient = null. Will not do reconnect");
+			return Status.MQTT_NO_CONN;
+		}
+
+		if (getConnectStatus().equals(TXMqttConstants.ConnectStatus.kConnecting)) {
+			LOG.info("The client is connecting. Reconnect return directly.");
+			return Status.MQTT_CONNECT_IN_PROGRESS;
+		}
+
+		if (mConnOptions.isAutomaticReconnect()
+				&& !getConnectStatus().equals(TXMqttConstants.ConnectStatus.kConnecting)) {
+			LOG.info("Requesting Automatic reconnect using New Java AC");
+			try {
+				mMqttClient.reconnect();
+			} catch (Exception ex) {
+				LOG.error("Exception occurred attempting to reconnect: ", ex);
+				setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+				return Status.ERROR;
+			}
+		} else if (getConnectStatus().equals(TXMqttConstants.ConnectStatus.kDisconnected)
+				&& !mConnOptions.isCleanSession()) {
+			IMqttActionListener listener = new IMqttActionListener() {
+				@Override
+				public void onSuccess(IMqttToken asyncActionToken) {
+					LOG.info("onSuccess!");
+					// mActionCallBack.onConnectCompleted(Status.OK, true,
+					// asyncActionToken.getUserContext(), "reconnected to " +
+					// mServerURI);
+				}
+
+				@Override
+				public void onFailure(IMqttToken asyncActionToken, Throwable exception) {
+					LOG.error(exception+"onFailure!");
+					setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+					mActionCallBack.onConnectCompleted(Status.ERROR, true, asyncActionToken.getUserContext(),
+							exception.toString());
+				}
+			};
+
+			try {
+				mMqttClient.connect(mConnOptions, null, listener);
+				setConnectingState(TXMqttConstants.ConnectStatus.kDisconnected);
+			} catch (Exception e) {
+				LOG.error("Exception occurred attempting to reconnect: ", e);
+				setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+				return Status.ERROR;
+			}
+		}
+
+		return Status.OK;
+	}
+
+	/**
+	 * MQTT断连，结果通过回调函数通知。
+	 *
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status disConnect(Object userContext) {
+		return disConnect(0, userContext);
+	}
+
+	/**
+	 * MQTT断连, 结果通过回调函数通知。
+	 *
+	 * @param timeout
+	 *            等待时间（必须大于0）。单位：毫秒
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status disConnect(long timeout, Object userContext) {
+		mLastReceivedMessageId = INVALID_MESSAGE_ID;
+
+		if (mOTAImpl != null) {
+			mOTAImpl.setSubscribedState(false);
+		}
+
+		if (mMqttClient != null && mMqttClient.isConnected()) {
+			IMqttActionListener mActionListener = new IMqttActionListener() {
+				@Override
+				public void onSuccess(IMqttToken asyncActionToken) {
+					setConnectingState(TXMqttConstants.ConnectStatus.kDisconnected);
+					mActionCallBack.onDisconnectCompleted(Status.OK, asyncActionToken.getUserContext(),
+							"disconnected to " + mServerURI);
+				}
+
+				@Override
+				public void onFailure(IMqttToken asyncActionToken, Throwable cause) {
+					mActionCallBack.onDisconnectCompleted(Status.ERROR, asyncActionToken.getUserContext(),
+							cause.toString());
+				}
+			};
+
+			try {
+				if (timeout <= 0) {
+					mMqttClient.disconnect(userContext, mActionListener);
+				} else {
+					mMqttClient.disconnect(timeout, userContext, mActionListener);
+				}
+			} catch (MqttException e) {
+				LOG.error(e + "manual disconnect failed.");
+				return Status.ERROR;
+			}
+		}
+
+		return Status.ERROR;
+	}
+
+	/**
+	 * 发布MQTT消息接口, 结果通过回调函数通知。
+	 *
+	 * @param topic
+	 *            topic名称
+	 * @param message
+	 *            消息内容
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status publish(String topic, MqttMessage message, Object userContext) {
+		IMqttDeliveryToken sendToken = null;
+
+		if (topic == null || topic.trim().length() == 0) {
+			LOG.error("Topic is empty!!!");
+			return Status.PARAMETER_INVALID;
+		}
+		if (topic.length() > TXMqttConstants.MAX_SIZE_OF_CLOUD_TOPIC) {
+			LOG.error("Topic length is too long!!!");
+			return Status.PARAMETER_INVALID;
+		}
+
+		LOG.info("Starting publish topic: {} Message: {}", topic, message.toString());
+		System.out.println("topic = " + topic);
+		System.out.println("message.toString() = " + message.toString());
+		//System.out.println("mMqttClient.isConnected() = " + mMqttClient.isConnected());
+		
+		System.out.println("mMqttClient != null = " + mMqttClient != null);
+		
+		if ((mMqttClient != null) && (mMqttClient.isConnected())) {
+			try {
+				sendToken = mMqttClient.publish(topic, message, userContext,
+						new QcloudMqttActionListener(TXMqttConstants.PUBLISH));
+			} catch (Exception e) {
+				LOG.error(e + "publish topic: " + topic + " failed1.");
+				return Status.ERROR;
+			}
+		} else if ((mMqttClient != null) && (this.bufferOpts != null) && (this.bufferOpts.isBufferEnabled())) { // 放入缓存
+			try {
+				sendToken = mMqttClient.publish(topic, message, userContext,
+						new QcloudMqttActionListener(TXMqttConstants.PUBLISH));
+			} catch (Exception e) {
+				LOG.error(e + "publish topic: " + topic + " failed2.");
+				return Status.ERROR;
+			}
+		} else {
+			System.out.println("1111111111111111111111111111 topic = " + topic);
+			LOG.error( "publish topic: {} failed, mMqttClient not connected and disconnect buffer not enough.", topic);
+			return Status.ERROR;
+		}
+
+		return Status.OK;
+	}
+
+	public Status getRemoteConfig() {
+		// format the payload
+		JSONObject obj = new JSONObject();
+		try {
+			obj.put("type", "get");
+		} catch (JSONException e) {
+			return Status.ERROR;
+		}
+
+		MqttMessage message = new MqttMessage();
+		// 这里添加获取到的数据
+		message.setPayload(obj.toString().getBytes());
+		message.setQos(1);
+		String topic = String.format("$config/report/%s/%s", mProductId, mDeviceName);
+		return publish(topic, message, null);
+	}
+
+	public Status concernConfig() {
+		String subscribeConfigTopic = PRODUCT_CONFIG_PREFIX + mProductId + "/" + mDeviceName;
+		return this.subscribe(subscribeConfigTopic, 1, "subscribe config topic");
+	}
+
+	public Status gatewayGetSubdevRelation() {
+
+		// format the payload
+		JSONObject obj = new JSONObject();
+		try {
+			obj.put("type", "describe_sub_devices");
+		} catch (JSONException e) {
+			return Status.ERROR;
+		}
+
+		MqttMessage message = new MqttMessage();
+		// 这里添加获取到的数据
+		message.setPayload(obj.toString().getBytes());
+		message.setQos(1);
+		String topic = String.format("$gateway/operation/%s/%s", mProductId, mDeviceName);
+		System.out.println("topic=" + topic);
+		return publish(topic, message, null);
+	}
+
+	public Status gatewayBindSubdev(String subProductID, String subDeviceName, String psk) {
+
+		// format the payload
+		JSONObject obj = new JSONObject();
+		try {
+			obj.put("type", "bind");
+			JSONObject plObj = new JSONObject();
+			JSONObject dev = new JSONObject();
+			dev.put("product_id", subProductID);
+			dev.put("device_name", subDeviceName);
+			int randNum = (int) (Math.random() * 999999);
+			dev.put("random", randNum);
+			long timestamp = System.currentTimeMillis() / 1000;
+			dev.put("timestamp", timestamp);
+			dev.put("signmethod", "hmacsha256");
+			dev.put("authtype", "psk");
+			String text2Sgin = subProductID + subDeviceName + ";" + randNum + ";" + timestamp;
+			String signStr = sign(text2Sgin, psk);
+			dev.put("signature", signStr);
+			JSONArray devs = new JSONArray();
+			devs.put(dev);
+			plObj.put("devices", devs);
+			obj.put("payload", plObj);
+		} catch (JSONException e) {
+			return Status.ERROR;
+		}
+
+		MqttMessage message = new MqttMessage();
+		// 这里添加获取到的数据
+		message.setPayload(obj.toString().getBytes());
+		message.setQos(1);
+		String topic = String.format("$gateway/operation/%s/%s", mProductId, mDeviceName);
+		System.out.println("topic=" + topic);
+		return publish(topic, message, null);
+	}
+
+	private String sign(String src, String psk) {
+		Mac mac;
+
+		try {
+			mac = Mac.getInstance(HMAC_SHA_256);
+		} catch (NoSuchAlgorithmException e) {
+			e.printStackTrace();
+			return null;
+		}
+
+		String hmacSign;
+		SecretKeySpec signKey = new SecretKeySpec(psk.getBytes(), HMAC_SHA_256);
+
+		try {
+			mac.init(signKey);
+			byte[] rawHmac = mac.doFinal(src.getBytes());
+			hmacSign = Base64.encodeToString(rawHmac, Base64.NO_WRAP);
+			return hmacSign;
+		} catch (InvalidKeyException e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+
+	public Status gatewayUnbindSubdev(String subProductID, String subDeviceName) {
+
+		// format the payload
+		JSONObject obj = new JSONObject();
+		try {
+			obj.put("type", "unbind");
+			JSONObject plObj = new JSONObject();
+			JSONObject dev = new JSONObject();
+			dev.put("product_id", subProductID);
+			dev.put("device_name", subDeviceName);
+			JSONArray devs = new JSONArray();
+			devs.put(dev);
+			plObj.put("devices", devs);
+			obj.put("payload", plObj);
+		} catch (JSONException e) {
+			return Status.ERROR;
+		}
+
+		MqttMessage message = new MqttMessage();
+		// 这里添加获取到的数据
+		message.setPayload(obj.toString().getBytes());
+		message.setQos(1);
+		String topic = String.format("$gateway/operation/%s/%s", mProductId, mDeviceName);
+		System.out.println("topic=" + topic);
+		return publish(topic, message, null);
+	}
+
+	/**
+	 * 订阅Topic, 结果通过回调函数通知。
+	 *
+	 * @param topic
+	 *            topic名称
+	 * @param qos
+	 *            QOS等级
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status subscribe(final String topic, final int qos, Object userContext) {
+		if (topic == null || topic.trim().length() == 0) {
+			LOG.error("Topic is empty!!!");
+			return Status.PARAMETER_INVALID;
+		}
+		if (topic.length() > TXMqttConstants.MAX_SIZE_OF_CLOUD_TOPIC) {
+			LOG.error("Topic length is too long!!!");
+			return Status.PARAMETER_INVALID;
+		}
+
+		LOG.info("Starting subscribe topic: " + topic);
+
+		if ((mMqttClient != null) && (mMqttClient.isConnected())) {
+			try {
+				mMqttClient.subscribe(topic, qos, userContext, new QcloudMqttActionListener(TXMqttConstants.SUBSCRIBE));
+			} catch (Exception e) {
+				LOG.error(e + "subscribe topic: {} failed.", topic);
+				return Status.ERROR;
+			}
+		} else {
+			LOG.error("subscribe topic: {} failed, because mMqttClient not connected.", topic);
+			return Status.MQTT_NO_CONN;
+		}
+
+		mSubscribedTopicMap.put(topic, qos);
+
+		return Status.OK;
+	}
+
+	/**
+	 * 取消订阅主题, 结果通过回调函数通知。
+	 *
+	 * @param topic
+	 *            要取消订阅的主题
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status unSubscribe(final String topic, Object userContext) {
+		if (topic == null || topic.trim().length() == 0) {
+			LOG.error("Topic is empty!!!");
+			return Status.PARAMETER_INVALID;
+		}
+		if (topic.length() > TXMqttConstants.MAX_SIZE_OF_CLOUD_TOPIC) {
+			LOG.error("Topic length is too long!!!");
+			return Status.PARAMETER_INVALID;
+		}
+
+		LOG.info("Starting unSubscribe topic: {}", topic);
+
+		if ((mMqttClient != null) && (mMqttClient.isConnected())) {
+			try {
+				mMqttClient.unsubscribe(topic, userContext, new QcloudMqttActionListener(TXMqttConstants.UNSUBSCRIBE));
+			} catch (Exception e) {
+				LOG.error(e + "unSubscribe topic: {} failed.", topic);
+				return Status.ERROR;
+			}
+		} else {
+			LOG.error("unSubscribe topic: {} failed, because mMqttClient not connected.", topic);
+			return Status.MQTT_NO_CONN;
+		}
+
+		mSubscribedTopicMap.remove(topic);
+
+		return Status.OK;
+	}
+
+	/**
+	 * 初始化OTA功能。
+	 *
+	 * @param storagePath
+	 *            OTA升级包存储路径(调用者必须确保路径已存在，并且具有写权限)
+	 * @param callback
+	 *            OTA事件回调
+	 */
+	public void initOTA(String storagePath, TXOTACallBack callback) {
+		mOTAImpl = new TXOTAImpl(this, storagePath, callback);
+	}
+
+	/**
+	 * 初始化OTA功能。
+	 *
+	 * @param storagePath OTA升级包存储路径(调用者必须确保路径已存在，并且具有写权限)
+	 * @param cosServerCaCrtList OTA升级包下载服务器的CA证书链
+	 * @param callback OTA事件回调
+	 */
+	public void initOTA(String storagePath, String[] cosServerCaCrtList, TXOTACallBack callback) {
+		mOTAImpl = new TXOTAImpl(this, storagePath, cosServerCaCrtList, callback);
+	}
+
+	/**
+	 * 上报设备当前版本信息到后台服务器。
+	 *
+	 * @param currentFirmwareVersion
+	 *            设备当前版本信息
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status reportCurrentFirmwareVersion(String currentFirmwareVersion) {
+		if (mOTAImpl != null && currentFirmwareVersion != null) {
+			return mOTAImpl.reportCurrentFirmwareVersion(currentFirmwareVersion);
+		}
+
+		return Status.ERROR;
+	}
+
+
+	public Status gatewaySubdevReportVer(String currentVersion) {
+		if (mOTAImpl != null && currentVersion != null) {
+			return mOTAImpl.gatewaySubdevReportVer(currentVersion);
+		}
+
+		return Status.ERROR;
+	}
+
+	//子设备上报默认的固件版本
+	public Status gatewaySubdevReportVer() {
+		if (mOTAImpl != null && getSubDevVersion() != null) {
+			return mOTAImpl.gatewaySubdevReportVer(getSubDevVersion());
+		}
+
+		return Status.ERROR;
+	}
+
+	//网关上报子设备固件下载进度
+	public void gatewayDownSubdevApp(String firmwareURL, String outputFile, String md5Sum, String version) {
+		if (mOTAImpl != null && getSubDevVersion() != null) {
+			mOTAImpl.gatewayDownSubdevApp(firmwareURL, outputFile, md5Sum, version);
+		}
+	}
+
+	//网关上报子设备固件下载进度
+	public Status gatewaySubdevReportProgress(int percent, String targetVersion) {
+		if (mOTAImpl != null && getSubDevVersion() != null) {
+			return mOTAImpl.gatewaySubdevReportProgress(percent, targetVersion);
+		}
+
+		return Status.ERROR;
+	}
+
+	//子设备上报固件开始升级
+	public Status gatewaySubdevReportStart(String targetVersion) {
+		if (mOTAImpl != null && getSubDevVersion() != null) {
+			return mOTAImpl.reportBurnngMessage(targetVersion);
+		}
+
+		return Status.ERROR;
+	}
+
+	//子设备上报固件升级成功
+	public Status gatewaySubdevReportSuccess(String targetVersion) {
+		if (mOTAImpl != null && getSubDevVersion() != null) {
+			return mOTAImpl.reportSuccessMessage(targetVersion);
+		}
+
+		return Status.ERROR;
+	}
+
+	// 上报子设备升级过程中的失败原因
+	public Status gatewaySubdevReportFail(int errorCode, String errorMsg,String targetVersion) {
+		if (mOTAImpl != null && getSubDevVersion() != null) {
+			return mOTAImpl.reportFailedMessage(errorCode, errorMsg, targetVersion);
+		}
+
+		return Status.ERROR;
+	}
+
+	/**
+	 * 上报设备升级状态到后台服务器。
+	 *
+	 * @param state
+	 *            状态
+	 * @param resultCode
+	 *            结果代码。0：表示成功；其它：表示失败；常见错误码：-1: 下载超时;
+	 *            -2:文件不存在；-3:签名过期；-4:校验错误；-5:更新固件失败
+	 * @param resultMsg
+	 *            结果描述
+	 * @param version
+	 *            版本号
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status reportOTAState(TXOTAConstansts.ReportState state, int resultCode, String resultMsg, String version) {
+		if (mOTAImpl != null) {
+			return mOTAImpl.reportUpdateFirmwareState(state.toString().toLowerCase(), resultCode, resultMsg, version);
+		}
+
+		return Status.ERROR;
+	}
+
+	/**
+	 * 设置当前连接状态
+	 *
+	 * @param connectStatus
+	 *            当前连接状态
+	 */
+	protected synchronized void setConnectingState(TXMqttConstants.ConnectStatus connectStatus) {
+		this.mConnectStatus = connectStatus;
+	}
+
+	/**
+	 * @return 当前连接状态
+	 */
+	public TXMqttConstants.ConnectStatus getConnectStatus() {
+		return this.mConnectStatus;
+	}
+
+	@Override
+	public void connectComplete(boolean reconnect, String serverURI) {
+		LOG.info("connectComplete. reconnect flag is " + reconnect);
+		setConnectingState(TXMqttConstants.ConnectStatus.kConnected);
+
+		if (!reconnect) {
+			return;
+		}
+
+		Iterator<String> it = mSubscribedTopicMap.keySet().iterator();
+		while (it.hasNext()) {
+			String topic = it.next();
+			Integer qos = mSubscribedTopicMap.get(topic);
+			try {
+				LOG.info("subscribe to {}...", topic);
+				mMqttClient.subscribe(topic, qos, null, new QcloudMqttActionListener(TXMqttConstants.SUBSCRIBE));
+			} catch (Exception e) {
+				LOG.error( "subscribe to {} failed.", topic);
+			}
+		}
+
+		mActionCallBack.onConnectCompleted(Status.OK, reconnect, null, "connected to " + serverURI);
+	}
+
+	/**
+	 * 连接丢失，回调上层
+	 *
+	 * @param cause
+	 *            连接断开原因
+	 */
+	@Override
+	public void connectionLost(Throwable cause) {
+		LOG.error("connection lost because of: {}", cause.toString());
+
+		setConnectingState(TXMqttConstants.ConnectStatus.kDisconnected);
+
+		mActionCallBack.onConnectionLost(cause);
+
+		mLastReceivedMessageId = INVALID_MESSAGE_ID;
+
+		if (mOTAImpl != null) {
+			mOTAImpl.setSubscribedState(false);
+		}
+	}
+
+	/**
+	 * 收到MQTT消息
+	 *
+	 * @param topic
+	 *            消息主题
+	 * @param message
+	 *            消息内容结构体
+	 * @throws Exception
+	 */
+	@Override
+	public void messageArrived(String topic, MqttMessage message) throws Exception {
+		if (message.getQos() > 0 && message.getId() == mLastReceivedMessageId) {
+			LOG.error("Received topic: {}, id: {}, message: {}, discard repeated message!!!",
+					topic, message.getId(), message);
+			return;
+		}
+
+		LOG.info("Received topic: {}, id: {}, message: {}", topic, message.getId(), message);
+
+		mLastReceivedMessageId = message.getId();
+
+		boolean consumed = false;
+		if (mOTAImpl != null) {
+			consumed = mOTAImpl.processMessage(topic, message);
+		}
+
+		if (mActionCallBack != null) {
+			if (!consumed) {
+				mActionCallBack.onMessageReceived(topic, message);
+			}
+		}
+	}
+
+	/**
+	 * 发布消息成功回调
+	 *
+	 * @param messageToken
+	 *            消息内容Token
+	 */
+	@Override
+	public void deliveryComplete(IMqttDeliveryToken messageToken) {
+		LOG.info("deliveryComplete, token.getMessageId:" + messageToken.getMessageId());
+	}
+
+	/**
+	 * 获取连接ID（长度为5的数字字母随机字符串）
+	 */
+	protected String getConnectId() {
+		StringBuffer connectId = new StringBuffer();
+		for (int i = 0; i < TXMqttConstants.MAX_CONN_ID_LEN; i++) {
+			int flag = (int) (Math.random() * Integer.MAX_VALUE) % 3;
+			int randNum = (int) (Math.random() * Integer.MAX_VALUE);
+			switch (flag) {
+			case 0:
+				connectId.append((char) (randNum % 26 + 'a'));
+				break;
+			case 1:
+				connectId.append((char) (randNum % 26 + 'A'));
+				break;
+			case 2:
+				connectId.append((char) (randNum % 10 + '0'));
+				break;
+			}
+		}
+
+		return connectId.toString();
+	}
+
+	/**
+	 * 事件回调
+	 */
+	private class QcloudMqttActionListener implements IMqttActionListener {
+		private int command;
+
+		public QcloudMqttActionListener(int command) {
+			this.command = command;
+		}
+
+		@Override
+		public void onSuccess(IMqttToken token) {
+
+			MqttWireMessage mqttWireMessage = token.getResponse();
+
+			switch (command) {
+			case TXMqttConstants.PUBLISH:
+				mActionCallBack.onPublishCompleted(Status.OK, token, token.getUserContext(),
+						TXMqttConstants.PUBLISH_SUCCESS);
+				break;
+
+			case TXMqttConstants.SUBSCRIBE:
+				int[] qos = ((MqttSuback) mqttWireMessage).getGrantedQos();
+				if (null != qos && qos.length >= 1 && qos[0] == 128) {
+					mActionCallBack.onSubscribeCompleted(Status.ERROR, token, token.getUserContext(),
+							TXMqttConstants.SUBSCRIBE_FAIL);
+				} else {
+					mActionCallBack.onSubscribeCompleted(Status.OK, token, token.getUserContext(),
+							TXMqttConstants.SUBSCRIBE_SUCCESS);
+
+					if (mOTAImpl != null) {
+						mOTAImpl.onSubscribeCompleted(Status.OK, token, token.getUserContext(),
+								TXMqttConstants.SUBSCRIBE_SUCCESS);
+					}
+				}
+				break;
+
+			case TXMqttConstants.UNSUBSCRIBE:
+				mActionCallBack.onUnSubscribeCompleted(Status.OK, token, token.getUserContext(),
+						TXMqttConstants.UNSUBSCRIBE_SUCCESS);
+				break;
+
+			default:
+				LOG.error("Unknown message on Success:" + token);
+				break;
+			}
+		}
+
+		@Override
+		public void onFailure(IMqttToken token, Throwable exception) {
+			switch (command) {
+			case TXMqttConstants.PUBLISH:
+				mActionCallBack.onPublishCompleted(Status.ERROR, token, token.getUserContext(), exception.toString());
+				break;
+			case TXMqttConstants.SUBSCRIBE:
+				mActionCallBack.onSubscribeCompleted(Status.ERROR, token, token.getUserContext(), exception.toString());
+				break;
+			case TXMqttConstants.UNSUBSCRIBE:
+				mActionCallBack.onUnSubscribeCompleted(Status.ERROR, token, token.getUserContext(),
+						exception.toString());
+				break;
+			default:
+				LOG.error("Unknown message on onFailure:" + token);
+				break;
+			}
+		}
+	}
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/Base64.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/Base64.java	(date 1606400383049)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/Base64.java	(date 1606400383049)
@@ -0,0 +1,741 @@
+package com.tencent.iot.hub.device.java.core.util;
+
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Utilities for encoding and decoding the Base64 representation of
+ * binary data.  See RFCs <a
+ * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
+ * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
+ */
+public class Base64 {
+    /**
+     * Default values for encoder/decoder flags.
+     */
+    public static final int DEFAULT = 0;
+
+    /**
+     * Encoder flag bit to omit the padding '=' characters at the end
+     * of the output (if any).
+     */
+    public static final int NO_PADDING = 1;
+
+    /**
+     * Encoder flag bit to omit all line terminators (i.e., the output
+     * will be on one long line).
+     */
+    public static final int NO_WRAP = 2;
+
+    /**
+     * Encoder flag bit to indicate lines should be terminated with a
+     * CRLF pair instead of just an LF.  Has no effect if {@code
+     * NO_WRAP} is specified as well.
+     */
+    public static final int CRLF = 4;
+
+    /**
+     * Encoder/decoder flag bit to indicate using the "URL and
+     * filename safe" variant of Base64 (see RFC 3548 section 4) where
+     * {@code -} and {@code _} are used in place of {@code +} and
+     * {@code /}.
+     */
+    public static final int URL_SAFE = 8;
+
+    /**
+     * Flag to pass to {@link Base64OutputStream} to indicate that it
+     * should not close the output stream it is wrapping when it
+     * itself is closed.
+     */
+    public static final int NO_CLOSE = 16;
+
+    //  --------------------------------------------------------
+    //  shared code
+    //  --------------------------------------------------------
+
+    /* package */ static abstract class Coder {
+        public byte[] output;
+        public int op;
+
+        /**
+         * Encode/decode another block of input data.  this.output is
+         * provided by the caller, and must be big enough to hold all
+         * the coded data.  On exit, this.opwill be set to the length
+         * of the coded data.
+         *
+         * @param finish true if this is the final call to process for
+         *        this object.  Will finalize the coder state and
+         *        include any final bytes in the output.
+         *
+         * @return true if the input so far is good; false if some
+         *         error has been detected in the input stream..
+         */
+        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
+
+        /**
+         * @return the maximum number of bytes a call to process()
+         * could produce for the given number of input bytes.  This may
+         * be an overestimate.
+         */
+        public abstract int maxOutputSize(int len);
+    }
+
+    //  --------------------------------------------------------
+    //  decoding
+    //  --------------------------------------------------------
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param str    the input String to decode, which is converted to
+     *               bytes using the default charset
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(String str, int flags) {
+        return decode(str.getBytes(), flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param input the input array to decode
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(byte[] input, int flags) {
+        return decode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Decode the Base64-encoded data in input and return the data in
+     * a new byte array.
+     *
+     * <p>The padding '=' characters at the end are considered optional, but
+     * if any are present, there must be the correct number of them.
+     *
+     * @param input  the data to decode
+     * @param offset the position within the input array at which to start
+     * @param len    the number of bytes of input to decode
+     * @param flags  controls certain features of the decoded output.
+     *               Pass {@code DEFAULT} to decode standard Base64.
+     *
+     * @throws IllegalArgumentException if the input contains
+     * incorrect padding
+     */
+    public static byte[] decode(byte[] input, int offset, int len, int flags) {
+        // Allocate space for the most data the input could represent.
+        // (It could contain less if it contains whitespace, etc.)
+        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
+
+        if (!decoder.process(input, offset, len, true)) {
+            throw new IllegalArgumentException("bad base-64");
+        }
+
+        // Maybe we got lucky and allocated exactly enough output space.
+        if (decoder.op == decoder.output.length) {
+            return decoder.output;
+        }
+
+        // Need to shorten the array, so allocate a new one of the
+        // right size and copy.
+        byte[] temp = new byte[decoder.op];
+        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
+        return temp;
+    }
+
+    /* package */ static class Decoder extends Coder {
+        /**
+         * Lookup table for turning bytes into their position in the
+         * Base64 alphabet.
+         */
+        private static final int DECODE[] = {
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
+            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /**
+         * Decode lookup table for the "web safe" variant (RFC 3548
+         * sec. 4) where - and _ replace + and /.
+         */
+        private static final int DECODE_WEBSAFE[] = {
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
+            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+        };
+
+        /** Non-data values in the DECODE arrays. */
+        private static final int SKIP = -1;
+        private static final int EQUALS = -2;
+
+        /**
+         * States 0-3 are reading through the next input tuple.
+         * State 4 is having read one '=' and expecting exactly
+         * one more.
+         * State 5 is expecting no more data or padding characters
+         * in the input.
+         * State 6 is the error state; an error has been detected
+         * in the input and no future input can "fix" it.
+         */
+        private int state;   // state number (0 to 6)
+        private int value;
+
+        final private int[] alphabet;
+
+        public Decoder(int flags, byte[] output) {
+            this.output = output;
+
+            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
+            state = 0;
+            value = 0;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code
+         * len} bytes could decode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 3/4 + 10;
+        }
+
+        /**
+         * Decode another block of input data.
+         *
+         * @return true if the state machine is still healthy.  false if
+         *         bad base-64 data has been detected in the input stream.
+         */
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            if (this.state == 6) return false;
+
+            int p = offset;
+            len += offset;
+
+            // Using local variables makes the decoder about 12%
+            // faster than if we manipulate the member variables in
+            // the loop.  (Even alphabet makes a measurable
+            // difference, which is somewhat surprising to me since
+            // the member variable is final.)
+            int state = this.state;
+            int value = this.value;
+            int op = 0;
+            final byte[] output = this.output;
+            final int[] alphabet = this.alphabet;
+
+            while (p < len) {
+                // Try the fast path:  we're starting a new tuple and the
+                // next four bytes of the input stream are all data
+                // bytes.  This corresponds to going through states
+                // 0-1-2-3-0.  We expect to use this method for most of
+                // the data.
+                //
+                // If any of the next four bytes of input are non-data
+                // (whitespace, etc.), value will end up negative.  (All
+                // the non-data values in decode are small negative
+                // numbers, so shifting any of them up and or'ing them
+                // together will result in a value with its top bit set.)
+                //
+                // You can remove this whole block and the output should
+                // be the same, just slower.
+                if (state == 0) {
+                    while (p+4 <= len &&
+                           (value = ((alphabet[input[p] & 0xff] << 18) |
+                                     (alphabet[input[p+1] & 0xff] << 12) |
+                                     (alphabet[input[p+2] & 0xff] << 6) |
+                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
+                        output[op+2] = (byte) value;
+                        output[op+1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        p += 4;
+                    }
+                    if (p >= len) break;
+                }
+
+                // The fast path isn't available -- either we've read a
+                // partial tuple, or the next four input bytes aren't all
+                // data, or whatever.  Fall back to the slower state
+                // machine implementation.
+
+                int d = alphabet[input[p++] & 0xff];
+
+                switch (state) {
+                case 0:
+                    if (d >= 0) {
+                        value = d;
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 1:
+                    if (d >= 0) {
+                        value = (value << 6) | d;
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 2:
+                    if (d >= 0) {
+                        value = (value << 6) | d;
+                        ++state;
+                    } else if (d == EQUALS) {
+                        // Emit the last (partial) output tuple;
+                        // expect exactly one more padding character.
+                        output[op++] = (byte) (value >> 4);
+                        state = 4;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 3:
+                    if (d >= 0) {
+                        // Emit the output triple and return to state 0.
+                        value = (value << 6) | d;
+                        output[op+2] = (byte) value;
+                        output[op+1] = (byte) (value >> 8);
+                        output[op] = (byte) (value >> 16);
+                        op += 3;
+                        state = 0;
+                    } else if (d == EQUALS) {
+                        // Emit the last (partial) output tuple;
+                        // expect no further data or padding characters.
+                        output[op+1] = (byte) (value >> 2);
+                        output[op] = (byte) (value >> 10);
+                        op += 2;
+                        state = 5;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 4:
+                    if (d == EQUALS) {
+                        ++state;
+                    } else if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+
+                case 5:
+                    if (d != SKIP) {
+                        this.state = 6;
+                        return false;
+                    }
+                    break;
+                }
+            }
+
+            if (!finish) {
+                // We're out of input, but a future call could provide
+                // more.
+                this.state = state;
+                this.value = value;
+                this.op = op;
+                return true;
+            }
+
+            // Done reading input.  Now figure out where we are left in
+            // the state machine and finish up.
+
+            switch (state) {
+            case 0:
+                // Output length is a multiple of three.  Fine.
+                break;
+            case 1:
+                // Read one extra input byte, which isn't enough to
+                // make another output byte.  Illegal.
+                this.state = 6;
+                return false;
+            case 2:
+                // Read two extra input bytes, enough to emit 1 more
+                // output byte.  Fine.
+                output[op++] = (byte) (value >> 4);
+                break;
+            case 3:
+                // Read three extra input bytes, enough to emit 2 more
+                // output bytes.  Fine.
+                output[op++] = (byte) (value >> 10);
+                output[op++] = (byte) (value >> 2);
+                break;
+            case 4:
+                // Read one padding '=' when we expected 2.  Illegal.
+                this.state = 6;
+                return false;
+            case 5:
+                // Read all the padding '='s we expected and no more.
+                // Fine.
+                break;
+            }
+
+            this.state = state;
+            this.op = op;
+            return true;
+        }
+    }
+
+    //  --------------------------------------------------------
+    //  encoding
+    //  --------------------------------------------------------
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * String with the result.
+     *
+     * @param input  the data to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int flags) {
+        try {
+            return new String(encode(input, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * String with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to
+     *               start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static String encodeToString(byte[] input, int offset, int len, int flags) {
+        try {
+            return new String(encode(input, offset, len, flags), "US-ASCII");
+        } catch (UnsupportedEncodingException e) {
+            // US-ASCII is guaranteed to be available.
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int flags) {
+        return encode(input, 0, input.length, flags);
+    }
+
+    /**
+     * Base64-encode the given data and return a newly allocated
+     * byte[] with the result.
+     *
+     * @param input  the data to encode
+     * @param offset the position within the input array at which to
+     *               start
+     * @param len    the number of bytes of input to encode
+     * @param flags  controls certain features of the encoded output.
+     *               Passing {@code DEFAULT} results in output that
+     *               adheres to RFC 2045.
+     */
+    public static byte[] encode(byte[] input, int offset, int len, int flags) {
+        Encoder encoder = new Encoder(flags, null);
+
+        // Compute the exact length of the array we will produce.
+        int output_len = len / 3 * 4;
+
+        // Account for the tail of the data and the padding bytes, if any.
+        if (encoder.do_padding) {
+            if (len % 3 > 0) {
+                output_len += 4;
+            }
+        } else {
+            switch (len % 3) {
+                case 0: break;
+                case 1: output_len += 2; break;
+                case 2: output_len += 3; break;
+            }
+        }
+
+        // Account for the newlines, if any.
+        if (encoder.do_newline && len > 0) {
+            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
+                (encoder.do_cr ? 2 : 1);
+        }
+
+        encoder.output = new byte[output_len];
+        encoder.process(input, offset, len, true);
+
+        assert encoder.op == output_len;
+
+        return encoder.output;
+    }
+
+    /* package */ static class Encoder extends Coder {
+        /**
+         * Emit a new line every this many output tuples.  Corresponds to
+         * a 76-character line length (the maximum allowable according to
+         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
+         */
+        public static final int LINE_GROUPS = 19;
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits)
+         * into output bytes.
+         */
+        private static final byte ENCODE[] = {
+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
+        };
+
+        /**
+         * Lookup table for turning Base64 alphabet positions (6 bits)
+         * into output bytes.
+         */
+        private static final byte ENCODE_WEBSAFE[] = {
+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
+            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
+        };
+
+        final private byte[] tail;
+        /* package */ int tailLen;
+        private int count;
+
+        final public boolean do_padding;
+        final public boolean do_newline;
+        final public boolean do_cr;
+        final private byte[] alphabet;
+
+        public Encoder(int flags, byte[] output) {
+            this.output = output;
+
+            do_padding = (flags & NO_PADDING) == 0;
+            do_newline = (flags & NO_WRAP) == 0;
+            do_cr = (flags & CRLF) != 0;
+            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
+
+            tail = new byte[2];
+            tailLen = 0;
+
+            count = do_newline ? LINE_GROUPS : -1;
+        }
+
+        /**
+         * @return an overestimate for the number of bytes {@code
+         * len} bytes could encode to.
+         */
+        public int maxOutputSize(int len) {
+            return len * 8/5 + 10;
+        }
+
+        public boolean process(byte[] input, int offset, int len, boolean finish) {
+            // Using local variables makes the encoder about 9% faster.
+            final byte[] alphabet = this.alphabet;
+            final byte[] output = this.output;
+            int op = 0;
+            int count = this.count;
+
+            int p = offset;
+            len += offset;
+            int v = -1;
+
+            // First we need to concatenate the tail of the previous call
+            // with any input bytes available now and see if we can empty
+            // the tail.
+
+            switch (tailLen) {
+                case 0:
+                    // There was no tail.
+                    break;
+
+                case 1:
+                    if (p+2 <= len) {
+                        // A 1-byte tail with at least 2 bytes of
+                        // input available now.
+                        v = ((tail[0] & 0xff) << 16) |
+                            ((input[p++] & 0xff) << 8) |
+                            (input[p++] & 0xff);
+                        tailLen = 0;
+                    };
+                    break;
+
+                case 2:
+                    if (p+1 <= len) {
+                        // A 2-byte tail with at least 1 byte of input.
+                        v = ((tail[0] & 0xff) << 16) |
+                            ((tail[1] & 0xff) << 8) |
+                            (input[p++] & 0xff);
+                        tailLen = 0;
+                    }
+                    break;
+            }
+
+            if (v != -1) {
+                output[op++] = alphabet[(v >> 18) & 0x3f];
+                output[op++] = alphabet[(v >> 12) & 0x3f];
+                output[op++] = alphabet[(v >> 6) & 0x3f];
+                output[op++] = alphabet[v & 0x3f];
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            // At this point either there is no tail, or there are fewer
+            // than 3 bytes of input available.
+
+            // The main loop, turning 3 input bytes into 4 output bytes on
+            // each iteration.
+            while (p+3 <= len) {
+                v = ((input[p] & 0xff) << 16) |
+                    ((input[p+1] & 0xff) << 8) |
+                    (input[p+2] & 0xff);
+                output[op] = alphabet[(v >> 18) & 0x3f];
+                output[op+1] = alphabet[(v >> 12) & 0x3f];
+                output[op+2] = alphabet[(v >> 6) & 0x3f];
+                output[op+3] = alphabet[v & 0x3f];
+                p += 3;
+                op += 4;
+                if (--count == 0) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                    count = LINE_GROUPS;
+                }
+            }
+
+            if (finish) {
+                // Finish up the tail of the input.  Note that we need to
+                // consume any bytes in tail before any bytes
+                // remaining in input; there should be at most two bytes
+                // total.
+
+                if (p-tailLen == len-1) {
+                    int t = 0;
+                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (p-tailLen == len-2) {
+                    int t = 0;
+                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
+                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
+                    tailLen -= t;
+                    output[op++] = alphabet[(v >> 12) & 0x3f];
+                    output[op++] = alphabet[(v >> 6) & 0x3f];
+                    output[op++] = alphabet[v & 0x3f];
+                    if (do_padding) {
+                        output[op++] = '=';
+                    }
+                    if (do_newline) {
+                        if (do_cr) output[op++] = '\r';
+                        output[op++] = '\n';
+                    }
+                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
+                    if (do_cr) output[op++] = '\r';
+                    output[op++] = '\n';
+                }
+
+                assert tailLen == 0;
+                assert p == len;
+            } else {
+                // Save the leftovers in tail to be consumed on the next
+                // call to encodeInternal.
+
+                if (p == len-1) {
+                    tail[tailLen++] = input[p];
+                } else if (p == len-2) {
+                    tail[tailLen++] = input[p];
+                    tail[tailLen++] = input[p+1];
+                }
+            }
+
+            this.op = op;
+            this.count = count;
+
+            return true;
+        }
+    }
+
+    private Base64() { }   // don't instantiate
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXWebSocketActionCallback.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXWebSocketActionCallback.java	(date 1606400383046)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXWebSocketActionCallback.java	(date 1606400383046)
@@ -0,0 +1,16 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+
+public interface TXWebSocketActionCallback {
+
+    // 上线回调
+    void onConnected();
+
+    void onMessageArrived(String topic, MqttMessage message);
+
+    // 掉线回调
+    void onConnectionLost(Throwable cause);
+
+    void onDisconnected();
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttActionCallBack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttActionCallBack.java	(date 1606400383044)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/mqtt/TXMqttActionCallBack.java	(date 1606400383044)
@@ -0,0 +1,82 @@
+package com.tencent.iot.hub.device.java.core.mqtt;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+
+
+public abstract class TXMqttActionCallBack {
+
+    /**
+     * MQTT Connect完成回调
+     *
+     * @param status        Status.OK: 连接成功； Status.ERROR: 连接失败
+     * @param reconnect     true: 重新连接      false: 首次连接
+     * @param userContext   用户上下文
+     * @param msg           连接信息
+     */
+    public abstract void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg);
+
+    /**
+     * MQTT连接断开回调
+     *
+     * @param cause       连接断开原因
+     */
+    public abstract void onConnectionLost(Throwable cause);
+
+    /**
+     * MQTT Disconnect完成回调
+     *
+     * @param status      Status.OK: 断连成功； Status.ERROR: 断连失败
+     * @param userContext 用户上下文
+     * @param msg         详细信息
+     */
+    public abstract void onDisconnectCompleted(Status status, Object userContext, String msg);
+
+    /**
+     * 发布消息完成回调
+     *
+     * @param status      Status.OK: 发布消息成功； Status.ERROR: 发布消息失败
+     * @param token       消息token，包含消息内容结构体
+     * @param userContext 用户上下文
+     * @param msg         详细信息
+     */
+    public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+
+    }
+
+    /**
+     * 订阅主题完成回调
+     *
+     * @param status      Status.OK: 订阅成功； Status.ERROR: 订阅失败
+     * @param token       消息token，包含消息内容结构体
+     * @param userContext 用户上下文
+     * @param msg        详细信息
+     */
+    public void onSubscribeCompleted(Status status, IMqttToken token, Object userContext,  String msg) {
+
+    }
+
+    /**
+     * 取消订阅主题完成回调
+     *
+     * @param status      Status.OK: 取消订阅成功； Status.ERROR: 取消订阅失败
+     * @param token       消息token，包含消息内容结构体
+     * @param userContext 用户上下文
+     * @param msg         详细信息
+     */
+    public void onUnSubscribeCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+
+    }
+
+    /**
+     * 收到订阅主题的消息Push
+     *
+     * @param topic        主题名称
+     * @param message      消息内容
+     */
+    public void onMessageReceived(String topic, MqttMessage message) {
+
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/SymcSslUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/SymcSslUtils.java	(date 1606400383049)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/SymcSslUtils.java	(date 1606400383049)
@@ -0,0 +1,102 @@
+package com.tencent.iot.hub.device.java.core.util;
+
+import com.tencent.iot.hub.device.java.core.device.CA;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTAImpl;
+
+import org.bouncycastle.cert.X509CertificateHolder;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.openssl.PEMParser;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.security.KeyStore;
+import java.security.Security;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.Random;
+
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManagerFactory;
+
+
+
+public class SymcSslUtils {
+
+    public static final String TAG = "iot.SymcSslUtils";
+    private static final Logger LOG = LoggerFactory.getLogger(SymcSslUtils.class);
+
+    private static String PASSWORD = String.valueOf(new Random(System.currentTimeMillis()).nextInt());
+
+    public static SSLSocketFactory getSocketFactory(String psk) {
+        Security.addProvider(new BouncyCastleProvider());
+        CertificateFactory certFactory = null;
+        try {
+            certFactory = CertificateFactory.getInstance("X.509");
+        } catch (CertificateException e) {
+            LOG.error("{}", "getSocketFactory failed, create CertificateFactory error.", e);
+        }
+
+        PEMParser parser = null;
+        X509Certificate caCert = null;
+
+        // load CA certificate
+        {
+            ByteArrayInputStream caInput = new ByteArrayInputStream(CA.caCrt.getBytes());
+            parser = new PEMParser(new InputStreamReader(caInput));
+            Object object = null;
+            try {
+                object = parser.readObject();
+            } catch (IOException e) {
+                LOG.error("{}", "parse CA failed.", e);
+                return null;
+            }
+
+            if (!(object instanceof X509CertificateHolder)) {
+                LOG.error("{}", "CA file not X509CertificateHolder.");
+                return null;
+            }
+
+            X509CertificateHolder certificateHolder = (X509CertificateHolder) object;
+            try {
+                InputStream caIn = new ByteArrayInputStream(certificateHolder.getEncoded());
+                caCert = (X509Certificate) certFactory.generateCertificate(caIn);
+                caIn.close();
+                parser.close();
+            } catch (Exception e) {
+                LOG.error("{}", "generate CA certtificate failed.", e);
+                return null;
+            }
+        }
+
+        try {
+            KeyStore caKs = KeyStore.getInstance(KeyStore.getDefaultType());
+            caKs.load(null, null);
+            caKs.setCertificateEntry("ca-certificate", caCert);
+            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+            tmf.init(caKs);
+
+            InputStream pskInput = new ByteArrayInputStream(psk.getBytes());
+            KeyStore pskStore = KeyStore.getInstance(KeyStore.getDefaultType());
+            pskStore.load(pskInput, null);
+            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+            kmf.init(pskStore, PASSWORD.toCharArray());
+
+            SSLContext context = SSLContext.getInstance("TLS");
+            context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
+
+            return context.getSocketFactory();
+
+        } catch (Exception e) {
+            LOG.error("{}", "construct SSLSocketFactory failed.", e);
+            return null;
+        }
+    }
+
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/HmacSha256.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/HmacSha256.java	(date 1606400383049)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/HmacSha256.java	(date 1606400383049)
@@ -0,0 +1,55 @@
+package com.tencent.iot.hub.device.java.core.util;
+
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * Created by jamesbonddu on 2018/5/30.
+ */
+
+
+public class HmacSha256 {
+
+    private static final String HMAC_SHA256 = "HmacSHA256";
+
+    /**
+     * 生成签名数据
+     *
+     * @param data 待加密的数据
+     * @param key  加密使用的key
+     * @return 生成16进制编码的字符串
+     */
+    public static String getSignature(byte[] data, byte[] key)  {
+        try {
+            SecretKeySpec signingKey = new SecretKeySpec(key, HMAC_SHA256);
+            Mac mac = Mac.getInstance(HMAC_SHA256);
+            mac.init(signingKey);
+
+            byte[] rawHmac = mac.doFinal(data);
+
+            return bytesToHexString(rawHmac);
+        }catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        return null;
+    }
+
+    /**
+     * byte[]数组转换为16进制的字符串
+     *
+     * @param bytes 要转换的字节数组
+     * @return 转换后的结果
+     */
+    private static String bytesToHexString(byte[] bytes) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < bytes.length; i++) {
+            String hex = Integer.toHexString(0xFF & bytes[i]);
+            if (hex.length() == 1) {
+                sb.append('0');
+            }
+            sb.append(hex);
+        }
+        return sb.toString();
+    }
+}
\ No newline at end of file
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/Asn1Object.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/Asn1Object.java	(date 1606400383048)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/Asn1Object.java	(date 1606400383048)
@@ -0,0 +1,136 @@
+package com.tencent.iot.hub.device.java.core.util;
+
+
+import java.io.IOException;
+import java.math.BigInteger;
+
+public class Asn1Object {
+
+    protected final int type;
+    protected final int length;
+    protected final byte[] value;
+    protected final int tag;
+
+    /**
+     * Construct a ASN.1 TLV. The TLV could be either a constructed or primitive
+     * entity.
+     *
+     * <p/>
+     * The first byte in DER encoding is made of following fields,
+     *
+     * <pre>
+     * -------------------------------------------------
+     * |Bit 8|Bit 7|Bit 6|Bit 5|Bit 4|Bit 3|Bit 2|Bit 1|
+     * -------------------------------------------------
+     * |  Class    | CF  |     +      Type             |
+     * -------------------------------------------------
+     * </pre>
+     *
+     * <ul>
+     * <li>Class: Universal, Application, Context or Private
+     * <li>CF: Constructed flag. If 1, the field is constructed.
+     * <li>Type: This is actually called tag in ASN.1. It indicates data type
+     * (Integer, String) or a construct (sequence, choice, set).
+     * </ul>
+     *
+     * @param tag
+     *            Tag or Identifier
+     * @param length
+     *            Length of the field
+     * @param value
+     *            Encoded octet string for the field.
+     */
+    public Asn1Object(int tag, int length, byte[] value) {
+        this.tag = tag;
+        this.type = tag & 0x1F;
+        this.length = length;
+        this.value = value;
+    }
+
+    public int getType() {
+        return type;
+    }
+
+    public int getLength() {
+        return length;
+    }
+
+    public byte[] getValue() {
+        return value;
+    }
+
+    public boolean isConstructed() {
+        return (tag & DerParser.CONSTRUCTED) == DerParser.CONSTRUCTED;
+    }
+
+    /**
+     * For constructed field, return a parser for its content.
+     *
+     * @return A parser for the construct.
+     * @throws IOException
+     *             IOException resulted from invalid file IO
+     */
+    public DerParser getParser() throws IOException {
+        if (!isConstructed())
+            throw new IOException("Invalid DER: can't parse primitive entity"); //$NON-NLS-1$
+
+        return new DerParser(value);
+    }
+
+    /**
+     * Get the value as integer
+     *
+     * @return BigInteger
+     * @throws IOException
+     *             IOException resulted from invalid file IO
+     */
+    public BigInteger getInteger() throws IOException {
+        if (type != DerParser.INTEGER)
+            throw new IOException("Invalid DER: object is not integer"); //$NON-NLS-1$
+
+        return new BigInteger(value);
+    }
+
+    /**
+     * Get value as string. Most strings are treated as Latin-1.
+     *
+     * @return Java string
+     * @throws IOException
+     *             IOException resulted from invalid file IO
+     */
+    public String getString() throws IOException {
+
+        String encoding;
+
+        switch (type) {
+
+            // Not all are Latin-1 but it's the closest thing
+            case DerParser.NUMERIC_STRING:
+            case DerParser.PRINTABLE_STRING:
+            case DerParser.VIDEOTEX_STRING:
+            case DerParser.IA5_STRING:
+            case DerParser.GRAPHIC_STRING:
+            case DerParser.ISO646_STRING:
+            case DerParser.GENERAL_STRING:
+                encoding = "ISO-8859-1"; //$NON-NLS-1$
+                break;
+
+            case DerParser.BMP_STRING:
+                encoding = "UTF-16BE"; //$NON-NLS-1$
+                break;
+
+            case DerParser.UTF8_STRING:
+                encoding = "UTF-8"; //$NON-NLS-1$
+                break;
+
+            case DerParser.UNIVERSAL_STRING:
+                throw new IOException("Invalid DER: can't handle UCS-4 string"); //$NON-NLS-1$
+
+            default:
+                throw new IOException("Invalid DER: object is not a string"); //$NON-NLS-1$
+        }
+
+        return new String(value, encoding);
+    }
+}
+
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/DerParser.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/DerParser.java	(date 1606400383049)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/DerParser.java	(date 1606400383049)
@@ -0,0 +1,163 @@
+package com.tencent.iot.hub.device.java.core.util;
+
+
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.math.BigInteger;
+
+/**
+ * A bare-minimum ASN.1 DER decoder, just having enough functions to decode
+ * PKCS#1 private keys. Especially, it doesn't handle explicitly tagged types
+ * with an outer tag.
+ *
+ * <p/>
+ * This parser can only handle one layer. To parse nested constructs, get a new
+ * parser for each layer using <code>Asn1Object.getParser()</code>.
+ *
+ * <p/>
+ * There are many DER decoders in JRE but using them will tie this program to a
+ * specific JCE/JVM.
+ *
+ * @author shockcao
+ *
+ */
+public class DerParser {
+
+    // Classes
+    public final static int UNIVERSAL = 0x00;
+    public final static int APPLICATION = 0x40;
+    public final static int CONTEXT = 0x80;
+    public final static int PRIVATE = 0xC0;
+
+    // Constructed Flag
+    public final static int CONSTRUCTED = 0x20;
+
+    // Tag and data types
+    public final static int ANY = 0x00;
+    public final static int BOOLEAN = 0x01;
+    public final static int INTEGER = 0x02;
+    public final static int BIT_STRING = 0x03;
+    public final static int OCTET_STRING = 0x04;
+    public final static int NULL = 0x05;
+    public final static int OBJECT_IDENTIFIER = 0x06;
+    public final static int REAL = 0x09;
+    public final static int ENUMERATED = 0x0a;
+    public final static int RELATIVE_OID = 0x0d;
+
+    public final static int SEQUENCE = 0x10;
+    public final static int SET = 0x11;
+
+    public final static int NUMERIC_STRING = 0x12;
+    public final static int PRINTABLE_STRING = 0x13;
+    public final static int T61_STRING = 0x14;
+    public final static int VIDEOTEX_STRING = 0x15;
+    public final static int IA5_STRING = 0x16;
+    public final static int GRAPHIC_STRING = 0x19;
+    public final static int ISO646_STRING = 0x1A;
+    public final static int GENERAL_STRING = 0x1B;
+
+    public final static int UTF8_STRING = 0x0C;
+    public final static int UNIVERSAL_STRING = 0x1C;
+    public final static int BMP_STRING = 0x1E;
+
+    public final static int UTC_TIME = 0x17;
+    public final static int GENERALIZED_TIME = 0x18;
+
+    protected InputStream in;
+
+    /**
+     * Create a new DER decoder from an input stream.
+     *
+     * @param in
+     *            The DER encoded stream
+     */
+    public DerParser(InputStream in) throws IOException {
+        this.in = in;
+    }
+
+    /**
+     * Create a new DER decoder from a byte array.
+     *
+     * @param bytes
+     *            encoded bytes
+     * @throws IOException
+     *             IOException resulted from invalid file IO
+     */
+    public DerParser(byte[] bytes) throws IOException {
+        this(new ByteArrayInputStream(bytes));
+    }
+
+    /**
+     * Read next object. If it's constructed, the value holds encoded content
+     * and it should be parsed by a new parser from
+     * <code>Asn1Object.getParser</code>.
+     *
+     * @return A object
+     * @throws IOException
+     *             IOException resulted from invalid file IO
+     */
+    public Asn1Object read() throws IOException {
+        int tag = in.read();
+
+        if (tag == -1)
+            throw new IOException("Invalid DER: stream too short, missing tag"); //$NON-NLS-1$
+
+        int length = getLength();
+
+        byte[] value = new byte[length];
+        int n = in.read(value);
+        if (n < length)
+            throw new IOException("Invalid DER: stream too short, missing value"); //$NON-NLS-1$
+
+        Asn1Object o = new Asn1Object(tag, length, value);
+
+        return o;
+    }
+
+    /**
+     * Decode the length of the field. Can only support length encoding up to 4
+     * octets.
+     *
+     * <p/>
+     * In BER/DER encoding, length can be encoded in 2 forms,
+     * <ul>
+     * <li>Short form. One octet. Bit 8 has value "0" and bits 7-1 give the
+     * length.
+     * <li>Long form. Two to 127 octets (only 4 is supported here). Bit 8 of
+     * first octet has value "1" and bits 7-1 give the number of additional
+     * length octets. Second and following octets give the length, base 256,
+     * most significant digit first.
+     * </ul>
+     *
+     * @return The length as integer
+     * @throws IOException
+     *             IOException resulted from invalid file IO
+     */
+    private int getLength() throws IOException {
+
+        int i = in.read();
+        if (i == -1)
+            throw new IOException("Invalid DER: length missing"); //$NON-NLS-1$
+
+        // A single byte short length
+        if ((i & ~0x7F) == 0)
+            return i;
+
+        int num = i & 0x7F;
+
+        // We can't handle length longer than 4 bytes
+        if (i >= 0xFF || num > 4)
+            throw new IOException("Invalid DER: length field too big (" //$NON-NLS-1$
+                    + i + ")"); //$NON-NLS-1$
+
+        byte[] bytes = new byte[num];
+        int n = in.read(bytes);
+        if (n < num)
+            throw new IOException("Invalid DER: length too short"); //$NON-NLS-1$
+
+        return new BigInteger(1, bytes).intValue();
+    }
+
+}
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectModuleManager\">\r\n    <modules>\r\n      <module fileurl=\"file://$PROJECT_DIR$/.idea/modules/zz_ijkplayer-master.iml\" filepath=\"$PROJECT_DIR$/.idea/modules/zz_ijkplayer-master.iml\" />\r\n      <module fileurl=\"file://$PROJECT_DIR$/.idea/modules/app/zz_ijkplayer-master.app.iml\" filepath=\"$PROJECT_DIR$/.idea/modules/app/zz_ijkplayer-master.app.iml\" />\r\n      <module fileurl=\"file://$PROJECT_DIR$/.idea/modules/jjdxm-ijkplayer/zz_ijkplayer-master.jjdxm-ijkplayer.iml\" filepath=\"$PROJECT_DIR$/.idea/modules/jjdxm-ijkplayer/zz_ijkplayer-master.jjdxm-ijkplayer.iml\" />\r\n    </modules>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ .idea/modules.xml	(date 1606840884043)
@@ -4,6 +4,9 @@
     <modules>
       <module fileurl="file://$PROJECT_DIR$/.idea/modules/zz_ijkplayer-master.iml" filepath="$PROJECT_DIR$/.idea/modules/zz_ijkplayer-master.iml" />
       <module fileurl="file://$PROJECT_DIR$/.idea/modules/app/zz_ijkplayer-master.app.iml" filepath="$PROJECT_DIR$/.idea/modules/app/zz_ijkplayer-master.app.iml" />
+      <module fileurl="file://$PROJECT_DIR$/.idea/modules/hub-device-java/zz_ijkplayer-master.hub-device-java.iml" filepath="$PROJECT_DIR$/.idea/modules/hub-device-java/zz_ijkplayer-master.hub-device-java.iml" />
+      <module fileurl="file://$PROJECT_DIR$/.idea/modules/iot_core/zz_ijkplayer-master.iot_core.iml" filepath="$PROJECT_DIR$/.idea/modules/iot_core/zz_ijkplayer-master.iot_core.iml" />
+      <module fileurl="file://$PROJECT_DIR$/.idea/modules/iot_service/zz_ijkplayer-master.iot_service.iml" filepath="$PROJECT_DIR$/.idea/modules/iot_service/zz_ijkplayer-master.iot_service.iml" />
       <module fileurl="file://$PROJECT_DIR$/.idea/modules/jjdxm-ijkplayer/zz_ijkplayer-master.jjdxm-ijkplayer.iml" filepath="$PROJECT_DIR$/.idea/modules/jjdxm-ijkplayer/zz_ijkplayer-master.jjdxm-ijkplayer.iml" />
     </modules>
   </component>
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/common/Status.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/common/Status.java	(date 1606400383042)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/common/Status.java	(date 1606400383042)
@@ -0,0 +1,76 @@
+package com.tencent.iot.hub.device.java.core.common;
+
+
+
+public enum Status {
+    /**
+     * Indicates that the operation succeeded
+     */
+    OK,
+
+    /**
+     * Indicates that the operation failed
+     */
+    ERROR,
+
+    /**
+     * Indicates that the operation's result may be returned asynchronously
+     */
+    NO_RESULT,
+
+    /**
+     * Indicates that the parameter is invalid
+     */
+    PARAMETER_INVALID,
+
+    /**
+     * Indicates that the MQTT connecting is in progress
+     */
+    MQTT_CONNECT_IN_PROGRESS,
+
+
+    /**
+     * Indicates that the mqtt connection is not established
+     */
+    MQTT_NO_CONN,
+
+    /**
+     * Indicates that the mqtt topic is not subscribed
+     */
+    ERROR_TOPIC_UNSUBSCRIBED,
+
+    /**
+     * 表示超过JSON文档中的最大TOKEN数
+     */
+    ERR_MAX_JSON_TOKEN,
+
+    /**
+     * 表示文档请求数超并发
+     */
+    ERR_MAX_APPENDING_REQUEST,
+
+    /**
+     * 表示JSON构造错误
+     */
+    ERR_JSON_CONSTRUCT,
+
+    /**
+     *  子设备初始状态
+     */
+    SUBDEV_STAT_INIT,
+
+    /**
+     *  子设备在线状态
+     */
+    SUBDEV_STAT_ONLINE,
+
+    /**
+     *  子设备掉线状态
+     */
+    SUBDEV_STAT_OFFLINE,
+
+    /**
+     *  子设备不存在
+     */
+    SUBDEV_STAT_NOT_EXIST
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/AsymcSslUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/AsymcSslUtils.java	(date 1606400383048)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/util/AsymcSslUtils.java	(date 1606400383048)
@@ -0,0 +1,391 @@
+package com.tencent.iot.hub.device.java.core.util;
+
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.math.BigInteger;
+import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.KeyFactory;
+import java.security.KeyStore;
+import java.security.PrivateKey;
+import java.security.Security;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.security.spec.KeySpec;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.security.spec.RSAPrivateCrtKeySpec;
+import java.util.Random;
+
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManagerFactory;
+
+import org.bouncycastle.cert.X509CertificateHolder;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.openssl.PEMParser;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.tencent.iot.hub.device.java.core.device.CA;
+
+
+
+public class AsymcSslUtils {
+
+    public static final String TAG = "iot.AsymcSslUtils";
+    private static final Logger LOG = LoggerFactory.getLogger(AsymcSslUtils.class);
+    
+    private static String PASSWORD = String.valueOf(new Random(System.currentTimeMillis()).nextInt());
+
+    /**
+     * 读取resouce文件
+     * 
+     * 证书文件及Key文件存放在Android asset目录下，通过AssetManager读取文件内容获取输入流，
+     * 通过输入流构造双向认证SSLSocketFactory
+     *
+     * @param clientCrtFileName    客户端证书文件名
+     * @param clientPriKeyFileName 客户端私钥文件名
+     * @return
+     */
+    public static SSLSocketFactory getSocketFactoryByAssetsFile(final String clientCrtFileName, final String clientPriKeyFileName) {
+        SSLSocketFactory factory = null;
+        InputStream clientInputStream = null;
+        InputStream keyInputStream = null;
+        clientInputStream=AsymcSslUtils.class.getClassLoader().getResourceAsStream(clientCrtFileName);
+        keyInputStream=AsymcSslUtils.class.getClassLoader().getResourceAsStream(clientPriKeyFileName);
+        factory = getSocketFactoryByStream(clientInputStream, keyInputStream);
+
+        return factory;
+    }
+
+    /**
+     * 证书文件及Key文件存放在Android 本地存储中，通过FileInputStream读取文件内容输入流
+     * 通过输入流解析构造双向认证SSLSocketFactory
+     *
+     * @param clientCrtFileName    客户端证书文件名，要求全路径
+     * @param clientPriKeyFileName 客户端私钥文件名，要求全路径
+     * @return
+     */
+    public static SSLSocketFactory getSocketFactoryByFile(final String clientCrtFileName, final String clientPriKeyFileName) {
+        InputStream clientInputStream = null;
+        InputStream keyInputStream = null;
+        SSLSocketFactory factory = null;
+
+        try {
+            clientInputStream = new FileInputStream(new File(clientCrtFileName));
+            keyInputStream = new FileInputStream(new File(clientPriKeyFileName));
+
+            factory = getSocketFactoryByStream(clientInputStream, keyInputStream);;
+        } catch (FileNotFoundException e) {
+            LOG.error("{}", "getSocketFactory failed, cannot open CRT Files.", e);
+        }finally {
+            if (clientInputStream != null) {
+                try {
+                    clientInputStream.close();
+                }catch (Exception e) {
+
+                }
+            }
+
+            if (keyInputStream != null) {
+                try {
+                    keyInputStream.close();
+                }catch (Exception e) {
+
+                }
+            }
+        }
+
+        return factory;
+    }
+
+    /**
+     * 获取双向认证SSLSocketFactory
+     *
+     * @param clientInput 设备证书文件输入流
+     * @param keyInput    设备私钥文件输入流
+     * @return
+     */
+    public static SSLSocketFactory getSocketFactoryByStream(final InputStream clientInput, final InputStream keyInput) {
+        return getSocketFactoryByStream(clientInput, keyInput, null);
+    }
+
+    /**
+     * 获取双向认证SSLSocketFactory
+     *
+     * @param clientInput 设备证书文件输入流
+     * @param keyInput    设备私钥文件输入流
+     * @param customCA 自定义CA证书
+     * @return
+     */
+    public static SSLSocketFactory getSocketFactoryByStream(final InputStream clientInput, final InputStream keyInput, String customCA) {
+        Security.addProvider(new BouncyCastleProvider());
+        CertificateFactory certFactory = null;
+        try {
+            certFactory = CertificateFactory.getInstance("X.509");
+        } catch (CertificateException e) {
+            LOG.error("{}", "getSocketFactory failed, create CertificateFactory error.", e);
+        }
+
+        PEMParser parser = null;
+        X509Certificate caCert = null;
+        X509Certificate clientCert = null;
+        PrivateKey privateKey = null;
+
+        // load CA certificate
+        {
+            ByteArrayInputStream caInput = null;
+            if (customCA != null && customCA.length() > 0) {
+                caInput = new ByteArrayInputStream(customCA.getBytes(Charset.forName("UTF-8")));
+            } else {
+                caInput = new ByteArrayInputStream(CA.caCrt.getBytes(Charset.forName("UTF-8")));
+            }
+            parser = new PEMParser(new InputStreamReader(caInput));
+            Object object = null;
+            try {
+                object = parser.readObject();
+            } catch (IOException e) {
+                LOG.error("{}", "parse CA failed.", e);
+                return null;
+            }
+
+            if (!(object instanceof X509CertificateHolder)) {
+                LOG.error("{}", "CA file not X509CertificateHolder.");
+                return null;
+            }
+
+            X509CertificateHolder certificateHolder = (X509CertificateHolder) object;
+            try {
+                InputStream caIn = new ByteArrayInputStream(certificateHolder.getEncoded());
+                caCert = (X509Certificate) certFactory.generateCertificate(caIn);
+                caIn.close();
+                parser.close();
+            } catch (Exception e) {
+                LOG.error("{}", "generate CA certtificate failed.", e);
+                return null;
+            }
+
+        }
+
+        // load client certificate
+        {
+            parser = new PEMParser(new InputStreamReader(clientInput));
+            Object object = null;
+            try {
+                object = parser.readObject();
+            } catch (IOException e) {
+                LOG.error("{}", "parse Client CRT failed.", e);
+                return null;
+            }
+
+            if (!(object instanceof X509CertificateHolder)) {
+                LOG.error("{}", "Client CRT file not X509CertificateHolder.");
+                return null;
+            }
+
+            X509CertificateHolder certificateHolder = (X509CertificateHolder) object;
+            try {
+                InputStream clientIn = new ByteArrayInputStream(certificateHolder.getEncoded());
+                clientCert = (X509Certificate) certFactory.generateCertificate(clientIn);
+                clientIn.close();
+                parser.close();
+            } catch (Exception e) {
+                LOG.error("{}", "generate Client certtificate failed.", e);
+                return null;
+            }
+        }
+
+        // load client private key
+        {
+            try {
+                privateKey = getPrivateKey(keyInput, null);
+            } catch (Exception e) {
+                LOG.error("{}", "generate PrivateKey failed.", e);
+                return null;
+            }
+        }
+
+        try {
+            // CA certificate is used to authenticate server
+            KeyStore caKs = KeyStore.getInstance(KeyStore.getDefaultType());
+            caKs.load(null, null);
+            caKs.setCertificateEntry("ca-certificate", caCert);
+            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+            tmf.init(caKs);
+
+            // client key and certificates are sent to server so it can authenticate us
+            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
+            ks.load(null, null);
+            ks.setCertificateEntry("certificate", clientCert);
+            ks.setKeyEntry("private-key", privateKey, PASSWORD.toCharArray(), new java.security.cert.Certificate[]{clientCert});
+            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+            kmf.init(ks, PASSWORD.toCharArray());
+
+            // finally, create SSL socket factory
+            SSLContext context = SSLContext.getInstance("TLS");
+            context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
+            return context.getSocketFactory();
+        } catch (Exception e) {
+            LOG.error("{}", "construct SSLSocketFactory failed.", e);
+            return null;
+        }
+
+    }
+
+    /**
+     * 获取默认CA证书的SSLSocketFactory
+     *
+     * @return SSLSocketFactory
+     */
+    public static SSLSocketFactory getSocketFactory() {
+        return getSocketFactory(null);
+    }
+
+    /**
+     * 获取自定义CA证书的SSLSocketFactory
+     *
+     * @param customCA 自定义CA证书
+     * @return SSLSocketFactory
+     */
+    public static SSLSocketFactory getSocketFactory(String customCA) {
+        Security.addProvider(new BouncyCastleProvider());
+        CertificateFactory certFactory = null;
+        try {
+            certFactory = CertificateFactory.getInstance("X.509");
+        } catch (CertificateException e) {
+            LOG.error("{}", "getSocketFactory failed, create CertificateFactory error.", e);
+        }
+
+        PEMParser parser = null;
+        X509Certificate caCert = null;
+
+        // load CA certificate
+        {
+            ByteArrayInputStream caInput = null;
+            if (customCA != null && customCA.length() > 0) {
+                caInput = new ByteArrayInputStream(customCA.getBytes(Charset.forName("UTF-8")));
+            } else {
+                caInput = new ByteArrayInputStream(CA.caCrt.getBytes(Charset.forName("UTF-8")));
+            }
+            parser = new PEMParser(new InputStreamReader(caInput));
+            Object object = null;
+            try {
+                object = parser.readObject();
+            } catch (IOException e) {
+                LOG.error("{}", "parse CA failed.", e);
+                return null;
+            }
+
+            if (!(object instanceof X509CertificateHolder)) {
+                LOG.error("{}", "CA file not X509CertificateHolder.");
+                return null;
+            }
+
+            X509CertificateHolder certificateHolder = (X509CertificateHolder) object;
+            try {
+                InputStream caIn = new ByteArrayInputStream(certificateHolder.getEncoded());
+                caCert = (X509Certificate) certFactory.generateCertificate(caIn);
+                caIn.close();
+                parser.close();
+            } catch (Exception e) {
+                LOG.error("{}", "generate CA certtificate failed.", e);
+                return null;
+            }
+
+        }
+
+
+        try {
+            // CA certificate is used to authenticate server
+            KeyStore caKs = KeyStore.getInstance(KeyStore.getDefaultType());
+            caKs.load(null, null);
+            caKs.setCertificateEntry("ca-certificate", caCert);
+            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+            tmf.init(caKs);
+
+
+            // finally, create SSL socket factory
+            SSLContext context = SSLContext.getInstance("TLS");
+            context.init(null, tmf.getTrustManagers(), null);
+            return context.getSocketFactory();
+        } catch (Exception e) {
+            LOG.error("{}", "construct SSLSocketFactory failed.", e);
+            return null;
+        }
+
+    }
+
+    private static PrivateKey getPrivateKey(InputStream stream, String algorithm) throws IOException,
+            GeneralSecurityException {
+        PrivateKey key = null;
+        boolean isRSAKey = false;
+
+        BufferedReader br = new BufferedReader(new InputStreamReader(stream, "UTF-8"));
+        StringBuilder builder = new StringBuilder();
+        boolean inKey = false;
+        for (String line = br.readLine(); line != null; line = br.readLine()) {
+            if (!inKey) {
+                if (line.startsWith("-----BEGIN ") && line.endsWith(" PRIVATE KEY-----")) {
+                    inKey = true;
+                    isRSAKey = line.contains("RSA");
+                }
+                continue;
+            } else {
+                if (line.startsWith("-----END ") && line.endsWith(" PRIVATE KEY-----")) {
+                    inKey = false;
+                    isRSAKey = line.contains("RSA");
+                    break;
+                }
+                builder.append(line);
+            }
+        }
+        KeySpec keySpec = null;
+        byte[] encoded = Base64.decode(builder.toString(), Base64.DEFAULT);
+        if (isRSAKey) {
+            keySpec = getRSAKeySpec(encoded);
+        } else {
+            keySpec = new PKCS8EncodedKeySpec(encoded);
+        }
+        KeyFactory kf = KeyFactory.getInstance((algorithm == null) ? "RSA" : algorithm);
+        key = kf.generatePrivate(keySpec);
+
+        return key;
+    }
+
+    private static RSAPrivateCrtKeySpec getRSAKeySpec(byte[] keyBytes) throws IOException {
+
+        DerParser parser = new DerParser(keyBytes);
+
+        Asn1Object sequence = parser.read();
+        if (sequence.getType() != DerParser.SEQUENCE)
+            throw new IOException("Invalid DER: not a sequence"); //$NON-NLS-1$
+
+        // Parse inside the sequence
+        parser = sequence.getParser();
+
+        parser.read(); // Skip version
+        BigInteger modulus = parser.read().getInteger();
+        BigInteger publicExp = parser.read().getInteger();
+        BigInteger privateExp = parser.read().getInteger();
+        BigInteger prime1 = parser.read().getInteger();
+        BigInteger prime2 = parser.read().getInteger();
+        BigInteger exp1 = parser.read().getInteger();
+        BigInteger exp2 = parser.read().getInteger();
+        BigInteger crtCoef = parser.read().getInteger();
+
+        RSAPrivateCrtKeySpec keySpec = new RSAPrivateCrtKeySpec(modulus, publicExp, privateExp, prime1, prime2, exp1,
+                exp2, crtCoef);
+
+        return keySpec;
+    }
+}
+
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/DeviceProperty.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/DeviceProperty.java	(date 1606400383047)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/DeviceProperty.java	(date 1606400383047)
@@ -0,0 +1,80 @@
+package com.tencent.iot.hub.device.java.core.shadow;
+
+/**
+ * 设备属性信息
+ */
+public class DeviceProperty {
+
+	/**
+	 * 属性名（字段名）
+	 */
+	public String mKey;
+
+	/**
+	 * 属性值
+	 */
+	public Object mData;
+
+	/**
+	 * 属性值类型
+	 */
+	public TXShadowConstants.JSONDataType mDataType;
+
+	public DeviceProperty() {
+	}
+
+	/**
+	 * 设备属性构造器
+	 *
+	 * @param key
+	 *            属性名
+	 * @param data
+	 *            属性值
+	 * @param dataType
+	 *            属性值类型
+	 */
+	public DeviceProperty(String key, String data, TXShadowConstants.JSONDataType dataType) {
+		this.mKey = key;
+		this.mData = data;
+		this.mDataType = dataType;
+	}
+
+	/**
+	 * 设置属性名（字段名）
+	 *
+	 * @param mKey
+	 * @return
+	 */
+	public DeviceProperty key(String mKey) {
+		this.mKey = mKey;
+		return this;
+	}
+
+	/**
+	 * 设置属性值
+	 *
+	 * @param mData
+	 * @return
+	 */
+	public DeviceProperty data(Object mData) {
+		this.mData = mData;
+		return this;
+	}
+
+	/**
+	 * 设置属性值类型
+	 *
+	 * @param mDataType
+	 * @return
+	 */
+	public DeviceProperty dataType(TXShadowConstants.JSONDataType mDataType) {
+		this.mDataType = mDataType;
+		return this;
+	}
+
+	@Override
+	public String toString() {
+		return "DeviceProperty{" + "mKey='" + mKey + '\'' + ", mData='" + mData + '\'' + ", mDataType=" + mDataType
+				+ '}';
+	}
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/device/TXDeviceConstants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/device/TXDeviceConstants.java	(date 1606400383042)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/device/TXDeviceConstants.java	(date 1606400383042)
@@ -0,0 +1,22 @@
+package com.tencent.iot.hub.device.java.core.device;
+
+
+
+public interface TXDeviceConstants {
+
+    /**
+     * 设备ID的最大长度，必须保持唯一
+     */
+    int MAX_SIZE_OF_CLIENT_ID = 80;
+
+    /**
+     * 产品名称的最大长度
+     */
+    int MAX_SIZE_OF_PRODUCT_NAME = 20;
+
+    /**
+     * 设备名称的最大长度
+     */
+    int MAX_SIZE_OF_DEVICE_NAME = 20;
+
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/device/CA.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/device/CA.java	(date 1606400383042)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/device/CA.java	(date 1606400383042)
@@ -0,0 +1,84 @@
+package com.tencent.iot.hub.device.java.core.device;
+
+
+public class CA {
+
+    //IoT服务器根证书
+    public static String caCrt =
+        "-----BEGIN CERTIFICATE-----\r\n" +
+        "MIIDxTCCAq2gAwIBAgIJALM1winYO2xzMA0GCSqGSIb3DQEBCwUAMHkxCzAJBgNV\r\n" +
+        "BAYTAkNOMRIwEAYDVQQIDAlHdWFuZ0RvbmcxETAPBgNVBAcMCFNoZW5aaGVuMRAw\r\n" +
+        "DgYDVQQKDAdUZW5jZW50MRcwFQYDVQQLDA5UZW5jZW50IElvdGh1YjEYMBYGA1UE\r\n" +
+        "AwwPd3d3LnRlbmNlbnQuY29tMB4XDTE3MTEyNzA0MjA1OVoXDTMyMTEyMzA0MjA1\r\n" +
+        "OVoweTELMAkGA1UEBhMCQ04xEjAQBgNVBAgMCUd1YW5nRG9uZzERMA8GA1UEBwwI\r\n" +
+        "U2hlblpoZW4xEDAOBgNVBAoMB1RlbmNlbnQxFzAVBgNVBAsMDlRlbmNlbnQgSW90\r\n" +
+        "aHViMRgwFgYDVQQDDA93d3cudGVuY2VudC5jb20wggEiMA0GCSqGSIb3DQEBAQUA\r\n" +
+        "A4IBDwAwggEKAoIBAQDVxwDZRVkU5WexneBEkdaKs4ehgQbzpbufrWo5Lb5gJ3i0\r\n" +
+        "eukbOB81yAaavb23oiNta4gmMTq2F6/hAFsRv4J2bdTs5SxwEYbiYU1teGHuUQHO\r\n" +
+        "iQsZCdNTJgcikga9JYKWcBjFEnAxKycNsmqsq4AJ0CEyZbo//IYX3czEQtYWHjp7\r\n" +
+        "FJOlPPd1idKtFMVNG6LGXEwS/TPElE+grYOxwB7Anx3iC5ZpE5lo5tTioFTHzqbT\r\n" +
+        "qTN7rbFZRytAPk/JXMTLgO55fldm4JZTP3GQsPzwIh4wNNKhi4yWG1o2u3hAnZDv\r\n" +
+        "UVFV7al2zFdOfuu0KMzuLzrWrK16SPadRDd9eT17AgMBAAGjUDBOMB0GA1UdDgQW\r\n" +
+        "BBQrr48jv4FxdKs3r0BkmJO7zH4ALzAfBgNVHSMEGDAWgBQrr48jv4FxdKs3r0Bk\r\n" +
+        "mJO7zH4ALzAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQDRSjXnBc3T\r\n" +
+        "d9VmtTCuALXrQELY8KtM+cXYYNgtodHsxmrRMpJofsPGiqPfb82klvswpXxPK8Xx\r\n" +
+        "SuUUo74Fo+AEyJxMrRKlbJvlEtnpSilKmG6rO9+bFq3nbeOAfat4lPl0DIscWUx3\r\n" +
+        "ajXtvMCcSwTlF8rPgXbOaSXZidRYNqSyUjC2Q4m93Cv+KlyB+FgOke8x4aKAkf5p\r\n" +
+        "XR8i1BN1OiMTIRYhGSfeZbVRq5kTdvtahiWFZu9DGO+hxDZObYGIxGHWPftrhBKz\r\n" +
+        "RT16Amn780rQLWojr70q7o7QP5tO0wDPfCdFSc6CQFq/ngOzYag0kJ2F+O5U6+kS\r\n" +
+        "QVrcRBDxzx/G\r\n" +
+        "-----END CERTIFICATE-----";
+
+
+    //OTA升级包下载服务器的CA证书链
+    public static String[] cosServerCaCrtList = {
+        "-----BEGIN CERTIFICATE-----\r\n" +
+        "MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\r\n" +
+        "A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\r\n" +
+        "b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\r\n" +
+        "MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\r\n" +
+        "YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\r\n" +
+        "aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\r\n" +
+        "jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\r\n" +
+        "xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\r\n" +
+        "1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\r\n" +
+        "snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\r\n" +
+        "U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\r\n" +
+        "9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\r\n" +
+        "BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\r\n" +
+        "AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\r\n" +
+        "yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\r\n" +
+        "38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\r\n" +
+        "AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\r\n" +
+        "DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\r\n" +
+        "HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\r\n" +
+        "-----END CERTIFICATE-----\r\n",
+
+        "-----BEGIN CERTIFICATE-----\r\n"+
+        "MIIEaTCCA1GgAwIBAgILBAAAAAABRE7wQkcwDQYJKoZIhvcNAQELBQAwVzELMAkG\r\n"+
+        "A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\r\n"+
+        "b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw0xNDAyMjAxMDAw\r\n"+
+        "MDBaFw0yNDAyMjAxMDAwMDBaMGYxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\r\n"+
+        "YWxTaWduIG52LXNhMTwwOgYDVQQDEzNHbG9iYWxTaWduIE9yZ2FuaXphdGlvbiBW\r\n"+
+        "YWxpZGF0aW9uIENBIC0gU0hBMjU2IC0gRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IB\r\n"+
+        "DwAwggEKAoIBAQDHDmw/I5N/zHClnSDDDlM/fsBOwphJykfVI+8DNIV0yKMCLkZc\r\n"+
+        "C33JiJ1Pi/D4nGyMVTXbv/Kz6vvjVudKRtkTIso21ZvBqOOWQ5PyDLzm+ebomchj\r\n"+
+        "SHh/VzZpGhkdWtHUfcKc1H/hgBKueuqI6lfYygoKOhJJomIZeg0k9zfrtHOSewUj\r\n"+
+        "mxK1zusp36QUArkBpdSmnENkiN74fv7j9R7l/tyjqORmMdlMJekYuYlZCa7pnRxt\r\n"+
+        "Nw9KHjUgKOKv1CGLAcRFrW4rY6uSa2EKTSDtc7p8zv4WtdufgPDWi2zZCHlKT3hl\r\n"+
+        "2pK8vjX5s8T5J4BO/5ZS5gIg4Qdz6V0rvbLxAgMBAAGjggElMIIBITAOBgNVHQ8B\r\n"+
+        "Af8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUlt5h8b0cFilT\r\n"+
+        "HMDMfTuDAEDmGnwwRwYDVR0gBEAwPjA8BgRVHSAAMDQwMgYIKwYBBQUHAgEWJmh0\r\n"+
+        "dHBzOi8vd3d3Lmdsb2JhbHNpZ24uY29tL3JlcG9zaXRvcnkvMDMGA1UdHwQsMCow\r\n"+
+        "KKAmoCSGImh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5uZXQvcm9vdC5jcmwwPQYIKwYB\r\n"+
+        "BQUHAQEEMTAvMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5nbG9iYWxzaWduLmNv\r\n"+
+        "bS9yb290cjEwHwYDVR0jBBgwFoAUYHtmGkUNl8qJUC99BM00qP/8/UswDQYJKoZI\r\n"+
+        "hvcNAQELBQADggEBAEYq7l69rgFgNzERhnF0tkZJyBAW/i9iIxerH4f4gu3K3w4s\r\n"+
+        "32R1juUYcqeMOovJrKV3UPfvnqTgoI8UV6MqX+x+bRDmuo2wCId2Dkyy2VG7EQLy\r\n"+
+        "XN0cvfNVlg/UBsD84iOKJHDTu/B5GqdhcIOKrwbFINihY9Bsrk8y1658GEV1BSl3\r\n"+
+        "30JAZGSGvip2CTFvHST0mdCF/vIhCPnG9vHQWe3WVjwIKANnuvD58ZAWR65n5ryA\r\n"+
+        "SOlCdjSXVWkkDoPWoC209fN5ikkodBpBocLTJIg1MGCUF7ThBCIxPTsvFwayuJ2G\r\n"+
+        "K1pp74P1S8SqtCr4fKGxhZSM9AyHDPSsQPhZSZg=\r\n"+
+        "-----END CERTIFICATE-----",
+    };
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowActionCallBack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowActionCallBack.java	(date 1606400383047)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowActionCallBack.java	(date 1606400383047)
@@ -0,0 +1,85 @@
+package com.tencent.iot.hub.device.java.core.shadow;
+
+import  com.tencent.iot.hub.device.java.core.common.Status;
+
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+
+import java.util.List;
+
+/**
+ * 设备影子Action回调接口
+ */
+
+public abstract class TXShadowActionCallBack {
+
+    /**
+     * 文档请求响应的回调接口
+     *
+     * @param type 文档操作方式, get/update/delete
+     * @param result 请求响应结果, 0: 成功；非0：失败
+     * @param jsonDocument   云端返回的json文档
+     */
+    public void onRequestCallback(String type, int result, String jsonDocument) {
+    }
+
+    /**
+     * 设备属性更新回调接口
+     *
+     * @param propertyJSONDocument 从云端收到的原始设备属性json文档
+     * @param propertyList   更新后的设备属性集
+     */
+    public void onDevicePropertyCallback(String propertyJSONDocument, List<? extends DeviceProperty> propertyList) {
+    }
+
+
+    /**
+     * 收到来自云端的消息
+     *
+     * @param topic   主题名称
+     * @param message 消息内容
+     */
+    public void onMessageReceived(String topic, MqttMessage message) {
+    }
+
+
+    /**
+     * 发布消息完成回调
+     *
+     * @param status        Status.OK: 发布消息成功； Status.ERROR: 发布消息失败
+     * @param token         消息token，包含消息内容结构体
+     * @param userContext   用户上下文
+     * @param msg           详细信息
+     */
+    public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+    }
+
+    /**
+     * 订阅主题完成回调
+     *
+     * @param status           Status.OK: 订阅成功； Status.ERROR: 订阅失败
+     * @param token            消息token，包含消息内容结构体
+     * @param userContext      用户上下文
+     * @param msg              详细信息
+     */
+    public void onSubscribeCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+    }
+
+    /**
+     * 取消订阅主题完成回调
+     *
+     * @param status           Status.OK: 取消订阅成功； Status.ERROR: 取消订阅失败
+     * @param token            消息token，包含消息内容结构体
+     * @param userContext      用户上下文
+     * @param msg              详细信息
+     */
+    public void onUnSubscribeCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+    }
+    
+    public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {
+
+	}
+
+	public void onConnectionLost(Throwable cause) {
+	}
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowConnection.java	(date 1606400383048)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowConnection.java	(date 1606400383048)
@@ -0,0 +1,763 @@
+package com.tencent.iot.hub.device.java.core.shadow;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.MQTT_SERVER_PORT_TLS;
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.QCLOUD_IOT_MQTT_DIRECT_DOMAIN;
+
+public class TXShadowConnection {
+
+	public static final String TAG = TXShadowConnection.class.getName();
+	 private static final Logger LOG = LoggerFactory.getLogger(TXShadowConnection.class);
+	/**
+	 * clientToken formatter
+	 */
+	private static final String CLIENT_TOKEN = "%s-%d";
+
+	/**
+	 * shadow action回调接口
+	 */
+	private TXShadowActionCallBack mShadowActionCallback = null;
+
+	/**
+	 * mqtt 连接实例
+	 */
+	private TXMqttConnection mMqttConnection = null;
+
+	private int mQos = TXMqttConstants.QOS0;
+
+	private AtomicInteger mClientTokenNum = new AtomicInteger(0);
+
+	/**
+	 * 保存用户注册的属性
+	 */
+	private HashMap<String, DeviceProperty> mRegisterPropertyMap = new HashMap<>();
+
+	/**
+	 * 是否已经成功订阅OPERATION_RESULT_TOPIC
+	 */
+	private boolean mIsOperationResultSubscribeSuccess = false;
+
+	/**
+	 * 文档版本号
+	 */
+	private int mDocumentVersion = 0;
+
+	private String OPERATION_TOPIC = null;
+	private String OPERATION_RESULT_TOPIC = null;
+
+	private static final int MAX_MESSAGE_ID = 65535;
+	private int mPublishMessageId = 0;
+
+	public ShadowUponMqttCallBack mShadowUponMqttCallBack = null;
+
+	/**
+	 * @param productID
+	 *            产品名
+	 * @param deviceName
+	 *            设备名，唯一
+	 * @param secretKey
+	 *            密钥
+	 * @param callBack
+	 *            连接、消息发布、消息订阅回调接口
+	 */
+	public TXShadowConnection( String productID, String deviceName, String secretKey,
+			TXShadowActionCallBack callBack) {
+		this(productID, deviceName, secretKey, null, callBack);
+	}
+
+	/**
+	 * @param productID
+	 *            产品名
+	 * @param deviceName
+	 *            设备名，唯一
+	 * @param secretKey
+	 *            密钥
+	 * @param bufferOpts
+	 *            发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+	 * @param callBack
+	 *            连接、消息发布、消息订阅回调接口
+	 */
+	public TXShadowConnection(String productID, String deviceName, String secretKey,
+			DisconnectedBufferOptions bufferOpts, TXShadowActionCallBack callBack) {
+		this(productID, deviceName, secretKey, bufferOpts, null, callBack);
+	}
+
+	/**
+	 * @param productID
+	 *            产品名
+	 * @param deviceName
+	 *            设备名，唯一
+	 * @param secretKey
+	 *            密钥
+	 * @param bufferOpts
+	 *            发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+	 * @param clientPersistence
+	 *            消息永久存储
+	 * @param callBack
+	 *            连接、消息发布、消息订阅回调接口
+	 */
+	public TXShadowConnection(String productID, String deviceName, String secretKey,
+			DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence,
+			TXShadowActionCallBack callBack) {
+		this( null, productID, deviceName, secretKey, bufferOpts,
+				clientPersistence, callBack);
+	}
+
+	/**
+	 * Shadow连接器构造器
+	 *
+	 * @param serverURI
+	 *            服务器URI
+	 * @param productID
+	 *            产品名
+	 * @param deviceName
+	 *            设备名，唯一
+	 * @param secretKey
+	 *            密钥
+	 * @param bufferOpts
+	 *            发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+	 * @param clientPersistence
+	 *            消息永久存储
+	 * @param callBack
+	 *            连接、消息发布、消息订阅回调接口
+	 */
+	public TXShadowConnection(String serverURI, String productID, String deviceName, String secretKey,
+			DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence,
+			TXShadowActionCallBack callBack) {
+		this.mShadowActionCallback = callBack;
+
+		mShadowUponMqttCallBack = new ShadowUponMqttCallBack();
+		mMqttConnection = new TXMqttConnection(serverURI, productID, deviceName, secretKey, bufferOpts,
+				clientPersistence, mShadowUponMqttCallBack);
+
+		OPERATION_TOPIC = "$shadow/operation/" + productID + "/" + mMqttConnection.mDeviceName;
+		OPERATION_RESULT_TOPIC = "$shadow/operation/result/" + productID + "/" + mMqttConnection.mDeviceName;
+
+		mPublishMessageId = new Random().nextInt(MAX_MESSAGE_ID);
+	}
+
+	public void setMqttConnection(TXMqttConnection connection) {
+		mMqttConnection = connection;
+	}
+
+	/**
+	 * 获取TXMqttConnection句柄
+	 */
+	public TXMqttConnection getMqttConnection() {
+		return mMqttConnection;
+	}
+
+	/**
+	 * 设置断连状态buffer缓冲区
+	 *
+	 * @param bufferOpts
+	 *            缓冲参数
+	 */
+	public void setBufferOpts(DisconnectedBufferOptions bufferOpts) {
+		mMqttConnection.setBufferOpts(bufferOpts);
+	}
+
+	/**
+	 * 与云端建立连接，结果通过回调函数通知。
+	 *
+	 * @param options
+	 *            连接参数
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public synchronized Status connect(MqttConnectOptions options, Object userContext) {
+		Status status = mMqttConnection.connect(options, userContext);
+		if (status != Status.OK) {
+			return status;
+		}
+
+		long startTimeMills = System.currentTimeMillis();
+		while (!mIsOperationResultSubscribeSuccess) {
+			try {
+				Thread.sleep(100);
+			} catch (Exception e) {
+			}
+
+			if (mMqttConnection.getConnectStatus() == TXMqttConstants.ConnectStatus.kConnectFailed) {
+				return Status.ERROR;
+			}
+
+			if (System.currentTimeMillis() - startTimeMills > 20000) { // 20
+																		// seconds
+				LOG.error("Subscribe topic [{}] timeout!!!", OPERATION_RESULT_TOPIC);
+				return Status.ERROR;
+			}
+		}
+
+		return status;
+	}
+
+	/**
+	 * 断开连接请求，结果通过回调函数通知。
+	 *
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status disConnect(Object userContext) {
+		Status status = mMqttConnection.unSubscribe(OPERATION_RESULT_TOPIC, userContext);
+		if (status != Status.OK) {
+			return status;
+		}
+
+		return mMqttConnection.disConnect("disconnect context");
+	}
+	
+	public Status publish(String topic, MqttMessage msg, Object userCtx) {
+		return mMqttConnection.publish(topic, msg, userCtx);
+	}
+	
+	public Status subcribe(String topic, int qos, Object userContext) {
+		return mMqttConnection.subscribe(topic, qos, userContext);
+	}
+
+	/**
+	 * 获取连接状态
+	 *
+	 * @return 连接状态
+	 */
+	public TXMqttConstants.ConnectStatus getConnectStatus() {
+		return mMqttConnection.getConnectStatus();
+	}
+
+	/**
+	 * 更新设备属性信息，结果通过回调函数通知。
+	 *
+	 * @param devicePropertyList
+	 *            需要更新的设备属性集
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status update(List<? extends DeviceProperty> devicePropertyList, Object userContext) {
+		Status status = checkMqttStatus();
+		if (Status.OK != status) {
+			return status;
+		}
+
+		if (!mIsOperationResultSubscribeSuccess) {
+			LOG.debug("******subscribe topic:" + OPERATION_RESULT_TOPIC);
+			mMqttConnection.subscribe(OPERATION_RESULT_TOPIC, mQos, "subscribe context");
+			return Status.ERROR_TOPIC_UNSUBSCRIBED;
+		}
+
+		String clientToken = String.format(CLIENT_TOKEN, mMqttConnection.mClientId, mClientTokenNum.getAndIncrement());
+		String jsonDocument = buildUpdateJsonDocument(devicePropertyList, clientToken);
+
+		return publish(OPERATION_TOPIC, jsonDocument, userContext);
+	}
+
+	/**
+	 * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息。
+	 *
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status reportNullDesiredInfo() {
+		Status status = checkMqttStatus();
+		if (Status.OK != status) {
+			return status;
+		}
+
+		String clientToken = String.format(CLIENT_TOKEN, mMqttConnection.mClientId, mClientTokenNum.getAndIncrement());
+		String jsonDocument = buildDesiredNullJsonDocument(null, clientToken);
+
+		LOG.debug("reportNullDesiredInfo, document: {}", jsonDocument);
+
+		return publish(OPERATION_TOPIC, jsonDocument, null);
+	}
+
+	/**
+	 * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息。
+	 *
+	 * @param reportJsonDoc
+	 *            用户上报的JSON内容
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status reportNullDesiredInfo(String reportJsonDoc) {
+		Status status = checkMqttStatus();
+		if (Status.OK != status) {
+			return status;
+		}
+
+		String clientToken = String.format(CLIENT_TOKEN, mMqttConnection.mClientId, mClientTokenNum.getAndIncrement());
+		String jsonDocument = buildDesiredNullJsonDocument(reportJsonDoc, clientToken);
+
+		LOG.debug("reportNullDesiredInfo, document: {}", jsonDocument);
+
+		return publish(OPERATION_TOPIC, jsonDocument, null);
+	}
+
+	/**
+	 * 获取设备影子文档，结果通过回调函数通知。
+	 *
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	public Status get(Object userContext) {
+		Status status = checkMqttStatus();
+		if (Status.OK != status) {
+			return status;
+		}
+
+		if (!mIsOperationResultSubscribeSuccess) {
+			LOG.debug("***subscribe topic:" + OPERATION_RESULT_TOPIC);
+			mMqttConnection.subscribe(OPERATION_RESULT_TOPIC, mQos, "subscribe context");
+
+			return Status.ERROR_TOPIC_UNSUBSCRIBED;
+		}
+
+		String clientToken = String.format(CLIENT_TOKEN, mMqttConnection.mClientId, mClientTokenNum.getAndIncrement());
+		String jsonDocument = buildGetJsonDocument(clientToken);
+
+		LOG.debug("get document: {}", jsonDocument);
+
+		return publish(OPERATION_TOPIC, jsonDocument, userContext);
+	}
+
+	/**
+	 * 注册当前设备的设备属性
+	 *
+	 * @param property
+	 *            设备属性
+	 */
+	public void registerProperty(DeviceProperty property) {
+		mRegisterPropertyMap.put(property.mKey, property);
+	}
+
+	/**
+	 * 取消注册当前设备的指定属性
+	 *
+	 * @param property
+	 */
+	public void unRegisterProperty(DeviceProperty property) {
+		mRegisterPropertyMap.remove(property.mKey);
+	}
+
+	/**
+	 * 向指定TOPIC发布设备影子文档，结果通过回调函数通知。
+	 *
+	 * @param topic
+	 *            指定的topic
+	 * @param document
+	 *            json文档
+	 * @param userContext
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+	 */
+	private Status publish(String topic, String document, Object userContext) {
+		Status status;
+		status = checkMqttStatus();
+		if (status != Status.OK) {
+			return status;
+		}
+
+		MqttMessage mqttMessage = new MqttMessage();
+		if ((null != document) && (document.length() != 0)) {
+			mqttMessage.setId(getMessageId());
+			mqttMessage.setPayload(document.getBytes());
+		}
+		mqttMessage.setQos(TXMqttConstants.QOS0);
+		LOG.debug("******publish message id:" + mqttMessage.getId());
+
+		status = mMqttConnection.publish(topic, mqttMessage, userContext);
+		if (status != Status.OK) {
+			return status;
+		}
+
+		return Status.OK;
+	}
+
+	/**
+	 * 检查mqtt状态
+	 *
+	 * @return 当前状态
+	 */
+	private Status checkMqttStatus() {
+		if (null == mMqttConnection || mMqttConnection.getConnectStatus() != TXMqttConstants.ConnectStatus.kConnected) {
+			LOG.error("mqtt is disconnected!");
+			return Status.MQTT_NO_CONN;
+		}
+
+		return Status.OK;
+	}
+
+	/**
+	 * 构建json信息
+	 *
+	 * @param devicePropertyList
+	 *            需要上报的设备属性集
+	 * @param clientToken
+	 *            clientToken字段
+	 * @return json字符串
+	 */
+	private String buildUpdateJsonDocument(List<? extends DeviceProperty> devicePropertyList, String clientToken) {
+		JSONObject documentJSONObj = new JSONObject();
+
+		try {
+			documentJSONObj.put(TXShadowConstants.TYPE, TXShadowConstants.UPDATE);
+
+			JSONObject stateJSONObj = new JSONObject();
+			if (devicePropertyList != null && !devicePropertyList.isEmpty()) {
+
+				JSONObject reportedJSONObj = new JSONObject();
+				for (DeviceProperty deviceProperty : devicePropertyList) {
+					if (TXShadowConstants.JSONDataType.INT == deviceProperty.mDataType) {
+						reportedJSONObj.put(deviceProperty.mKey, Integer.parseInt((String) deviceProperty.mData));
+					} else if (TXShadowConstants.JSONDataType.LONG == deviceProperty.mDataType) {
+						reportedJSONObj.put(deviceProperty.mKey, Long.parseLong((String) deviceProperty.mData));
+					} else if (TXShadowConstants.JSONDataType.FLOAT == deviceProperty.mDataType) {
+						reportedJSONObj.put(deviceProperty.mKey, Float.parseFloat((String) deviceProperty.mData));
+					} else if (TXShadowConstants.JSONDataType.DOUBLE == deviceProperty.mDataType) {
+						reportedJSONObj.put(deviceProperty.mKey, Double.parseDouble((String) deviceProperty.mData));
+					} else if (TXShadowConstants.JSONDataType.BOOLEAN == deviceProperty.mDataType) {
+						reportedJSONObj.put(deviceProperty.mKey, Boolean.parseBoolean((String) deviceProperty.mData));
+					} else {
+						reportedJSONObj.put(deviceProperty.mKey, deviceProperty.mData);
+					}
+				}
+				stateJSONObj.put(TXShadowConstants.REPORTED, reportedJSONObj);
+			}
+
+			documentJSONObj.put(TXShadowConstants.STATE, stateJSONObj);
+			documentJSONObj.put(TXShadowConstants.CLIENT_TOKEN, clientToken);
+			documentJSONObj.put(TXShadowConstants.VERSION, mDocumentVersion);
+
+		} catch (JSONException e) {
+			LOG.error("{}", "build report info failed", e);
+			return "";
+		}
+
+		return documentJSONObj.toString();
+	}
+
+	private String buildDesiredNullJsonDocument(String reportJsonDoc, String clientToken) {
+		JSONObject documentJSONObj = new JSONObject();
+
+		try {
+			documentJSONObj.put(TXShadowConstants.TYPE, TXShadowConstants.UPDATE);
+
+			JSONObject stateJSONObj = new JSONObject();
+			if (reportJsonDoc != null) {
+				JSONObject reportedJSONObj = new JSONObject(reportJsonDoc);
+				stateJSONObj.put(TXShadowConstants.REPORTED, reportedJSONObj);
+			}
+			stateJSONObj.put(TXShadowConstants.DESIRED, "");
+
+			documentJSONObj.put(TXShadowConstants.STATE, stateJSONObj);
+			documentJSONObj.put(TXShadowConstants.CLIENT_TOKEN, clientToken);
+			documentJSONObj.put(TXShadowConstants.VERSION, mDocumentVersion);
+
+		} catch (JSONException e) {
+			LOG.error("{}", "build report info failed", e);
+			return "";
+		}
+
+		return documentJSONObj.toString();
+	}
+
+	private String buildGetJsonDocument(String clientToken) {
+		JSONObject documentJSONObj = new JSONObject();
+
+		try {
+			documentJSONObj.put(TXShadowConstants.TYPE, TXShadowConstants.GET);
+			documentJSONObj.put(TXShadowConstants.CLIENT_TOKEN, clientToken);
+		} catch (JSONException e) {
+			LOG.error("{}", "build report info failed", e);
+			return "";
+		}
+
+		return documentJSONObj.toString();
+	}
+
+	private String buildDeleteJsonDocument(String clientToken) {
+		JSONObject documentJSONObj = new JSONObject();
+
+		try {
+			documentJSONObj.put(TXShadowConstants.TYPE, TXShadowConstants.DELETE);
+			documentJSONObj.put(TXShadowConstants.CLIENT_TOKEN, clientToken);
+		} catch (JSONException e) {
+			LOG.error("{}", "build report info failed", e);
+			return "";
+		}
+
+		return documentJSONObj.toString();
+	}
+
+	private int getMessageId() {
+		mPublishMessageId++;
+		if (mPublishMessageId > MAX_MESSAGE_ID) {
+			mPublishMessageId = 1;
+		}
+
+		return mPublishMessageId;
+	}
+
+	/**
+	 * 处理接收到的影子消息
+	 *
+	 * @param topic
+	 *            来自哪个TOPIC的消息
+	 * @param message
+	 *            MQTT消息
+	 */
+	private void processShadowMessageReceived(String topic, MqttMessage message) {
+		if (null == message || null == message.getPayload()) {
+			LOG.error("handle mqtt message failed, reason[{}]!", "message or payload is empty");
+			return;
+		}
+
+		String jsonStr = new String(message.getPayload());
+		JSONObject jsonObj = null;
+		try {
+			jsonObj = new JSONObject(jsonStr);
+
+			String type = jsonObj.getString(TXShadowConstants.TYPE);
+			if (TXShadowConstants.DELTA.equals(type)) {
+				processDeltaMessage(message);
+			}
+		} catch (Exception e) {
+
+		}
+	}
+
+	/**
+	 * 处理delta消息函数。 当服务端发送delta消息到终端, 将会调用此方法
+	 *
+	 * @param message
+	 *            mqtt消息
+	 */
+	private void processDeltaMessage(MqttMessage message) {
+		JSONObject jsonObj = null;
+
+		try {
+			jsonObj = new JSONObject(new String(message.getPayload()));
+			//edited by v_vweisun 2020/09/22 start
+			jsonObj = jsonObj.getJSONObject(TXShadowConstants.PAYLOAD);//new JSONObject(jsonObj.getString(TXShadowConstants.PAYLOAD));
+			//edited by v_vweisun 2020/09/22 end
+
+			if (jsonObj.has(TXShadowConstants.VERSION)) {
+				int versionNum = jsonObj.getInt(TXShadowConstants.VERSION);
+				if (versionNum > mDocumentVersion) {
+					mDocumentVersion = versionNum;
+					LOG.debug("New Version number : {}", mDocumentVersion);
+				} else {
+					LOG.warn("Old Delta Message received - Ignoring rx : {} local : {}", versionNum,
+							mDocumentVersion);
+					return;
+				}
+			}
+		} catch (JSONException e) {
+			LOG.error("{}", "Received JSON is not valid!", e);
+			return;
+		}
+
+		if (!jsonObj.has(TXShadowConstants.STATE)) {
+			return;
+		}
+
+		List<DeviceProperty> propertyList = new ArrayList<>();
+		String stateJsonStr = "";
+
+		try {
+			//edited by v_vweisun 2020/09/22 start
+//			stateJsonStr = jsonObj.getString(TXShadowConstants.STATE);
+
+			JSONObject stateObj = jsonObj.getJSONObject(TXShadowConstants.STATE);//new JSONObject(stateJsonStr);
+			//edited by v_vweisun 2020/09/22 end
+
+			Iterator it = mRegisterPropertyMap.keySet().iterator();
+			while (it.hasNext()) {
+				DeviceProperty property = mRegisterPropertyMap.get(it.next());
+
+				if (stateObj.has(property.mKey)) {
+					// edited by v_vweisun 2020/09/22 start
+					String value = "";
+					if (TXShadowConstants.JSONDataType.INT == property.mDataType) {
+						property.data(stateObj.getInt(property.mKey));
+						value = String.valueOf(stateObj.getInt(property.mKey));
+					} else if (TXShadowConstants.JSONDataType.LONG == property.mDataType) {
+						property.data(stateObj.getLong(property.mKey));
+						value = String.valueOf(stateObj.getLong(property.mKey));
+					} else if (TXShadowConstants.JSONDataType.FLOAT == property.mDataType) {
+						property.data(stateObj.getFloat(property.mKey));
+						value = String.valueOf(stateObj.getFloat(property.mKey));
+					} else if (TXShadowConstants.JSONDataType.DOUBLE == property.mDataType) {
+						property.data(stateObj.getDouble(property.mKey));
+						value = String.valueOf(stateObj.getDouble(property.mKey));
+					} else if (TXShadowConstants.JSONDataType.BOOLEAN == property.mDataType) {
+						property.data(stateObj.getBoolean(property.mKey));
+						value = String.valueOf(stateObj.getBoolean(property.mKey));
+					} else {
+						property.data(stateObj.getString(property.mKey));
+						value = String.valueOf(stateObj.getString(property.mKey));
+					}
+					// edited by v_vweisun 2020/09/22 end
+					propertyList.add(property);
+					LOG.debug("******{}, {}", property.mKey, value);
+				}
+			}
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+
+		if (null != mShadowActionCallback && !propertyList.isEmpty()) {
+			mShadowActionCallback.onDevicePropertyCallback(stateJsonStr, propertyList);
+		}
+	}
+
+	private class ShadowUponMqttCallBack extends TXMqttActionCallBack {
+		@Override
+		public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {
+			LOG.debug("onConnectCompleted, status[{}], reconnect[{}], msg[{}]", status, reconnect, msg);
+			if (Status.OK == status) {
+				LOG.debug("******subscribe topic:" + OPERATION_RESULT_TOPIC);
+				mMqttConnection.subscribe(OPERATION_RESULT_TOPIC, mQos, "subscribe context");
+			}
+			mShadowActionCallback.onConnectCompleted(status, reconnect, userContext, msg);
+		}
+
+		@Override
+		public void onConnectionLost(Throwable cause) {
+			LOG.error("{}", "mqtt connection lost!", cause);
+			mIsOperationResultSubscribeSuccess = false;
+			mShadowActionCallback.onConnectionLost(cause);
+		}
+
+		@Override
+		public void onDisconnectCompleted(Status status, Object userContext, String msg) {
+			LOG.debug("onDisconnectCompleted, status[{}], msg[{}]", status.name(), msg);
+
+			mIsOperationResultSubscribeSuccess = false;
+		}
+
+		@Override
+		public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
+			super.onPublishCompleted(status, token, userContext, errMsg);
+
+			String[] topics = token.getTopics();
+			LOG.debug("onPublishCompleted, status[{}], errMsg[{}], topics[{}]", status.name(), errMsg,
+					Arrays.toString(topics));
+			for (String topic : topics) {
+				if (topic.startsWith("$" + TXShadowConstants.SHADOW)) {
+				} else {
+					mShadowActionCallback.onPublishCompleted(status, token, userContext, errMsg);
+				}
+			}
+		}
+
+		@Override
+		public void onSubscribeCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
+			super.onSubscribeCompleted(status, token, userContext, errMsg);
+
+			String[] topics = token.getTopics();
+			LOG.debug("onSubscribeCompleted, status[{}], errMsg[{}], topics[{}]", status.name(), errMsg,
+					Arrays.toString(topics));
+			for (String topic : topics) {
+				if (topic.startsWith("$" + TXShadowConstants.SHADOW)) {
+					if (status == Status.OK) {
+						LOG.debug("***subscribe topic:" + OPERATION_RESULT_TOPIC + " success!!!!");
+						mIsOperationResultSubscribeSuccess = true;
+					}
+				} else {
+					mShadowActionCallback.onSubscribeCompleted(status, token, userContext, errMsg);
+				}
+			}
+		}
+
+		@Override
+		public void onUnSubscribeCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
+			super.onUnSubscribeCompleted(status, token, userContext, errMsg);
+
+			String[] topics = token.getTopics();
+			LOG.debug("onUnSubscribeCompleted, status[{}], errMsg[{}], topics[{}]", status.name(), errMsg,
+					Arrays.toString(topics));
+			for (String topic : topics) {
+				if (topic.startsWith("$" + TXShadowConstants.SHADOW)) {
+					if (status == Status.OK) {
+						mIsOperationResultSubscribeSuccess = false;
+					}
+				} else {
+					mShadowActionCallback.onUnSubscribeCompleted(status, token, userContext, errMsg);
+				}
+			}
+		}
+
+		@Override
+		public void onMessageReceived(String topic, MqttMessage message) {
+			super.onMessageReceived(topic, message);
+
+			LOG.debug("onMessageReceived,  topics[{}]", topic);
+
+			if (topic.startsWith("$" + TXShadowConstants.SHADOW)) {
+				if (null == message || null == message.getPayload()) {
+					LOG.error("handle mqtt message failed, reason[{}]!", "message or payload is empty");
+					return;
+				}
+
+				String jsonStr = new String(message.getPayload());
+
+				try {
+					JSONObject jsonObj = new JSONObject(jsonStr);
+
+					if (jsonObj.has(TXShadowConstants.TYPE)) {
+						String type = jsonObj.getString(TXShadowConstants.TYPE);
+
+						if (TXShadowConstants.GET.equals(type) || TXShadowConstants.UPDATE.equals(type)
+								|| TXShadowConstants.DELETE.equals(type)) {
+
+							if (jsonObj.has(TXShadowConstants.RESULT)) {
+								int result = jsonObj.getInt(TXShadowConstants.RESULT);
+								if (jsonObj.has(TXShadowConstants.PAYLOAD)) {
+									String payloadStr = jsonObj.getJSONObject(TXShadowConstants.PAYLOAD).toString();
+
+									mShadowActionCallback.onRequestCallback(type, result, payloadStr);
+
+									JSONObject payloadJsonObj = new JSONObject(payloadStr);
+									if (payloadJsonObj.has(TXShadowConstants.VERSION)) {
+										mDocumentVersion = payloadJsonObj.getInt(TXShadowConstants.VERSION);
+										LOG.debug("******update local mDocumentVersion to " + mDocumentVersion);
+									}
+								}
+							}
+						}
+					}
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+
+				processShadowMessageReceived(topic, message);
+			} else {
+				mShadowActionCallback.onMessageReceived(topic, message);
+			}
+		}
+	}
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowConstants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowConstants.java	(date 1606400383048)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/shadow/TXShadowConstants.java	(date 1606400383048)
@@ -0,0 +1,64 @@
+package com.tencent.iot.hub.device.java.core.shadow;
+
+public interface TXShadowConstants {
+    String TYPE = "type";
+    String GET = "get";
+    String UPDATE = "update";
+    String DELETE= "delete";
+    String RESULT = "result";
+    String SHADOW = "shadow";
+    String DELTA = "delta";
+    String VERSION = "version";
+    String STATE = "state";
+    String REPORTED = "reported";
+    String CLIENT_TOKEN = "clientToken";
+    String DESIRED = "desired";
+    String PAYLOAD = "payload";
+
+    /**
+     * 属性的JSON数据类型
+     */
+    enum JSONDataType {
+        /**
+         * 整型
+         */
+        INT,
+
+        /**
+         * 长整型
+         */
+        LONG,
+
+        /**
+         * 单精度浮点型
+         */
+        FLOAT,
+
+        /**
+         * 双精度浮点型
+         */
+        DOUBLE,
+
+        /**
+         * 布尔型
+         */
+        BOOLEAN,
+
+        /**
+         * 字符串
+         */
+        STRING,
+
+        /**
+         * 数组类型
+         */
+        ARRAY,
+
+        /**
+         * 对象类型
+         */
+        OBJECT
+
+    }
+}
+
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/gateway/TXGatewayConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/gateway/TXGatewayConnection.java	(date 1606400383043)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/gateway/TXGatewayConnection.java	(date 1606400383043)
@@ -0,0 +1,391 @@
+package com.tencent.iot.hub.device.java.core.gateway;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXAlarmPingSender;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.util.Base64;
+import com.tencent.iot.hub.device.java.core.util.HmacSha256;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttAsyncClient;
+import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
+import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.MQTT_SDK_VER;
+
+/**
+ * Created by willssong on 2018/12/25.
+ */
+
+public class TXGatewayConnection extends TXMqttConnection {
+	public static final String TAG = "TXMQTT" + MQTT_SDK_VER;
+	private static final Logger LOG = LoggerFactory.getLogger(TXGatewayConnection.class);
+	
+	private HashMap<String, TXGatewaySubdev> mSubdevs = new HashMap<String, TXGatewaySubdev>();
+	private static final String GW_OPERATION_RES_PREFIX = "$gateway/operation/result/";
+	private static final String GW_OPERATION_PREFIX = "$gateway/operation/";
+
+	/**
+	 * @param context
+	 *            用户上下文（这个参数在回调函数时透传给用户）
+	 * @param serverURI
+	 *            服务器URI
+	 * @param productID
+	 *            产品名
+	 * @param deviceName
+	 *            设备名，唯一
+	 * @param secretKey
+	 *            密钥
+	 * @param bufferOpts
+	 *            发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+	 * @param clientPersistence
+	 *            消息永久存储
+	 * @param callBack
+	 *            连接、消息发布、消息订阅回调接口
+	 */
+	public TXGatewayConnection(String serverURI, String productID, String deviceName, String secretKey,
+			DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence,
+			TXMqttActionCallBack callBack) {
+		super(serverURI, productID, deviceName, secretKey, bufferOpts, clientPersistence, callBack);
+	}
+
+	/**
+	 * 使用腾讯云物联网通信默认地址 "${ProductId}.iotcloud.tencentdevices.com:8883"  https://cloud.tencent.com/document/product/634/32546
+	 * @param context
+	 * @param productID
+	 * @param deviceName
+	 * @param secretKey
+	 * @param bufferOpts
+	 * @param clientPersistence
+	 * @param callBack
+	 */
+	public TXGatewayConnection(String productID, String deviceName, String secretKey,
+			DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence,
+			TXMqttActionCallBack callBack) {
+		this(null, productID, deviceName, secretKey, bufferOpts, clientPersistence, callBack);
+	}
+
+	/**
+	 *
+	 * @param context
+	 * @param productID
+	 * @param deviceName
+	 * @param secretKey
+	 * @param bufferOpts
+	 * @param callBack
+	 */
+	public TXGatewayConnection(String productID, String deviceName, String secretKey,
+			DisconnectedBufferOptions bufferOpts, TXMqttActionCallBack callBack) {
+		this(productID, deviceName, secretKey, bufferOpts, null, callBack);
+	}
+
+	/**
+	 *
+	 * @param context
+	 * @param productID
+	 * @param deviceName
+	 * @param secretKey
+	 * @param callBack
+	 */
+	public TXGatewayConnection(String productID, String deviceName, String secretKey, TXMqttActionCallBack callBack) {
+		this(productID, deviceName, secretKey, null, null, callBack);
+	}
+
+	public TXGatewayConnection(String srvURL, String productID, String deviceName, String secretKey,
+			TXMqttActionCallBack callBack) {
+		this(srvURL, productID, deviceName, secretKey, null, null, callBack);
+	}
+
+	/**
+	 *
+	 * @param productId
+	 * @param devName
+	 * @return null if not existed otherwise the subdev
+	 */
+	private TXGatewaySubdev findSubdev(String productId, String devName) {
+
+		LOG.debug("{}", "The hashed information is " + mSubdevs);
+		return mSubdevs.get(productId + devName);
+	}
+
+	/**
+	 * remove the subdev if it is offline
+	 * 
+	 * @param subdev
+	 * @return the operation results
+	 */
+	private synchronized TXGatewaySubdev removeSubdev(TXGatewaySubdev subdev) {
+		return mSubdevs.remove(subdev.mProductId + subdev.mDevName);
+	}
+
+	/**
+	 * remove the subdev if it is offline
+	 * 
+	 * @param productId
+	 * @param devName
+	 * @return
+	 */
+	private synchronized TXGatewaySubdev removeSubdev(String productId, String devName) {
+		return mSubdevs.remove(productId + devName);
+	}
+
+	/**
+	 * add a new subdev entry
+	 * 
+	 * @param dev
+	 */
+	private synchronized void addSubdev(TXGatewaySubdev dev) {
+		mSubdevs.put(dev.mProductId + dev.mDevName, dev);
+	}
+
+	/**
+	 * Get the subdev status
+	 * 
+	 * @param productId
+	 * @param devName
+	 * @return the status of subdev
+	 */
+	public Status getSubdevStatus(String productId, String devName) {
+		TXGatewaySubdev subdev = findSubdev(productId, devName);
+		if (subdev == null) {
+			return Status.SUBDEV_STAT_NOT_EXIST;
+		}
+		return subdev.getSubdevStatus();
+	}
+
+	/**
+	 * set the status of the subdev
+	 * 
+	 * @param productId
+	 * @param devName
+	 * @param stat
+	 * @return the status of operation
+	 */
+	public Status setSubdevStatus(String productId, String devName, Status stat) {
+		TXGatewaySubdev subdev = findSubdev(productId, devName);
+		if (subdev == null) {
+			return Status.SUBDEV_STAT_NOT_EXIST;
+		}
+		subdev.setSubdevStatus(stat);
+		return Status.OK;
+	}
+
+	/**
+	 * publish the offline message for the subdev
+	 * 
+	 * @param subProductID
+	 * @param subDeviceName
+	 * @return the result of operation
+	 */
+	public Status gatewaySubdevOffline(String subProductID, String subDeviceName) {
+		LOG.debug("{}", "Try to find " + subProductID + " & " + subDeviceName);
+		TXGatewaySubdev subdev = findSubdev(subProductID, subDeviceName);
+		if (subdev == null) {
+			LOG.debug("{}", "Cant find the subdev");
+			subdev = new TXGatewaySubdev(subProductID, subDeviceName);
+		}
+		String topic = GW_OPERATION_PREFIX + mProductId + "/" + mDeviceName;
+
+		LOG.debug("{}", "set " + subProductID + " & " + subDeviceName + " to offline");
+
+		// format the payload
+		JSONObject obj = new JSONObject();
+		try {
+			obj.put("type", "offline");
+			JSONObject plObj = new JSONObject();
+			String strDev = "[{'product_id':'" + subProductID + "','device_name':'" + subDeviceName + "'}]";
+			JSONArray devs = new JSONArray(strDev);
+			plObj.put("devices", devs);
+			obj.put("payload", plObj);
+		} catch (JSONException e) {
+			return Status.ERROR;
+		}
+		MqttMessage message = new MqttMessage();
+		message.setQos(0);
+		message.setPayload(obj.toString().getBytes());
+		LOG.debug("{}", "publish message " + message);
+
+		return super.publish(topic, message, null);
+	}
+
+	public Status gatewaySubdevOnline(String subProductID, String subDeviceName) {
+		TXGatewaySubdev subdev = findSubdev(subProductID, subDeviceName);
+		if (subdev == null) {
+			LOG.debug("{}", "Cant find the subdev");
+			subdev = new TXGatewaySubdev(subProductID, subDeviceName);
+		}
+		String topic = GW_OPERATION_PREFIX + mProductId + "/" + mDeviceName;
+		LOG.debug("{}", "set " + subProductID + " & " + subDeviceName + " to Online");
+		// format the payload
+		JSONObject obj = new JSONObject();
+		try {
+			obj.put("type", "online");
+			JSONObject plObj = new JSONObject();
+			String strDev = "[{'product_id':'" + subProductID + "','device_name':'" + subDeviceName + "'}]";
+			JSONArray devs = new JSONArray(strDev);
+			plObj.put("devices", devs);
+			obj.put("payload", plObj);
+		} catch (JSONException e) {
+			return Status.ERROR;
+		}
+		addSubdev(subdev);
+
+		MqttMessage message = new MqttMessage();
+		message.setQos(0);
+		message.setPayload(obj.toString().getBytes());
+		System.out.println( "publish to "+topic+" message " + message);
+
+		return super.publish(topic, message, null);
+	}
+
+	private boolean consumeGwOperationMsg(String topic, MqttMessage message) {
+		if (!topic.startsWith(GW_OPERATION_RES_PREFIX)) {
+			return false;
+		}
+		LOG.debug("{}", "got gate operation messga " + topic + message);
+		String productInfo = topic.substring(GW_OPERATION_RES_PREFIX.length());
+		int splitIdx = productInfo.indexOf('/');
+		String productId = productInfo.substring(0, splitIdx);
+		String devName = productInfo.substring(splitIdx + 1);
+
+		TXGatewaySubdev subdev = findSubdev(productId, devName);
+
+		// this subdev is not managed by me
+		if (subdev == null) {
+			return false;
+		}
+
+		try {
+			byte[] payload = message.getPayload();
+			JSONObject jsonObject = new JSONObject(new String(payload));
+
+			String type = jsonObject.getString("type");
+			if (type.equalsIgnoreCase("online")) {
+				String res = jsonObject.getString("result");
+
+				if (res.equals("0")) {
+					subdev.setSubdevStatus(Status.SUBDEV_STAT_ONLINE);
+				}
+
+			} else if (type.equalsIgnoreCase("offline")) {
+				String res = jsonObject.getString("result");
+
+				if (res.equals("0")) {
+					removeSubdev(subdev);
+				}
+			}
+
+		} catch (JSONException e) {
+
+		}
+
+		return true;
+	}
+
+	@Override
+	public void messageArrived(String topic, MqttMessage message) throws Exception {
+		LOG.debug("{}", "message received " + topic);
+		if (!consumeGwOperationMsg(topic, message)) {
+			super.messageArrived(topic, message);
+		}
+	}
+
+	@Override
+	public synchronized Status connect(MqttConnectOptions options, Object userContext) {
+		if (mConnectStatus.equals(TXMqttConstants.ConnectStatus.kConnecting)) {
+			LOG.info("{}", "The client is connecting. Connect return directly.");
+			return Status.MQTT_CONNECT_IN_PROGRESS;
+		}
+
+		if (mConnectStatus.equals(TXMqttConstants.ConnectStatus.kConnected)) {
+			LOG.info("{}", "The client is already connected. Connect return directly.");
+			return Status.OK;
+		}
+
+		this.mConnOptions = options;
+		if (mConnOptions == null) {
+			LOG.error("{}", "Connect options == null, will not connect.");
+			return Status.PARAMETER_INVALID;
+		}
+
+		Long timestamp = System.currentTimeMillis() / 1000 + 600;
+		String userNameStr = mUserName + ";" + getConnectId() + ";" + timestamp;
+		System.out.println("**** userNameStr is " + userNameStr + " timestamp " + timestamp);
+
+		mConnOptions.setUserName(userNameStr);
+
+		if (mSecretKey != null) {
+			try {
+				String passWordStr = HmacSha256.getSignature(userNameStr.getBytes(),
+						Base64.decode(mSecretKey, Base64.DEFAULT)) + ";hmacsha256";
+				mConnOptions.setPassword(passWordStr.toCharArray());
+			} catch (IllegalArgumentException e) {
+				LOG.debug("{}", "Failed to set password");
+			}
+		}
+
+		mConnOptions.setMqttVersion(MqttConnectOptions.MQTT_VERSION_3_1_1);
+
+		IMqttActionListener mActionListener = new IMqttActionListener() {
+			public void onSuccess(IMqttToken token) {
+				LOG.info("{}", "onSuccess!");
+				setConnectingState(TXMqttConstants.ConnectStatus.kConnected);
+				mActionCallBack.onConnectCompleted(Status.OK, false, token.getUserContext(),
+						"connected to " + mServerURI);
+				// If the connection is established, subscribe the gateway
+				// operation topic
+				String gwTopic = GW_OPERATION_RES_PREFIX + mProductId + "/" + mDeviceName;
+				int qos = TXMqttConstants.QOS1;
+
+				subscribe(gwTopic, qos, "Subscribe GATEWAY result topic");
+				LOG.debug("{}", "Connected, then subscribe the gateway result topic");
+			}
+
+			public void onFailure(IMqttToken token, Throwable exception) {
+				LOG.error("{}", exception, "onFailure!");
+				setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+				mActionCallBack.onConnectCompleted(Status.ERROR, false, token.getUserContext(), exception.toString());
+			}
+		};
+
+		if (mMqttClient == null) {
+			try {
+				mPingSender = new TXAlarmPingSender();
+				mMqttClient = new MqttAsyncClient(mServerURI, mClientId, mMqttPersist, mPingSender);
+				mMqttClient.setCallback(this);
+				mMqttClient.setBufferOpts(super.bufferOpts);
+				mMqttClient.setManualAcks(false);
+			} catch (Exception e) {
+				LOG.error("{}", "new MqttClient failed", e);
+				setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+				return Status.ERROR;
+			}
+		}
+
+		try {
+			LOG.info("Start connecting to {}", mServerURI);
+			setConnectingState(TXMqttConstants.ConnectStatus.kConnecting);
+			mMqttClient.connect(mConnOptions, userContext, mActionListener);
+		} catch (Exception e) {
+			LOG.error("{}", "MqttClient connect failed", e);
+			setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+			return Status.ERROR;
+		}
+
+		return Status.OK;
+	}
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/gateway/TXGatewaySubdev.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/gateway/TXGatewaySubdev.java	(date 1606400383043)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/core/gateway/TXGatewaySubdev.java	(date 1606400383043)
@@ -0,0 +1,43 @@
+package com.tencent.iot.hub.device.java.core.gateway;
+
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+
+/**
+ * Created by willssong on 2018/12/25.
+ */
+
+public class TXGatewaySubdev {
+    public static final String TAG = "TXGatewaySubdev";
+    public String mDevName;
+    public String mProductId;
+    private Status mStat;
+
+    /**
+     *
+     * @param devName           子设备设备名
+     * @param productId         子设备设备ID
+     */
+    public TXGatewaySubdev(String productId, String devName) {
+        mDevName = devName;
+        mProductId = productId;
+        mStat = Status.SUBDEV_STAT_INIT;
+    }
+
+    /**
+     *
+     * @return                  子设备当前状态
+     */
+    public synchronized Status getSubdevStatus() {
+        return mStat;
+    }
+
+    /**
+     *
+     * @param stat              更新子设备状态
+     */
+    public synchronized  void setSubdevStatus(Status stat) {
+        mStat = stat;
+    }
+
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/shadow/ShadowSample.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/shadow/ShadowSample.java	(date 1606400383052)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/shadow/ShadowSample.java	(date 1606400383052)
@@ -0,0 +1,134 @@
+package com.tencent.iot.hub.device.java.main.shadow;
+
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.shadow.DeviceProperty;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowActionCallBack;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowConnection;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowConstants;
+import com.tencent.iot.hub.device.java.core.util.AsymcSslUtils;
+
+
+public class ShadowSample {
+
+    private static final String TAG = ShadowSample.class.getSimpleName();
+    private static final Logger LOG = LoggerFactory.getLogger(ShadowSample.class);
+    
+    /**
+     * 产品名称
+     */
+    private static final String PRODUCT_ID = "YOUR_PRODUCT_ID";
+
+    /**
+     * 设备名称
+     */
+    private static final String DEVICE_NAME = "YOUR_DEVICE_NAME";
+
+
+    /**
+     * 密钥
+     */
+    private static final String SECRET_KEY = null;
+	
+    /**
+     * 设备证书名
+     */
+    private static final String DEVICE_CERT_NAME = "YOUR_DEVICE_NAME_cert.crt";
+
+    /**
+     * 设备私钥文件名
+     */
+    private static final String DEVICE_KEY_NAME = "YOUR_DEVICE_NAME_private.key";
+
+
+    /**
+     * shadow连接实例
+     */
+    private TXShadowConnection mShadowConnection;
+
+    /**
+     * shadow action 回调接口
+     */
+    private TXShadowActionCallBack mShadowActionCallBack;
+
+    private AtomicInteger mUpdateCount = new AtomicInteger(0);
+
+    private AtomicInteger mTemperatureDesire = new AtomicInteger(20);
+
+    /**
+     * 设备属性集（该变量必须为全局变量）
+     */
+    private List<DeviceProperty> mDevicePropertyList = null;
+
+    private boolean isConnected = false;
+
+    public ShadowSample(TXShadowActionCallBack shadowActionCallBack) {
+        this.mShadowActionCallBack = shadowActionCallBack;
+        this.mDevicePropertyList = new ArrayList<>();
+    }
+
+    public void getDeviceDocument() {
+        if (!isConnected) {
+            return;
+        }
+        mShadowConnection.get(null);
+    }
+
+    public void connect() {
+        LOG.info("{}", "connect");
+
+        mShadowConnection = new TXShadowConnection(PRODUCT_ID, DEVICE_NAME, SECRET_KEY, mShadowActionCallBack);
+
+        MqttConnectOptions options = new MqttConnectOptions();
+        options.setConnectionTimeout(8);
+        options.setKeepAliveInterval(240);
+        options.setAutomaticReconnect(true);
+        options.setSocketFactory(AsymcSslUtils.getSocketFactoryByAssetsFile(DEVICE_CERT_NAME, DEVICE_KEY_NAME));
+        Status status = mShadowConnection.connect(options, null);
+        LOG.info("connect IoT completed, status[{}]", status);
+        isConnected = true;
+    }
+
+    public void registerProperty() {
+        if (!isConnected) {
+            return;
+        }
+
+        DeviceProperty deviceProperty1 = new DeviceProperty();
+        deviceProperty1.key("updateCount").data(String.valueOf(mUpdateCount.getAndIncrement())).dataType(TXShadowConstants.JSONDataType.INT);
+        mShadowConnection.registerProperty(deviceProperty1);
+
+        DeviceProperty deviceProperty2 = new DeviceProperty();
+        deviceProperty2.key("temperatureDesire").data(String.valueOf(mTemperatureDesire.getAndIncrement())).dataType(TXShadowConstants.JSONDataType.INT);
+        mShadowConnection.registerProperty(deviceProperty2);
+
+        mDevicePropertyList.add(deviceProperty1);
+        mDevicePropertyList.add(deviceProperty2);
+    }
+
+    public void closeConnect() {
+        if (!isConnected) {
+            return;
+        }
+        mShadowConnection.disConnect(null);
+        isConnected = false;
+    }
+
+    public void updateDeviceProperty(String propertyJSONDocument, List<DeviceProperty> devicePropertyList) {
+        if (!isConnected) {
+            return;
+        }
+        LOG.info("{}", "update device property success and report null desired info");
+        // 在确认delta更新后，调用reportNullDesiredInfo()接口进行上报
+        mShadowConnection.reportNullDesiredInfo();
+    }
+   
+}
\ No newline at end of file
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/mqtt/MQTTRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/mqtt/MQTTRequest.java	(date 1606400383050)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/mqtt/MQTTRequest.java	(date 1606400383050)
@@ -0,0 +1,49 @@
+package com.tencent.iot.hub.device.java.main.mqtt;
+
+
+public class MQTTRequest {
+
+    private static final String TAG = MQTTRequest.class.getSimpleName();
+
+    /**
+     * 请求类型
+     */
+    private String requestType = "";
+
+    /**
+     * 请求ID
+     */
+    private int requestId = 0;
+
+    public MQTTRequest() {
+    }
+
+    public MQTTRequest(String requestType, int requestId) {
+        this.requestType = requestType;
+        this.requestId = requestId;
+    }
+
+    public String getRequestType() {
+        return requestType;
+    }
+
+    public void setRequestType(String requestType) {
+        this.requestType = requestType;
+    }
+
+    public int getRequestId() {
+        return requestId;
+    }
+
+    public void setRequestId(int requestId) {
+        this.requestId = requestId;
+    }
+
+    @Override
+    public String toString() {
+        return "MQTTRequest{" +
+                "requestType='" + requestType + '\'' +
+                ", requestId=" + requestId +
+                '}';
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/mqtt/MQTTSample.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/mqtt/MQTTSample.java	(date 1606400383050)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/mqtt/MQTTSample.java	(date 1606400383050)
@@ -0,0 +1,172 @@
+package com.tencent.iot.hub.device.java.main.mqtt;
+
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.tencent.iot.hub.device.java.core.gateway.TXGatewayConnection;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.util.AsymcSslUtils;
+
+public class MQTTSample {
+
+    private static final String TAG = "TXMQTT";
+    private static final Logger LOG = LoggerFactory.getLogger(MQTTSample.class);
+    
+    // Default Value, should be changed in testing
+    private String mBrokerURL = null;  //传入null，即使用腾讯云物联网通信默认地址 "${ProductId}.iotcloud.tencentdevices.com:8883"  https://cloud.tencent.com/document/product/634/32546
+    private String mProductID = "PRODUCT-ID";
+    private String mDevName = "DEVICE-NAME";
+    private String mDevPSK = "DEVICE-SECRET";
+    private String mSubProductID = "SUBDEV_PRODUCT-ID";
+    private String mSubDevName = "SUBDEV_DEV-NAME";
+    private String mTestTopic = "XLQ2S443OT/firefly";
+
+    private TXMqttActionCallBack mMqttActionCallBack;
+
+    /**
+     * MQTT连接实例
+     */
+    private TXMqttConnection mMqttConnection;
+
+    /**
+     * 请求ID
+     */
+    private static AtomicInteger requestID = new AtomicInteger(0);
+
+    public MQTTSample(TXMqttActionCallBack callBack) {
+        mMqttActionCallBack = callBack;
+        mMqttConnection = new TXMqttConnection(mProductID, mDevName, callBack);
+    }
+
+    public MQTTSample( TXMqttActionCallBack callBack, String brokerURL, String productId,
+                      String devName, String devPSK, String subProductID, String subDevName, String testTopic) {
+        mBrokerURL = brokerURL;
+        mProductID = productId;
+        mDevName = devName;
+        mDevPSK = devPSK;
+        mSubProductID = subProductID;
+        mSubDevName = subDevName;
+        mTestTopic = testTopic;
+        
+        mMqttActionCallBack = callBack;
+        mMqttConnection = new TXMqttConnection(mProductID, mDevName, mDevPSK, mMqttActionCallBack);
+    }
+
+    /**
+     * 获取主题
+     *
+     * @param topicName
+     * @return
+     */
+    private String getTopic(String topicName) {
+        return mTestTopic;
+    }
+
+    /**
+     * 建立MQTT连接
+     */
+    public void connect() {
+        mMqttConnection = new TXMqttConnection(mProductID, mDevName, mDevPSK, mMqttActionCallBack);
+        MqttConnectOptions options = new MqttConnectOptions();
+        options.setConnectionTimeout(8);
+        options.setKeepAliveInterval(240);
+        options.setAutomaticReconnect(true);
+
+ //       options.setSocketFactory(AsymcSslUtils.getSocketFactory());
+       
+
+        MQTTRequest mqttRequest = new MQTTRequest("connect", requestID.getAndIncrement());
+        mMqttConnection.connect(options, mqttRequest);
+
+        DisconnectedBufferOptions bufferOptions = new DisconnectedBufferOptions();
+        bufferOptions.setBufferEnabled(true);
+        bufferOptions.setBufferSize(1024);
+        bufferOptions.setDeleteOldestMessages(true);
+        mMqttConnection.setBufferOpts(bufferOptions);
+    }
+
+    /**
+     * 断开MQTT连接
+     */
+    public void disconnect() {
+        MQTTRequest mqttRequest = new MQTTRequest("disconnect", requestID.getAndIncrement());
+        mMqttConnection.disConnect(mqttRequest);
+    }
+
+    public void setSubdevOnline() {
+        // set subdev online
+       
+    }
+
+    public void setSubDevOffline() {
+       
+    }
+
+    /**
+     * 订阅主题
+     *
+     * @param topicName 主题名
+     */
+    public void subscribeTopic(String topicName) {
+        // 主题
+        String topic = getTopic(topicName);
+        // QOS等级
+        int qos = TXMqttConstants.QOS1;
+        // 用户上下文（请求实例）
+        MQTTRequest mqttRequest = new MQTTRequest("subscribeTopic", requestID.getAndIncrement());
+
+        LOG.debug("{}", "sub topic is " + topic);
+
+        // 订阅主题
+        mMqttConnection.subscribe(topic, qos, mqttRequest);
+
+    }
+
+    /**
+     * 取消订阅主题
+     *
+     * @param topicName 主题名
+     */
+    public void unSubscribeTopic(String topicName) {
+        // 主题
+        String topic = getTopic(topicName);
+        // 用户上下文（请求实例）
+        MQTTRequest mqttRequest = new MQTTRequest("unSubscribeTopic", requestID.getAndIncrement());
+        LOG.debug("{}", "Start to unSubscribe" + topic);
+        // 取消订阅主题
+        mMqttConnection.unSubscribe(topic, mqttRequest);
+    }
+
+    /**
+     * 发布主题
+     */
+    public void publishTopic(String topicName,  JSONObject jsonObject) {
+
+        // 主题
+        String topic = getTopic(topicName);
+        System.out.print("aaaaaaaaaaaaa " +topic);
+        // MQTT消息
+        MqttMessage message = new MqttMessage();
+
+        message.setQos(TXMqttConstants.QOS1);
+        message.setPayload(jsonObject.toString().getBytes());
+
+        // 用户上下文（请求实例）
+        MQTTRequest mqttRequest = new MQTTRequest("publishTopic", requestID.getAndIncrement());
+
+        LOG.debug("{}", "pub topic " + topic + message);
+        // 发布主题
+        mMqttConnection.publish(topic, message, mqttRequest);
+
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/service/RemoteRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/service/RemoteRequest.java	(date 1606400383051)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/service/RemoteRequest.java	(date 1606400383051)
@@ -0,0 +1,21 @@
+package com.tencent.iot.hub.device.java.main.service;
+
+
+public class RemoteRequest {
+
+    private int mRequestId;
+
+    public RemoteRequest() {
+    }
+
+    public RemoteRequest(int requestId) {
+        this.mRequestId = requestId;
+    }
+
+    @Override
+    public String toString() {
+        return "RemoteRequest{" +
+                "mRequestId=" + mRequestId +
+                '}';
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/shadow/SelfMqttActionCallBack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/shadow/SelfMqttActionCallBack.java	(date 1606400383051)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/shadow/SelfMqttActionCallBack.java	(date 1606400383051)
@@ -0,0 +1,91 @@
+package com.tencent.iot.hub.device.java.main.shadow;
+
+import java.util.Arrays;
+
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.java.main.mqtt.MQTTRequest;
+
+public class SelfMqttActionCallBack extends TXMqttActionCallBack {
+	private static final String TAG = "TXMQTT";
+	private static final Logger LOG = LoggerFactory.getLogger(TXMqttConnection.class);
+    @Override
+    public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {
+        String userContextInfo = "";
+        if (userContext instanceof MQTTRequest) {
+            userContextInfo = userContext.toString();
+        }
+        String logInfo = String.format("onConnectCompleted, status[%s], reconnect[%b], userContext[%s], msg[%s]",
+                status.name(), reconnect, userContextInfo, msg);
+        System.out.println("***************** OnConnectCompleted " + logInfo);
+        LOG.info("{}", logInfo);
+    }
+
+    @Override
+    public void onConnectionLost(Throwable cause) {
+        String logInfo = String.format("onConnectionLost, cause[%s]", cause.toString());
+        LOG.info("{}", logInfo);
+    }
+
+    @Override
+    public void onDisconnectCompleted(Status status, Object userContext, String msg) {
+        String userContextInfo = "";
+        if (userContext instanceof MQTTRequest) {
+            userContextInfo = userContext.toString();
+        }
+        String logInfo = String.format("onDisconnectCompleted, status[%s], userContext[%s], msg[%s]", status.name(), userContextInfo, msg);
+        LOG.info("{}", logInfo);
+    }
+
+    @Override
+    public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
+        String userContextInfo = "";
+        if (userContext instanceof MQTTRequest) {
+            userContextInfo = userContext.toString();
+        }
+        String logInfo = String.format("onPublishCompleted, status[%s], topics[%s],  userContext[%s], errMsg[%s]",
+                status.name(), Arrays.toString(token.getTopics()), userContextInfo, errMsg);
+        LOG.info("{}", logInfo);
+    }
+
+    @Override
+    public void onSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+        String userContextInfo = "";
+        System.out.println("***************** OnSub " + status);
+        if (userContext instanceof MQTTRequest) {
+            userContextInfo = userContext.toString();
+        }
+        String logInfo = String.format("onSubscribeCompleted, status[%s], topics[%s], userContext[%s], errMsg[%s]",
+                status.name(), Arrays.toString(asyncActionToken.getTopics()), userContextInfo, errMsg);
+        if (Status.ERROR == status) {
+            LOG.info("{}", logInfo);
+        } else {
+            LOG.info("{}", logInfo);
+        }
+    }
+
+    @Override
+    public void onUnSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+        String userContextInfo = "";
+        if (userContext instanceof MQTTRequest) {
+            userContextInfo = userContext.toString();
+        }
+        String logInfo = String.format("onUnSubscribeCompleted, status[%s], topics[%s], userContext[%s], errMsg[%s]",
+                status.name(), Arrays.toString(asyncActionToken.getTopics()), userContextInfo, errMsg);
+        LOG.info("{}", logInfo);
+    }
+
+    @Override
+    public void onMessageReceived(final String topic, final MqttMessage message) {
+        String logInfo = String.format("receive command, topic[%s], message[%s]", topic, message.toString());
+        System.out.println("***************** OnMsgReceived " + logInfo);
+        LOG.info("{}", logInfo);
+    }
+
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/shadow/ShadowRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/shadow/ShadowRequest.java	(date 1606400383051)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/shadow/ShadowRequest.java	(date 1606400383051)
@@ -0,0 +1,22 @@
+package com.tencent.iot.hub.device.java.main.shadow;
+
+
+
+public class ShadowRequest {
+
+    private int mRequestId;
+
+    public ShadowRequest() {
+    }
+
+    public ShadowRequest(int mRequestId) {
+        this.mRequestId = mRequestId;
+    }
+
+    @Override
+    public String toString() {
+        return "ShadowRequest{" +
+                "mRequestId=" + mRequestId +
+                '}';
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/scenarized/Airconditioner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/scenarized/Airconditioner.java	(date 1606400383050)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/scenarized/Airconditioner.java	(date 1606400383050)
@@ -0,0 +1,77 @@
+package com.tencent.iot.hub.device.java.main.scenarized;
+
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.util.AsymcSslUtils;
+
+public class Airconditioner {
+
+    private static final Logger LOG = LoggerFactory.getLogger(Airconditioner.class);
+	public static final String TAG = "iot.scenarized.Airconditioner";
+
+	/**
+	 * 产品ID
+	 */
+	private static final String PRODUCT_ID = "YOUR_PRODUCT_ID";
+
+	/**
+	 * 设备名称
+	 */
+	protected static final String DEVICE_NAME = "YOUR_DEVICE_NAME";
+
+	/**
+	 * 密钥
+	 */
+	private static final String SECRET_KEY = "YOUR_SECRET_KEY";
+	/**
+	 * 设备证书名
+	 */
+	private static final String DEVICE_CERT_NAME = "YOUR_DEVICE_NAME_cert.crt";
+
+	/**
+	 * 设备私钥文件名
+	 */
+	private static final String DEVICE_KEY_NAME = "YOUR_DEVICE_NAME_private.key";
+
+	private TXMqttConnection mqttConnection;
+
+	private MqttConnectOptions options;
+
+	public Airconditioner( TXMqttActionCallBack callBack) {
+
+		mqttConnection = new TXMqttConnection(PRODUCT_ID, DEVICE_NAME, SECRET_KEY, callBack);
+
+		options = new MqttConnectOptions();
+		options.setConnectionTimeout(8);
+		options.setKeepAliveInterval(240);
+		options.setAutomaticReconnect(true);
+		options.setSocketFactory(
+				AsymcSslUtils.getSocketFactoryByAssetsFile(DEVICE_CERT_NAME, DEVICE_KEY_NAME));
+
+		mqttConnection.connect(options, null);
+		DisconnectedBufferOptions bufferOptions = new DisconnectedBufferOptions();
+		bufferOptions.setBufferEnabled(true);
+		bufferOptions.setBufferSize(1024);
+		bufferOptions.setDeleteOldestMessages(true);
+		mqttConnection.setBufferOpts(bufferOptions);
+	}
+
+	public void subScribeTopic() {
+		LOG.debug("{}", "subScribeTopic");
+		String topic = String.format("%s/%s/%s", PRODUCT_ID, DEVICE_NAME, "control");
+		mqttConnection.subscribe(topic, TXMqttConstants.QOS1, null);
+	}
+
+	public void closeConnection() {
+		if (null != mqttConnection) {
+			mqttConnection.disConnect(null);
+		}
+	}
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/scenarized/Door.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/scenarized/Door.java	(date 1606400383051)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/scenarized/Door.java	(date 1606400383051)
@@ -0,0 +1,155 @@
+package com.tencent.iot.hub.device.java.main.scenarized;
+
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.util.AsymcSslUtils;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Door {
+
+    public static final String TAG = "iot.scenarized.Door";
+    private static final Logger LOG = LoggerFactory.getLogger(Door.class);
+    
+    /**
+     * 产品ID
+     */
+    private static final String PRODUCT_ID = "YOUR_PRODUCT_ID";
+
+    /**
+     * 设备名称
+     */
+    private static final String DEVICE_NAME = "YOUR_DEVICE_NAME";
+
+    /**
+     * 密钥
+     */
+    private static final String SECRET_KEY = "YOUR_SECRET_KEY";
+	
+    /**
+     * 设备证书名
+     */
+    private static final String DEVICE_CERT_NAME = "YOUR_DEVICE_NAME_cert.crt";
+
+    /**
+     * 设备私钥文件名
+     */
+    private static final String DEVICE_KEY_NAME = "YOUR_DEVICE_NAME_private.key";
+
+    private static final String COME_HOME_MESSAGE = "{\"action\": \"come_home\", \"targetDevice\": \"" + Airconditioner.DEVICE_NAME + "\"}";
+    private static final String LEAVE_HOME_MESSAGE = "{\"action\": \"leave_home\", \"targetDevice\": \"" + Airconditioner.DEVICE_NAME + "\"}";
+
+    private TXMqttConnection mqttConnection;
+
+    private MqttConnectOptions options;
+
+    public Door() {
+    }
+
+
+    /**
+     * 进门
+     */
+    public void enterRoom() {
+        if (mqttConnection == null) {
+            mqttConnection = new TXMqttConnection(PRODUCT_ID, DEVICE_NAME, SECRET_KEY, new DoorMqttActionCallBack());
+
+            options = new MqttConnectOptions();
+            options.setConnectionTimeout(8);
+            options.setKeepAliveInterval(240);
+            options.setAutomaticReconnect(true);
+            options.setSocketFactory(AsymcSslUtils.getSocketFactoryByAssetsFile(DEVICE_CERT_NAME, DEVICE_KEY_NAME));
+
+            mqttConnection.connect(options, null);
+            DisconnectedBufferOptions bufferOptions = new DisconnectedBufferOptions();
+            bufferOptions.setBufferEnabled(true);
+            bufferOptions.setBufferSize(1024);
+            bufferOptions.setDeleteOldestMessages(true);
+            mqttConnection.setBufferOpts(bufferOptions);
+        }
+
+        if (mqttConnection.getConnectStatus().equals(TXMqttConstants.ConnectStatus.kConnected)) {
+            MqttMessage message = new MqttMessage();
+            message.setPayload(COME_HOME_MESSAGE.getBytes());
+            String topic = String.format("%s/%s/%s", PRODUCT_ID, DEVICE_NAME, "event");
+            mqttConnection.publish(topic, message, null);
+        } else {
+            //mqttConnection.connect(options, null);
+        }
+    }
+
+    /**
+     * 出门
+     */
+    public void leaveRoom() {
+        if (null == mqttConnection) {
+            LOG.error("please enter room first!");
+            return;
+        }
+        MqttMessage message = new MqttMessage();
+        message.setPayload(LEAVE_HOME_MESSAGE.getBytes());
+        String topic = String.format("%s/%s/%s", PRODUCT_ID, DEVICE_NAME, "event");
+        mqttConnection.publish(topic, message, null);
+
+        closeConnection();
+    }
+
+    public void closeConnection() {
+        if (null != mqttConnection) {
+            mqttConnection.disConnect(null);
+            mqttConnection = null;
+        }
+    }
+
+    private class DoorMqttActionCallBack extends TXMqttActionCallBack {
+
+        @Override
+        public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {
+            LOG.info("onConnectCompleted：" + msg);
+
+            if (status.equals(Status.OK)) {
+                if (!reconnect) {
+                    MqttMessage message = new MqttMessage();
+                    message.setPayload(COME_HOME_MESSAGE.getBytes());
+                    String topic = String.format("%s/%s/%s", PRODUCT_ID, DEVICE_NAME, "event");
+                    mqttConnection.publish(topic, message, null);
+                }
+            }
+        }
+
+        @Override
+        public void onConnectionLost(Throwable cause) {
+            String logInfo = String.format("onConnectionLost, cause[%s]", cause.toString());
+            LOG.info(logInfo);
+        }
+
+        @Override
+        public void onDisconnectCompleted(Status status, Object userContext, String msg) {
+            String logInfo = String.format("onDisconnectCompleted, status[%s], msg[%s]", status.name(), msg);
+            LOG.info(logInfo);
+        }
+
+        @Override
+        public void onSubscribeCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+            String logInfo = String.format("onSubscribeCompleted, status[%s], message[%s]", status.name(), msg);
+            if (Status.ERROR == status) {
+                LOG.error(logInfo);
+            } else {
+                LOG.info(logInfo);
+            }
+        }
+
+        @Override
+        public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+            super.onPublishCompleted(status, token, userContext, msg);
+        }
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/utils/MyDailyRollingFileAppender.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/utils/MyDailyRollingFileAppender.java	(date 1606400383057)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/utils/MyDailyRollingFileAppender.java	(date 1606400383057)
@@ -0,0 +1,424 @@
+package com.tencent.iot.hub.device.java.utils;
+ 
+ 
+import java.io.File;
+import java.io.IOException;
+import java.io.Writer;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+ 
+import org.apache.log4j.FileAppender;
+import org.apache.log4j.Layout;
+import org.apache.log4j.helpers.CountingQuietWriter;
+import org.apache.log4j.helpers.LogLog;
+import org.apache.log4j.helpers.OptionConverter;
+import org.apache.log4j.spi.LoggingEvent;
+ 
+ 
+public class MyDailyRollingFileAppender extends FileAppender
+{
+ 
+    // The code assumes that the following constants are in a increasing
+    // sequence.
+    static final int TOP_OF_TROUBLE = -1;
+ 
+    static final int TOP_OF_MINUTE = 0;
+ 
+    static final int TOP_OF_HOUR = 1;
+ 
+    static final int HALF_DAY = 2;
+ 
+    static final int TOP_OF_DAY = 3;
+ 
+    static final int TOP_OF_WEEK = 4;
+ 
+    static final int TOP_OF_MONTH = 5;
+ 
+    /** 
+    * The default maximum file size is 10MB. 
+    */
+    protected long maxFileSize = 50 * 1024 * 1024;
+ 
+    /** 
+    * There is one backup file by default. 
+    */
+    protected int maxBackupIndex =  1000;
+ 
+    /** 
+    * meaning daily rollover. 
+    */
+    private String datePattern = "'.'yyyy-MM-dd";
+ 
+    /** 
+    * "scheduledFilename" at the beginning of the next hour. 
+    *  
+    */
+    private String scheduledFilename;
+ 
+    /** 
+    * The next time we estimate a rollover should occur. 
+    */
+    private long nextCheck = System.currentTimeMillis() - 1;
+ 
+    Date now = new Date();
+ 
+    SimpleDateFormat sdf;
+ 
+    RollingCalendar rc = new RollingCalendar();
+ 
+    int checkPeriod = TOP_OF_TROUBLE;
+ 
+    // The gmtTimeZone is used only in computeCheckPeriod() method.
+    static final TimeZone gmtTimeZone = TimeZone.getTimeZone("GMT");
+ 
+    /** 
+    * The default constructor does nothing. 
+    */
+    public MyDailyRollingFileAppender()
+    {
+    }
+ 
+    /** 
+    * ouput destination for this appender. 
+    */
+    public MyDailyRollingFileAppender(Layout layout, String filename, String datePattern) throws IOException
+    {
+        super(layout, filename, true);
+        this.datePattern = datePattern;
+        activateOptions();
+    }
+ 
+    /** 
+    * being rolled over to backup files. 
+    *  
+    * @since 1.1 
+    */
+    public long getMaximumFileSize()
+    {
+        return maxFileSize;
+    }
+ 
+    /** 
+    * being rolled over to backup files. 
+    *  
+    * <p> 
+    * JavaBeans {@link java.beans.Introspector Introspector}. 
+    *  
+    * @see #setMaxFileSize(String) 
+    */
+    public void setMaximumFileSize(long maxFileSize)
+    {
+        this.maxFileSize = maxFileSize;
+    }
+ 
+    /** 
+    * being rolled over to backup files. 
+    *  
+    * <p> 
+    * the value "10KB" will be interpreted as 10240. 
+    */
+    public void setMaxFileSize(String value)
+    {
+        maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
+    }
+ 
+    /** 
+    * Returns the value of the <b>MaxBackupIndex</b> option. 
+    */
+    public int getMaxBackupIndex()
+    {
+        return maxBackupIndex;
+    }
+ 
+    /** 
+    * Set the maximum number of backup files to keep around. 
+    *  
+    * <p> 
+    */
+    public void setMaxBackupIndex(int maxBackups)
+    {
+        this.maxBackupIndex = maxBackups;
+    }
+ 
+    /** 
+    */
+    public void setDatePattern(String pattern)
+    {
+        datePattern = pattern;
+    }
+ 
+    /** Returns the value of the <b>DatePattern</b> option. */
+    public String getDatePattern()
+    {
+        return datePattern;
+    }
+ 
+    @Override
+    public void activateOptions()
+    {
+        super.activateOptions();
+        if (datePattern != null && fileName != null)
+        {
+            now.setTime(System.currentTimeMillis());
+            sdf = new SimpleDateFormat(datePattern);
+            int type = computeCheckPeriod();
+            printPeriodicity(type);
+            rc.setType(type);
+            File file = new File(fileName);
+            scheduledFilename = fileName + sdf.format(new Date(file.lastModified()));
+ 
+        }
+        else
+        {
+            LogLog.error("Either File or DatePattern options are not set for appender [" + name + "].");
+        }
+    }
+ 
+    void printPeriodicity(int type)
+    {
+        switch (type)
+        {
+        case TOP_OF_MINUTE:
+            LogLog.debug("Appender [" + name + "] to be rolled every minute.");
+            break;
+        case TOP_OF_HOUR:
+            LogLog.debug("Appender [" + name + "] to be rolled on top of every hour.");
+            break;
+        case HALF_DAY:
+            LogLog.debug("Appender [" + name + "] to be rolled at midday and midnight.");
+            break;
+        case TOP_OF_DAY:
+            LogLog.debug("Appender [" + name + "] to be rolled at midnight.");
+            break;
+        case TOP_OF_WEEK:
+            LogLog.debug("Appender [" + name + "] to be rolled at start of week.");
+            break;
+        case TOP_OF_MONTH:
+            LogLog.debug("Appender [" + name + "] to be rolled at start of every month.");
+            break;
+        default:
+            LogLog.warn("Unknown periodicity for appender [" + name + "].");
+        }
+    }
+ 
+    // This method computes the roll over period by looping over the
+    // periods, starting with the shortest, and stopping when the r0 is
+    // different from from r1, where r0 is the epoch formatted according
+    // the datePattern (supplied by the user) and r1 is the
+    // epoch+nextMillis(i) formatted according to datePattern. All date
+    // formatting is done in GMT and not local format because the test
+    // logic is based on comparisons relative to 1970-01-01 00:00:00
+    // GMT (the epoch).
+ 
+    int computeCheckPeriod()
+    {
+        RollingCalendar rollingCalendar = new RollingCalendar(gmtTimeZone, Locale.ENGLISH);
+        // set sate to 1970-01-01 00:00:00 GMT
+        Date epoch = new Date(0);
+        if (datePattern != null)
+        {
+            for (int i = TOP_OF_MINUTE; i <= TOP_OF_MONTH; i++)
+            {
+                SimpleDateFormat simpleDateFormat = new SimpleDateFormat(datePattern);
+                simpleDateFormat.setTimeZone(gmtTimeZone); // do all date
+                                                            // formatting in GMT
+                String r0 = simpleDateFormat.format(epoch);
+                rollingCalendar.setType(i);
+                Date next = new Date(rollingCalendar.getNextCheckMillis(epoch));
+                String r1 = simpleDateFormat.format(next);
+                // System.out.println("Type = "+i+", r0 = "+r0+", r1 = "+r1);
+                if (r0 != null && r1 != null && !r0.equals(r1))
+                {
+                    return i;
+                }
+            }
+        }
+        return TOP_OF_TROUBLE; // Deliberately head for trouble...
+    }
+ 
+    /** 
+    * Implements the usual roll over behaviour. 
+    *  
+    * <p> 
+    * If <code>MaxBackupIndex</code> is positive, then files { 
+     
+    *  
+    * <p> 
+    * If <code>MaxBackupIndex</code> is equal to zero, then the 
+    * <code>File</code> is truncated with no backup files created. 
+    */
+    public // synchronization not necessary since doAppend is alreasy synched
+    void sizeRollOver()
+    {
+        File target;
+        File file;
+ 
+        LogLog.debug("rolling over count=" + ((CountingQuietWriter) qw).getCount());
+        LogLog.debug("maxBackupIndex=" + maxBackupIndex);
+ 
+        String datedFilename = fileName + sdf.format(now);
+ 
+        if (maxBackupIndex > 0)
+        {
+            // Delete the oldest file, to keep Windows happy.
+            file = new File(datedFilename + '.' + maxBackupIndex);
+            if (file.exists())
+                file.delete();
+ 
+            // Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3,
+            // 2}
+            for (int i = maxBackupIndex - 1; i >= 1; i--)
+            {
+                file = new File(datedFilename + "." + i);
+                if (file.exists())
+                {
+                    target = new File(datedFilename + '.' + (i + 1));
+                    LogLog.debug("Renaming file " + file + " to " + target);
+                    file.renameTo(target);
+                }
+            }
+ 
+            // Rename fileName to datedFilename.1
+            target = new File(datedFilename + "." + 1);
+ 
+            this.closeFile(); // keep windows happy.
+ 
+            file = new File(fileName);
+            LogLog.debug("Renaming file " + file + " to " + target);
+            file.renameTo(target);
+        }
+        else if (maxBackupIndex < 0)
+        { // infinite number of files
+            // find the max backup index
+            for (int i = 1; i < Integer.MAX_VALUE; i++)
+            {
+                target = new File(datedFilename + "." + i);
+                if (!target.exists())
+                { // Rename fileName to datedFilename.i
+                    this.closeFile();
+                    file = new File(fileName);
+                    file.renameTo(target);
+                    LogLog.debug("Renaming file " + file + " to " + target);
+                    break;
+                }
+            }
+        }
+ 
+        try
+        {
+            // This will also close the file. This is OK since multiple
+            // close operations are safe.
+            this.setFile(fileName, false, bufferedIO, bufferSize);
+        }
+        catch (IOException e)
+        {
+            LogLog.error("setFile(" + fileName + ", false) call failed.", e);
+        }
+        scheduledFilename = datedFilename;
+    }
+ 
+    @Override
+    public synchronized void setFile(String fileName, boolean append, boolean bufferedIO, int bufferSize) throws IOException
+    {
+        super.setFile(fileName, append, this.bufferedIO, this.bufferSize);
+        if (append)
+        {
+            File f = new File(fileName);
+            ((CountingQuietWriter) qw).setCount(f.length());
+        }
+    }
+ 
+    @Override
+    protected void setQWForFiles(Writer writer)
+    {
+        this.qw = new CountingQuietWriter(writer, errorHandler);
+    }
+ 
+    /** 
+    * Rollover the current file to a new file. 
+    */
+    void timeRollOver() throws IOException
+    {
+ 
+        /* Compute filename, but only if datePattern is specified */
+        if (datePattern == null)
+        {
+            errorHandler.error("Missing DatePattern option in rollOver().");
+            return;
+        }
+ 
+        String datedFilename = fileName + sdf.format(now);
+        // It is too early to roll over because we are still within the
+        // bounds of the current interval. Rollover will occur once the
+        // next interval is reached.
+        if (scheduledFilename.equals(datedFilename))
+        {
+            return;
+        }
+ 
+        // close current file, and rename it to datedFilename
+        this.closeFile();
+ 
+        File target = new File(scheduledFilename);
+        if (target.exists())
+        {
+            target.delete();
+        }
+ 
+        File file = new File(fileName);
+        boolean result = file.renameTo(target);
+        if (result)
+        {
+            LogLog.debug(fileName + " -> " + scheduledFilename);
+        }
+        else
+        {
+            LogLog.error("Failed to rename [" + fileName + "] to [" + scheduledFilename + "].");
+        }
+ 
+        try
+        {
+            // This will also close the file. This is OK since multiple
+            // close operations are safe.
+            super.setFile(fileName, false, this.bufferedIO, this.bufferSize);
+        }
+        catch (IOException e)
+        {
+            errorHandler.error("setFile(" + fileName + ", false) call failed.");
+        }
+        scheduledFilename = datedFilename;
+    }
+ 
+    /** 
+    *  
+    * <p> 
+    * rollover. 
+    * */
+    @Override
+    protected void subAppend(LoggingEvent event)
+    {
+        long n = System.currentTimeMillis();
+ 
+        if (n >= nextCheck)
+        {
+            now.setTime(n);
+            nextCheck = rc.getNextCheckMillis(now);
+            try
+            {
+                timeRollOver();
+            }
+            catch (IOException ioe)
+            {
+                LogLog.error("rollOver() failed.", ioe);
+            }
+        }
+        else if ((fileName != null) && ((CountingQuietWriter) qw).getCount() >= maxFileSize)
+        {
+            sizeRollOver();
+        }
+        super.subAppend(event);
+ 
+    }
+}
\ No newline at end of file
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/utils/RollingCalendar.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/utils/RollingCalendar.java	(date 1606400383058)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/utils/RollingCalendar.java	(date 1606400383058)
@@ -0,0 +1,102 @@
+package com.tencent.iot.hub.device.java.utils;
+ 
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.TimeZone;
+ 
+/**
+ * ClassName:RollingCalendar <br/>
+ * Date:     2016年3月31日 上午11:41:34 <br/>
+ * @author   lujie
+ * @version 
+ * @see     
+ */
+class RollingCalendar extends GregorianCalendar
+{
+    private static final long serialVersionUID = -3560331770601814177L;
+ 
+    int type = MyDailyRollingFileAppender.TOP_OF_TROUBLE;
+ 
+    RollingCalendar()
+    {
+        super();
+    }
+ 
+    RollingCalendar(TimeZone tz, Locale locale)
+    {
+        super(tz, locale);
+    }
+ 
+    void setType(int type)
+    {
+        this.type = type;
+    }
+ 
+    public long getNextCheckMillis(Date now)
+    {
+        return getNextCheckDate(now).getTime();
+    }
+ 
+    public Date getNextCheckDate(Date now)
+    {
+        this.setTime(now);
+ 
+        switch (type)
+        {
+        case MyDailyRollingFileAppender.TOP_OF_MINUTE:
+            this.set(Calendar.SECOND, 0);
+            this.set(Calendar.MILLISECOND, 0);
+            this.add(Calendar.MINUTE, 1);
+            break;
+        case MyDailyRollingFileAppender.TOP_OF_HOUR:
+            this.set(Calendar.MINUTE, 0);
+            this.set(Calendar.SECOND, 0);
+            this.set(Calendar.MILLISECOND, 0);
+            this.add(Calendar.HOUR_OF_DAY, 1);
+            break;
+        case MyDailyRollingFileAppender.HALF_DAY:
+            this.set(Calendar.MINUTE, 0);
+            this.set(Calendar.SECOND, 0);
+            this.set(Calendar.MILLISECOND, 0);
+            int hour = get(Calendar.HOUR_OF_DAY);
+            if (hour < 12)
+            {
+                this.set(Calendar.HOUR_OF_DAY, 12);
+            }
+            else
+            {
+                this.set(Calendar.HOUR_OF_DAY, 0);
+                this.add(Calendar.DAY_OF_MONTH, 1);
+            }
+            break;
+        case MyDailyRollingFileAppender.TOP_OF_DAY:
+            this.set(Calendar.HOUR_OF_DAY, 0);
+            this.set(Calendar.MINUTE, 0);
+            this.set(Calendar.SECOND, 0);
+            this.set(Calendar.MILLISECOND, 0);
+            this.add(Calendar.DATE, 1);
+            break;
+        case MyDailyRollingFileAppender.TOP_OF_WEEK:
+            this.set(Calendar.DAY_OF_WEEK, getFirstDayOfWeek());
+            this.set(Calendar.HOUR_OF_DAY, 0);
+            this.set(Calendar.MINUTE, 0);
+            this.set(Calendar.SECOND, 0);
+            this.set(Calendar.MILLISECOND, 0);
+            this.add(Calendar.WEEK_OF_YEAR, 1);
+            break;
+        case MyDailyRollingFileAppender.TOP_OF_MONTH:
+            this.set(Calendar.DATE, 1);
+            this.set(Calendar.HOUR_OF_DAY, 0);
+            this.set(Calendar.MINUTE, 0);
+            this.set(Calendar.SECOND, 0);
+            this.set(Calendar.MILLISECOND, 0);
+            this.add(Calendar.MONTH, 1);
+            break;
+        default:
+            throw new IllegalStateException("Unknown periodicity type.");
+        }
+        return getTime();
+    }
+}
\ No newline at end of file
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXShadowActionListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXShadowActionListener.java	(date 1606400383057)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXShadowActionListener.java	(date 1606400383057)
@@ -0,0 +1,64 @@
+// ITXShadowListener.aidl
+package com.tencent.iot.hub.device.java.service.interfaces;
+
+import com.tencent.iot.hub.device.java.service.TXMqttMessage;
+import com.tencent.iot.hub.device.java.service.TXMqttToken;
+
+import java.util.List;
+
+import com.tencent.iot.hub.device.java.core.shadow.DeviceProperty;
+
+public interface ITXShadowActionListener {
+
+    /**
+     * 文档请求响应的回调接口
+     *
+     * @param type     文档操作方式, get/update/delete
+     * @param result   请求响应结果, 0: 成功；非0：失败
+     * @param document 云端返回的JSON文档
+     */
+    void onRequestCallback(String type, int result, String document);
+
+    /**
+     * 设备属性处理回调接口
+     *
+     * @param propertyJSONDocument 设备属性json文档
+     * @param devicePropertyList   更新后的设备属性集
+     */
+    void onDevicePropertyCallback(String propertyJSONDocument,  List<DeviceProperty> devicePropertyList);
+
+    /**
+     * 发布消息完成回调
+     *
+     * @param status OK: 发布消息成功，ERROR: 发布消息失败
+     * @param token  消息token
+     * @param errMsg 详细信息
+     */
+    void onPublishCompleted(String status, TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 订阅主题完成回调
+     *
+     * @param status     OK: 订阅成功，ERROR: 订阅失败
+     * @param token      消息token
+     * @param errMsg     详细信息
+     */
+    void onSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 取消订阅主题完成回调
+     *
+     * @param status    OK: 取消订阅成功，ERROR: 取消订阅失败
+     * @param token     消息token，包含消息内容结构体
+     * @param errMsg    详细信息
+     */
+    void onUnSubscribeCompleted(String status,TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 收到订阅主题的消息Push
+     *
+     * @param topic   主题名称
+     * @param message 消息内容
+     */
+    void onMessageReceived(String topic, TXMqttMessage message);
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXMqttActionListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXMqttActionListener.java	(date 1606400383056)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXMqttActionListener.java	(date 1606400383056)
@@ -0,0 +1,78 @@
+// ITXMqttListener.aidl
+package com.tencent.iot.hub.device.java.service.interfaces;
+
+import com.tencent.iot.hub.device.java.service.TXMqttMessage;
+import com.tencent.iot.hub.device.java.service.TXMqttToken;
+
+public interface ITXMqttActionListener {
+
+    /**
+     * MQTT Connect完成回调
+     *
+     * @param status    OK: 连接成功        ERROR: 连接失败
+     * @param reconnect true: 重新连接      false: 首次连接
+     * @param msg       连接信息
+     */
+    void onConnectCompleted(String status, boolean reconnect, long userContextId, String msg);
+
+    /**
+     * MQTT连接断开回调
+     *
+     * @param cause 连接断开原因
+     */
+    void onConnectionLost(String cause);
+
+    /**
+     * MQTT Disconnect完成回调
+     *
+     * @param status OK: 断连成功，ERROR: 断连失败
+     * @param msg    相信信息
+     */
+    void onDisconnectCompleted(String status, long userContextId, String msg);
+
+    /**
+     * 发布消息完成回调
+     *
+     * @param status OK: 发布消息成功，ERROR: 发布消息失败
+     * @param token  消息token
+     * @param errMsg 详细信息
+     */
+    void onPublishCompleted(String status,  TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 订阅主题完成回调
+     *
+     * @param status  OK: 订阅成功，ERROR: 订阅失败
+     * @param token   消息token
+     * @param errMsg  详细信息
+     */
+    void onSubscribeCompleted(String status,  TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 取消订阅主题完成回调
+     *
+     * @param status    OK: 取消订阅成功，ERROR: 取消订阅失败
+     * @param token     消息token
+     * @param errMsg    详细信息
+     */
+    void onUnSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 收到订阅主题的消息Push
+     *
+     * @param topic   主题名称
+     * @param message 消息内容
+     */
+    void onMessageReceived(String topic,  TXMqttMessage message);
+
+    /**
+     * 远程服务已启动回调接口
+     */
+    void onServiceStartedCallback();
+
+    /**
+     * 远程服务销毁回调接口
+     */
+    void onServiceDestroyCallback();
+
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXOTAListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXOTAListener.java	(date 1606400383057)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXOTAListener.java	(date 1606400383057)
@@ -0,0 +1,38 @@
+// ITXMqttListener.aidl
+package com.tencent.iot.hub.device.java.service.interfaces;
+
+public interface ITXOTAListener {
+
+    /**
+     * 上报固件版本回调
+     *
+     * @param resultCode  上报结果码；0：成功；其它：失败
+     * @param version  版本；
+     * @param resultMsg  上报结果码描述
+     */
+    void onReportFirmwareVersion(int resultCode, String version, String resultMsg);
+
+    /**
+    * OTA升级包下载进度回调
+    *
+    * @param percent  下载进度（0 ~ 100）;
+    * @param version  版本；
+    */
+    void onDownloadProgress(int percent, String version);
+
+    /**
+    * OTA升级包下载完成回调
+    * @param outputFile  已下载完成的升级包文件名（包含全路径）；
+    * @param version  版本；
+    */
+    void onDownloadCompleted(String outputFile, String version);
+
+    /**
+    * OTA升级包下载失败回调
+    *
+    * @param errCode  失败错误码; -1: 下载超时; -2:文件不存在；-3:签名过期；-4:校验错误；
+    * @param version  版本；
+    */
+    void onDownloadFailure(int errCode, String version);
+
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXMqttService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXMqttService.java	(date 1606400383057)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/interfaces/ITXMqttService.java	(date 1606400383057)
@@ -0,0 +1,142 @@
+// ITXMqttService.aidl
+package com.tencent.iot.hub.device.java.service.interfaces;
+
+import com.tencent.iot.hub.device.java.service.TXDisconnectedBufferOptions;
+import com.tencent.iot.hub.device.java.service.interfaces.ITXMqttActionListener;
+import com.tencent.iot.hub.device.java.service.interfaces.ITXOTAListener;
+import com.tencent.iot.hub.device.java.service.interfaces.ITXShadowActionListener;
+import com.tencent.iot.hub.device.java.service.TXMqttConnectOptions;
+import com.tencent.iot.hub.device.java.service.TXMqttClientOptions;
+import com.tencent.iot.hub.device.java.service.TXMqttMessage;
+
+import java.util.List;
+
+import com.tencent.iot.hub.device.java.core.shadow.DeviceProperty;
+
+public interface ITXMqttService {
+    /**
+     * 注册mqttAction监听器
+     */
+    void registerMqttActionListener( ITXMqttActionListener mqttActionListener);
+
+    /**
+     * 注册shadowAction监听器
+     */
+    void registerShadowActionListener( ITXShadowActionListener shadowActionListener);
+
+    /**
+     * 初始化设备信息
+     * @param clientOptions  客户端选项
+     */
+    void initDeviceInfo( TXMqttClientOptions clientOptions);
+
+    /**
+     * 设置断连状态buffer缓冲区
+     */
+    void setBufferOpts( TXDisconnectedBufferOptions bufferOptions);
+
+    /**
+     * 连接MQTT
+     * @param  options
+     * @param  userContextId
+     * @return status
+     */
+    String connect( TXMqttConnectOptions options,  long userContextId);
+
+    /**
+     * 重新连接
+     */
+    String reconnect();
+
+    /**
+     * MQTT断连
+     * @param timeout       等待时间（必须>0）。单位：毫秒
+     * @param userContextId 用户上下文
+     */
+    String disConnect( long timeout,  long userContextId);
+
+    /**
+     * 订阅主题
+     * @param topic
+     * @param qos
+     * @param userContextId
+     */
+    String subscribe( String topic,  int qos,  long userContextId);
+
+    /**
+     * 取消订阅主题
+     */
+    String unSubscribe( String topic,  long userContextId);
+
+    /**
+     * 发布主题
+     * @param topic
+     * @param message
+     * @param userContextId
+     */
+    String publish( String topic,  TXMqttMessage message,  long userContextId);
+
+    /**
+     * 获取连接状态
+     *
+     * @return 连接状态
+     */
+    String getConnectStatus();
+
+    /**
+     * 获取设备影子文档
+     */
+    String getShadow( long userContextId);
+
+    /**
+     * 更新设备影子文档
+     * @param devicePropertyList
+     * @param userContextId
+     */
+    String updateShadow(List<DeviceProperty> devicePropertyList,  long userContextId);
+
+    /**
+     * 注册设备属性
+     * @param deviceProperty
+     */
+    void registerDeviceProperty( DeviceProperty deviceProperty);
+
+    /**
+     * 取消注册设备属性
+     * @param deviceProperty
+     */
+    void unRegisterDeviceProperty( DeviceProperty deviceProperty);
+
+    /**
+     * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息
+     * @param reportJsonDoc 用户上报的JSON内容
+     */
+    String reportNullDesiredInfo(String reportJsonDoc);
+
+    /**
+     * 初始化OTA功能。
+     *
+     * @param storagePath OTA升级包存储路径(调用者必须确保路径已存在，并且具有写权限)
+     * @param listener    OTA事件回调
+     */
+    void initOTA(String storagePath,  ITXOTAListener listener);
+
+    /**
+     * 上报设备当前版本信息到后台服务器。
+     *
+     * @param currentFirmwareVersion 设备当前版本信息
+     * @return 发送成功时返回字符串"OK"; 其它返回值表示发送失败；
+     */
+    String reportCurrentFirmwareVersion(String currentFirmwareVersion);
+
+     /**
+     * 上报设备升级状态到后台服务器。
+     *
+     * @param state 状态
+     * @param resultCode 结果代码。0：表示成功；其它：表示失败；常见错误码：-1: 下载超时; -2:文件不存在；-3:签名过期；-4:校验错误；-5：更新固件失败
+     * @param resultMsg 结果描述
+     * @param version 版本号
+     * @return 发送成功时返回字符串"OK"; 其它返回值表示发送失败；
+     */
+    String reportOTAState(String state, int resultCode, String resultMsg, String version);
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXShadowClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXShadowClient.java	(date 1606400383055)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXShadowClient.java	(date 1606400383055)
@@ -0,0 +1,311 @@
+package com.tencent.iot.hub.device.java.service;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTACallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTAConstansts;
+import com.tencent.iot.hub.device.java.core.shadow.DeviceProperty;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowActionCallBack;
+import com.tencent.iot.hub.device.java.service.interfaces.ITXShadowActionListener;
+
+import java.util.List;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Shadow远程服务客户端
+ */
+public class TXShadowClient {
+
+    private static final String TAG = TXShadowClient.class.getSimpleName();
+    private static final Logger LOG = LoggerFactory.getLogger(TXShadowClient.class);
+    
+    /**
+     * mqtt客户端，ShadowClient所有功能均通过该成员变量进行
+     */
+    private TXMqttClient mMqttClient = null;
+
+    /**
+     * shadowAction监听器，用于跨进程调用
+     */
+    private ITXShadowActionListener mShadowActionListener = null;
+
+    /**
+     * shadowAction回调接口，用于外部回调
+     */
+    private TXShadowActionCallBack mShadowActionCallBack = null;
+
+    public TXShadowClient() {
+        this.mMqttClient = new TXMqttClient();
+    }
+
+    public TXShadowClient(TXMqttClient mMqttClient) {
+        this.mMqttClient = mMqttClient;
+    }
+
+    /**
+     * 设置ShadowAction回调接口
+     *
+     * @param mShadowActionCallBack shadowAction回调接口
+     * @return
+     */
+    public TXShadowClient setShadowActionCallBack(TXShadowActionCallBack mShadowActionCallBack) {
+        this.mShadowActionCallBack = mShadowActionCallBack;
+        return this;
+    }
+
+
+    /**
+     * 获取Mqtt客户端实例
+     *
+     * @return
+     */
+    public TXMqttClient getMqttClient() {
+        return mMqttClient;
+    }
+
+    /**
+     * 初始化远程服务客户端
+     *
+     * @param clientOptions 客户端选项
+     */
+    public void init(TXMqttClientOptions clientOptions) {
+        initListener();
+        mMqttClient.init(clientOptions, mShadowActionListener);
+    }
+
+
+    /**
+     * 设置断连状态buffer缓冲区
+     *
+     * @param bufferOpts
+     */
+    public void setBufferOpts(TXDisconnectedBufferOptions bufferOpts) {
+        mMqttClient.setBufferOpts(bufferOpts);
+    }
+
+    /**
+     * 与云端建立连接，结果通过回调函数通知
+     *
+     * @param connectOptions 连接参数
+     * @param userContext    用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status connect(TXMqttConnectOptions connectOptions, Object userContext) {
+        connectOptions.setUseShadow(true);
+        return mMqttClient.connect(connectOptions, userContext);
+    }
+
+    /**
+     * 断开连接请求，结果通过回调函数通知。
+     *
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status disConnect(Object userContext) {
+        return mMqttClient.disConnect(userContext);
+    }
+
+    /**
+     * 获取连接状态
+     *
+     * @return 连接状态
+     */
+    public TXMqttConstants.ConnectStatus getConnectStatus() {
+        TXMqttConstants.ConnectStatus status = TXMqttConstants.ConnectStatus.kDisconnected;
+        try {
+            String statusStr = mMqttClient.mRemoteServer.getConnectStatus();
+            status = Status.valueOf(TXMqttConstants.ConnectStatus.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[getConnectStatus] failed!", e);
+        }
+        return status;
+    }
+
+    /**
+     * 获取设备影子
+     */
+    public Status get(Object userContext) {
+        Status status = Status.ERROR;
+        try {
+            long requestId = mMqttClient.addUserContext(userContext);
+            String statusStr = mMqttClient.mRemoteServer.getShadow(requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[getShadow] failed!", e);
+        }
+        return status;
+    }
+
+    /**
+     * 更新设备属性信息，结果通过回调函数通知。
+     *
+     * @param devicePropertyList 需要更新的设备属性集
+     * @param userContext        用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status update(List<DeviceProperty> devicePropertyList, Object userContext) {
+        Status status = Status.ERROR;
+        try {
+            long requestId = mMqttClient.addUserContext(userContext);
+            String statusStr = mMqttClient.mRemoteServer.updateShadow(devicePropertyList, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[updateShadow] failed!", e);
+        }
+        return status;
+    }
+
+    /**
+     * 注册设备属性
+     *
+     * @param deviceProperty
+     */
+    public void registerProperty(DeviceProperty deviceProperty) {
+        try {
+            mMqttClient.mRemoteServer.registerDeviceProperty(deviceProperty);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[registerDeviceProperty] failed!", e);
+        }
+    }
+
+    /**
+     * 取消注册设备属性
+     *
+     * @param deviceProperty
+     */
+    public void unRegisterProperty(DeviceProperty deviceProperty) {
+        try {
+            mMqttClient.mRemoteServer.unRegisterDeviceProperty(deviceProperty);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[unRegisterDeviceProperty] failed!", e);
+        }
+    }
+
+    /**
+     * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息。
+     *
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportNullDesiredInfo() {
+        return reportNullDesiredInfo(null);
+    }
+
+    /**
+     * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息。
+     *
+     * @param reportJsonDoc 用户上报的JSON内容
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportNullDesiredInfo(String reportJsonDoc) {
+        Status status = Status.ERROR;
+        try {
+            String statusStr = mMqttClient.mRemoteServer.reportNullDesiredInfo(reportJsonDoc);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[reportNullDesiredInfo] failed!", e);
+        }
+        return status;
+    }
+
+    /**
+     * 释放资源
+     */
+    public void clear() {
+        mMqttClient.clear();
+    }
+
+    /**
+     * 初始化OTA功能。
+     *
+     * @param storagePath OTA升级包存储路径(调用者必确保路径已存在，并且具有写权限)
+     * @param callback    OTA事件回调
+     */
+    public void initOTA(String storagePath, TXOTACallBack callback) {
+
+        mMqttClient.initOTA(storagePath, callback);
+    }
+
+    /**
+     * 上报设备当前版本信息到后台服务器。
+     *
+     * @param currentFirmwareVersion 设备当前版本信息
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportCurrentFirmwareVersion(String currentFirmwareVersion)  {
+
+        return mMqttClient.reportCurrentFirmwareVersion(currentFirmwareVersion);
+    }
+
+    /**
+     * 上报设备升级状态到后台服务器。
+     *
+     * @param state
+     * @param resultCode
+     * @param resultMsg
+     * @param version
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportOTAState(TXOTAConstansts.ReportState state, int resultCode, String resultMsg, String version) {
+
+        return mMqttClient.reportOTAState(state, resultCode, resultMsg, version);
+    }
+
+    /**
+     * 初始化监听器
+     */
+    private void initListener() {
+        mShadowActionListener = new ITXShadowActionListener() {
+            public void onRequestCallback(String type, int result, String document)  {
+                LOG.debug("onRequestCallback, type[{}], result[{}], document[{}]", type, result, document);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onRequestCallback(type, result, document);
+                }
+            }
+
+            public void onDevicePropertyCallback(String propertyJSONDocument, List<DeviceProperty> devicePropertyList) {
+                LOG.debug("onDevicePropertyCallback, propertyJSONDocument[{}], devicePropertyList size[{}]",
+                        propertyJSONDocument, devicePropertyList.size());
+                for (DeviceProperty deviceProperty : devicePropertyList) {
+                    LOG.debug(deviceProperty.toString());
+                }
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onDevicePropertyCallback(propertyJSONDocument, devicePropertyList);
+                }
+            }
+
+            public void onPublishCompleted(String status, TXMqttToken token, long userContextId, String errMsg) {
+                LOG.debug("onPublishCompleted, status[{}], token[{}], errMsg[{}]", status, token, errMsg);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onPublishCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(),
+                            mMqttClient.getUserContext(Long.valueOf(userContextId)), errMsg);
+                }
+            }
+
+            public void onSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg)  {
+                LOG.debug("onSubscribeCompleted, status[{}], token[{}], errMsg[{}]", status, token, errMsg);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onSubscribeCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(),
+                            mMqttClient.getUserContext(Long.valueOf(userContextId)), errMsg);
+                }
+            }
+
+            public void onUnSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg)  {
+                LOG.debug("onUnSubscribeCompleted, status[{}], token[{}], errMsg[{}]", status, token, errMsg);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onUnSubscribeCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(),
+                            mMqttClient.getUserContext(Long.valueOf(userContextId)), errMsg);
+                }
+            }
+
+            public void onMessageReceived(String topic, TXMqttMessage message)  {
+            	LOG.debug("onMessageReceived, topic[{}], message[{}]", topic, message);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onMessageReceived(topic, message.transToMqttMessage());
+                }
+            }
+        };
+    }
+
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttMessage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttMessage.java	(date 1606400383053)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttMessage.java	(date 1606400383053)
@@ -0,0 +1,82 @@
+package com.tencent.iot.hub.device.java.service;
+
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+
+import java.util.Arrays;
+
+/**
+ * 该类负责序列化MqttMessage相关信息
+ */
+
+public class TXMqttMessage {
+    private byte[] mPayload;
+    private int mQos = 1;
+    private boolean mRetained = false;
+    private int mMessageId;
+
+    public TXMqttMessage() {
+        setPayload(new byte[]{});
+    }
+
+    public TXMqttMessage(MqttMessage mqttMessage) {
+        mPayload = mqttMessage.getPayload();
+        mQos = mqttMessage.getQos();
+        mRetained = mqttMessage.isRetained();
+        mMessageId = mqttMessage.getId();
+    }
+
+    public MqttMessage transToMqttMessage() {
+        MqttMessage mqttMessage = new MqttMessage();
+        mqttMessage.setQos(mQos);
+        mqttMessage.setPayload(mPayload);
+        mqttMessage.setId(mMessageId);
+        mqttMessage.setRetained(mRetained);
+        return mqttMessage;
+    }
+
+    public byte[] getPayload() {
+        return mPayload;
+    }
+
+    public TXMqttMessage setPayload(byte[] payload) {
+        this.mPayload = payload;
+        return this;
+    }
+
+    public int getQos() {
+        return mQos;
+    }
+
+    public TXMqttMessage setQos(int qos) {
+        this.mQos = qos;
+        return this;
+    }
+
+    public boolean isRetained() {
+        return mRetained;
+    }
+
+    public TXMqttMessage setRetained(boolean retained) {
+        this.mRetained = retained;
+        return this;
+    }
+
+    public int getMessageId() {
+        return mMessageId;
+    }
+
+    public TXMqttMessage setMessageId(int messageId) {
+        this.mMessageId = messageId;
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return "TXMqttMessage{" +
+                ", mPayload=" + Arrays.toString(mPayload) +
+                ", mQos=" + mQos +
+                ", mRetained=" + mRetained +
+                ", mMessageId=" + mMessageId +
+                '}';
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttClient.java	(date 1606400383052)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttClient.java	(date 1606400383052)
@@ -0,0 +1,482 @@
+package com.tencent.iot.hub.device.java.service;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTACallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTAConstansts;
+import com.tencent.iot.hub.device.java.main.scenarized.Door;
+import com.tencent.iot.hub.device.java.service.interfaces.ITXMqttActionListener;
+import com.tencent.iot.hub.device.java.service.interfaces.ITXMqttService;
+import com.tencent.iot.hub.device.java.service.interfaces.ITXOTAListener;
+import com.tencent.iot.hub.device.java.service.interfaces.ITXShadowActionListener;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * mqtt远程服务客户端
+ */
+
+public class TXMqttClient {
+
+    private static final String TAG = TXMqttClient.class.getSimpleName();
+    private static final Logger LOG = LoggerFactory.getLogger(TXMqttClient.class);
+
+    /**
+     * mqtt客户端选项
+     */
+    private TXMqttClientOptions mMqttClientOptions = null;
+
+
+    /**
+     * mqttAction监听器，用于跨进程调用
+     */
+    private ITXMqttActionListener mMqttActionListener = null;
+
+    /**
+     * mqttAction回调接口，用于外部回调
+     */
+    private TXMqttActionCallBack mMqttActionCallBack = null;
+
+    private AtomicLong mRequestId = null;
+
+    /**
+     * 因userContext在外部定义，sdk内部不便于实现序列化。
+     * 因此在客户端保存requestId与userContext的映射关系，在跨进程调用时通过requestId代替userContext进行传递。
+     */
+    private Map<Long, Object> mUserContextMap = null;
+
+    /**
+     * mqtt远程服务
+     */
+    protected ITXMqttService mRemoteServer = null;
+
+    private TXOTACallBack mOTACallback = null;
+
+    private ITXOTAListener mOTAListener = new ITXOTAListener() {
+        public void onReportFirmwareVersion(int resultCode, String version, String resultMsg) {
+            if (mOTACallback != null) {
+                mOTACallback.onReportFirmwareVersion(resultCode, version, resultMsg);
+            }
+        }
+
+        public void onDownloadProgress(int percent, String version){
+            if (mOTACallback != null) {
+                mOTACallback.onDownloadProgress(percent, version);
+            }
+        }
+
+        public void onDownloadCompleted(String outputFile, String version) {
+            if (mOTACallback != null) {
+                mOTACallback.onDownloadCompleted(outputFile, version);
+            }
+        }
+
+        public void onDownloadFailure(int errCode, String version) {
+            if (mOTACallback != null) {
+                mOTACallback.onDownloadFailure(errCode, version);
+            }
+        }
+    };
+
+    public TXMqttClient() {
+    }
+
+    /**
+     * 设置MqttAction回调接口
+     *
+     * @param mMqttActionCallBack mqttAction回调接口
+     * @return
+     */
+    public TXMqttClient setMqttActionCallBack(TXMqttActionCallBack mMqttActionCallBack) {
+        this.mMqttActionCallBack = mMqttActionCallBack;
+        return this;
+    }
+
+  
+    /**
+     * 初始化远程服务客户端
+     *
+     * @param clientOptions 客户端选项
+     */
+    public void init( TXMqttClientOptions clientOptions) {
+
+        internalInit(clientOptions);
+
+        try {
+             mRemoteServer.registerMqttActionListener(mMqttActionListener);
+             mRemoteServer.initDeviceInfo(mMqttClientOptions);
+          } catch (Exception e) {
+             LOG.error("{}", "invoke remote service failed!", e);
+          }
+            
+        
+    }
+
+    /**
+     * 初始化远程服务客户端（内部接口不对外，仅供TXShadowClient调用）
+     *
+     * @param clientOptions        客户端选项
+     * @param shadowActionListener shadowAction监听器
+     */
+    protected void init( TXMqttClientOptions clientOptions, final ITXShadowActionListener shadowActionListener) {
+
+        internalInit(clientOptions);
+        try {
+             mRemoteServer.registerMqttActionListener(mMqttActionListener);
+             mRemoteServer.registerShadowActionListener(shadowActionListener);
+             mRemoteServer.initDeviceInfo(mMqttClientOptions);
+
+        } catch (Exception e) {
+             LOG.error("{}", "invoke remote service failed!", e);
+        }
+
+    }
+
+
+    /**
+     * 设置断连状态buffer缓冲区
+     *
+     * @param bufferOpts
+     */
+    public void setBufferOpts(TXDisconnectedBufferOptions bufferOpts) {
+        if (null == bufferOpts) {
+            return;
+        }
+        try {
+            mRemoteServer.setBufferOpts(bufferOpts);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[setBufferOpts] failed!", e);
+        }
+    }
+
+    /**
+     * 连接MQTT服务器，结果通过回调函数通知。
+     *
+     * @param connectOptions 连接参数
+     * @param userContext    用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status connect(TXMqttConnectOptions connectOptions, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            LOG.error("{}", "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+
+        try {
+            String statusStr = mRemoteServer.connect(connectOptions, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[connect] failed!", e);
+        }
+
+        return status;
+    }
+
+    /**
+     * 重新连接, 结果通过回调函数通知。
+     *
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reconnect() {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            LOG.error("{}", "remote service is not start!");
+            return status;
+        }
+
+        try {
+            String statusStr = mRemoteServer.reconnect();
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[reconnect] failed!", e);
+        }
+
+        return status;
+    }
+
+    /**
+     * MQTT断连，结果通过回调函数通知。
+     *
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status disConnect(Object userContext) {
+        return disConnect(0, userContext);
+    }
+
+    /**
+     * MQTT断连, 结果通过回调函数通知。
+     *
+     * @param timeout     等待时间（必须大于0）。单位：毫秒
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status disConnect(long timeout, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            LOG.error("{}", "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        try {
+            String statusStr = mRemoteServer.disConnect(timeout, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[disConnect] failed!", e);
+        }
+        return status;
+    }
+
+    /**
+     * 订阅Topic, 结果通过回调函数通知。
+     *
+     * @param topic       topic名称
+     * @param qos         QOS等级
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status subscribe(String topic, int qos, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            LOG.error("{}", "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        try {
+            String statusStr = mRemoteServer.subscribe(topic, qos, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[subscribe] failed!", e);
+        }
+        return status;
+    }
+
+    /**
+     * 取消订阅主题, 结果通过回调函数通知。
+     *
+     * @param topic       要取消订阅的主题
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status unSubscribe(String topic, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            LOG.error("{}", "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        try {
+            String statusStr = mRemoteServer.unSubscribe(topic, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[unSubscribe] failed!", e);
+        }
+
+        return status;
+    }
+
+    /**
+     * 发布MQTT消息接口, 结果通过回调函数通知。
+     *
+     * @param topic       topic名称
+     * @param message     消息内容
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status publish(String topic, TXMqttMessage message, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            LOG.error("{}", "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        try {
+            String statusStr = mRemoteServer.publish(topic, message, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[publish] failed!", e);
+        }
+
+        return status;
+    }
+
+    /**
+     * 释放资源
+     */
+    public void clear() {
+        mUserContextMap.clear();
+    }
+
+
+    /**
+     * 初始化OTA功能。
+     *
+     * @param storagePath OTA升级包存储路径(调用者必须确保路径已存在，并且具有写权限)
+     * @param callback    OTA事件回调
+     */
+    public void initOTA(String storagePath, TXOTACallBack callback) {
+        mOTACallback = callback;
+
+        try {
+            mRemoteServer.initOTA(storagePath, mOTAListener);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[initOTA] failed!", e);
+        }
+    }
+
+    /**
+     * 上报设备当前版本信息到后台服务器。
+     *
+     * @param currentFirmwareVersion 设备当前版本信息
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportCurrentFirmwareVersion(String currentFirmwareVersion)  {
+        Status status = Status.ERROR;
+
+        try {
+            String statusStr = mRemoteServer.reportCurrentFirmwareVersion(currentFirmwareVersion);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[reportCurrentFirmwareVersion] failed!", e);
+        }
+
+        return status;
+    }
+
+    /**
+     * 上报设备升级状态到后台服务器。
+     *
+     * @param state 状态
+     * @param resultCode 结果代码。0：表示成功；其它：表示失败；常见错误码：-1:下载超时; -2:文件不存在；-3:签名过期；-4:校验错误；-5:更新固件失败
+     * @param resultMsg 结果描述
+     * @param version 版本号
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportOTAState(TXOTAConstansts.ReportState state, int resultCode, String resultMsg, String version) {
+        Status status = Status.ERROR;
+
+        try {
+            String statusStr = mRemoteServer.reportOTAState(state.name(), resultCode, resultMsg, version);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (Exception e) {
+            LOG.error("{}", "invoke remote service[reportOTAState] failed!", e);
+        }
+
+        return status;
+    }
+
+    /**
+     * 添加用户上下文
+     *
+     * @param userContext
+     * @return
+     */
+    protected long addUserContext(Object userContext) {
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        return requestId;
+    }
+
+    /**
+     * 获取用户上下文
+     *
+     * @param userContextId
+     * @return
+     */
+    protected Object getUserContext(long userContextId) {
+        return mUserContextMap.get(userContextId);
+    }
+
+    /**
+     * 内部初始化
+     */
+    private void internalInit(TXMqttClientOptions clientOptions) {
+     
+        mMqttClientOptions = clientOptions;
+        mUserContextMap = new HashMap<Long, Object>();
+        mRequestId = new AtomicLong(0);
+
+        mMqttActionListener = new ITXMqttActionListener() {
+
+            public void onConnectCompleted(String status, boolean reconnect, long userContextId, String msg) {
+                LOG.debug("onConnectCompleted, status[{}], reconnect[{}], msg[{}]", status, reconnect, msg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onConnectCompleted(Status.valueOf(Status.class, status),
+                            reconnect, userContext, msg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            public void onConnectionLost(String cause)  {
+                LOG.debug("onConnectionLost, cause[{}]", cause);
+                if (null != mMqttActionCallBack) {
+                    mMqttActionCallBack.onConnectionLost(new Throwable(cause));
+                }
+            }
+
+            public void onDisconnectCompleted(String status, long userContextId, String msg) {
+                LOG.debug("onDisconnectCompleted, status[{}], msg[{}]", status, msg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onDisconnectCompleted(Status.valueOf(Status.class, status), userContext, msg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            public void onPublishCompleted(String status, TXMqttToken token, long userContextId, String errMsg) {
+                LOG.debug("onPublishCompleted, status[{}], token[{}], errMsg[{}]", status, token, errMsg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onPublishCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(), userContext, errMsg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            public void onSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg) {
+                LOG.debug("onSubscribeCompleted, status[{}], token[{}], errMsg[{}]", status, token, errMsg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onSubscribeCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(), userContext, errMsg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            public void onUnSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg) {
+                LOG.debug("onUnSubscribeCompleted, status[{}], token[{}], errMsg[{}]", status, token, errMsg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onUnSubscribeCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(), userContext, errMsg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            public void onMessageReceived(String topic, TXMqttMessage message) {
+                LOG.debug("onMessageReceived, topic[{}], message[{}]", topic, message);
+                if (null != mMqttActionCallBack) {
+                    mMqttActionCallBack.onMessageReceived(topic, message.transToMqttMessage());
+                }
+            }
+
+            public void onServiceStartedCallback(){
+
+            }
+
+            public void onServiceDestroyCallback(){
+                LOG.debug("onServiceDestroyCallback");
+            }
+        };
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttToken.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttToken.java	(date 1606400383054)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttToken.java	(date 1606400383054)
@@ -0,0 +1,62 @@
+package com.tencent.iot.hub.device.java.service;
+
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttToken;
+
+import java.util.Arrays;
+
+/**
+ * 该类负责序列化MqttToken相关信息
+ */
+
+public class TXMqttToken {
+
+    private String[] mTopics = null;
+    private volatile boolean mCompleted = false;
+    private int mMessageID = 0;
+    private int[] mGrantedQos = null;
+    private boolean mSessionPresent = false;
+
+    public TXMqttToken() {
+    }
+
+    public TXMqttToken(String[] topics, boolean mCompleted, int mMessageID, int[] mGrantedQos, boolean mSessionPresent) {
+        this.mTopics = topics;
+        this.mCompleted = mCompleted;
+        this.mMessageID = mMessageID;
+        this.mGrantedQos = mGrantedQos;
+        this.mSessionPresent = mSessionPresent;
+    }
+
+    public TXMqttToken(IMqttToken mqttToken) {
+        if (null != mqttToken.getTopics() && mqttToken.getTopics().length > 0) {
+            mTopics = new String[mqttToken.getTopics().length];
+            System.arraycopy(mqttToken.getTopics(), 0, mTopics, 0, mqttToken.getTopics().length);
+        }
+        mCompleted = mqttToken.isComplete();
+        mMessageID = mqttToken.getMessageId();
+        if (null != mqttToken.getGrantedQos() && mqttToken.getGrantedQos().length > 0) {
+            mGrantedQos = new int[mqttToken.getGrantedQos().length];
+            System.arraycopy(mqttToken.getGrantedQos(), 0, mGrantedQos, 0, mqttToken.getGrantedQos().length);
+        }
+        mSessionPresent = mqttToken.getSessionPresent();
+    }
+
+    public MqttToken transToMqttToken() {
+        MqttToken mqttToken = new MqttToken("TXMqttToken");
+        mqttToken.internalTok.setTopics(mTopics);
+        mqttToken.internalTok.setMessageID(mMessageID);
+        return mqttToken;
+    }
+
+    @Override
+    public String toString() {
+        return "TXMqttToken{" +
+                "mTopics=" + Arrays.toString(mTopics) +
+                ", mCompleted=" + mCompleted +
+                ", mMessageID=" + mMessageID +
+                ", mGrantedQos=" + Arrays.toString(mGrantedQos) +
+                ", mSessionPresent=" + mSessionPresent +
+                '}';
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/App.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/App.java	(date 1606843458217)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/App.java	(date 1606843458217)
@@ -0,0 +1,317 @@
+package com.tencent.iot.hub.device.java;
+
+import java.io.ByteArrayInputStream;
+import java.util.Arrays;
+
+import org.apache.log4j.LogManager;
+import org.apache.log4j.PropertyConfigurator;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttException;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTACallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXWebSocketActionCallback;
+import com.tencent.iot.hub.device.java.core.mqtt.TXWebSocketManager;
+import com.tencent.iot.hub.device.java.core.util.AsymcSslUtils;
+
+import javax.net.SocketFactory;
+
+/**
+ * Hello world!
+ *
+ */
+public class App {
+
+	private static final Logger LOG = LoggerFactory.getLogger(App.class);
+
+	private static String path2Store = System.getProperty("user.dir");
+
+	private static String mBrokerURL = null;  //传入null，即使用腾讯云物联网通信默认地址 "${ProductId}.iotcloud.tencentdevices.com:8883"  https://cloud.tencent.com/document/product/634/32546
+
+	private static final String GW_OPERATION_RES_PREFIX = "$gateway/operation/result/";
+
+	private static String mProductID = "YOUR_PRODUCT_ID";
+	private static String mDevName = "YOUR_DEVICE_NAME";
+	private static String mDevPSK = "YOUR_DEV_PSK";
+	private static String mSubProductID = "YOUR_SUB_PRODUCT_ID";
+	private static String mSubDevName = "YOUR_SUB_DEV_NAME";
+	private static String mSubDevProductKey = "YOUR_SUB_DEV_PSK";
+	private static String mTestTopic = "YOUR_TEST_TOPIC";
+	private static String mCertFilePath = null;
+	private static String mPrivKeyFilePath = null;
+	private static JSONObject jsonObject = new JSONObject();
+	private static int pubCount = 0;
+	private static final int testCnt = 1000;
+
+	private static TXMqttConnection mqttconnection;
+	private static MqttConnectOptions options;
+	//	private static final TEST = "{\"action\":\"come_home\",\"targetDevice\":\""+mDevName +"  \"}";
+	
+	private static void dbgPrint(String s) {
+		System.out.println(s);
+	}
+	
+	
+	public static void main(String[] args) {
+//		websocketConnect();
+//		websocketdisconnect();
+		LogManager.resetConfiguration();
+		LOG.isDebugEnabled();
+		PropertyConfigurator.configure(App.class.getResource("/log4j.properties"));
+
+		//MQTTSample mMQTTSample = new MQTTSample(new SelfMqttActionCallBack(), mBrokerURL, mProductID, mDevName, mDevPSK,
+			//	mSubProductID, mSubDevName, mTestTopic);
+		dbgPrint("mqttSample created\n");
+
+		String workDir = System.getProperty("user.dir") + "/";
+
+
+		//mMQTTSample.connect();
+
+//		dbgPrint("mqttSample connected!");
+//
+//		try {
+//			Thread.sleep(5000);
+//		} catch (InterruptedException e1) {
+//			// TODO Auto-generated catch block
+//			e1.printStackTrace();
+//		}
+//
+//		mMQTTSample.subscribeTopic(mTestTopic);
+//
+//		mMQTTSample.setSubdevOnline();
+		try {
+			jsonObject.put("tenant_id", "test");
+			jsonObject.put("hubId", "test");
+			JSONObject jsonObject2 = new JSONObject();
+			jsonObject2.put("serial", "test");
+			jsonObject2.put("hubId", "test");
+			jsonObject2.put("deviceType", "test");
+			jsonObject2.put("deviceId", "test");
+			jsonObject2.put("data", "data");
+			jsonObject.put("data", jsonObject2);
+		} catch (JSONException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+
+
+//		mMQTTSample.publishTopic("", jsonObject);
+//		mMQTTSample.publishTopic("", jsonObject);
+		System.out.println("qqqqqqeeeeeeqqqqqq");
+		options = new MqttConnectOptions();
+		options.setConnectionTimeout(8);
+		options.setKeepAliveInterval(60);
+		options.setAutomaticReconnect(true);
+		//客户端证书文件名  mDevPSK是设备秘钥
+
+		if (mDevPSK != null) {
+			options.setSocketFactory(AsymcSslUtils.getSocketFactory());
+		} else {
+			options.setSocketFactory(AsymcSslUtils.getSocketFactoryByFile(workDir + mCertFilePath, workDir + mPrivKeyFilePath));
+		}
+		mqttconnection = new TXMqttConnection(mProductID, mDevName, mDevPSK, new callBack());
+		mqttconnection.setSubDevName(mSubDevName);
+		mqttconnection.setSubDevProductKey(mSubDevProductKey);
+		mqttconnection.setSubProductID(mSubProductID);
+		mqttconnection.connect(options, null);
+		try {
+			while(pubCount < testCnt) {
+				Thread.sleep(20000);
+			}
+		} catch (InterruptedException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		mqttconnection.disConnect(null);
+	}
+
+	private static void websocketdisconnect() {
+		try {
+			TXWebSocketManager.getInstance().getClient(mProductID, mDevName).disconnect();
+		} catch (MqttException e) {
+			e.printStackTrace();
+		}
+	}
+
+	private static void websocketConnect() {
+
+		SocketFactory socketFactory = null;
+		if (mDevPSK != null) {
+			socketFactory = AsymcSslUtils.getSocketFactory();
+		} else {
+			String workDir = System.getProperty("user.dir") + "/";
+			socketFactory = AsymcSslUtils.getSocketFactoryByFile(workDir + mCertFilePath, workDir + mPrivKeyFilePath);
+		}
+
+		TXWebSocketManager.getInstance().getClient(mProductID, mDevName).setSecretKey(mDevPSK, socketFactory);
+		try {
+			TXWebSocketManager.getInstance().getClient(mProductID, mDevName).setTXWebSocketActionCallback(new TXWebSocketActionCallback() {
+
+				@Override
+				public void onConnected() {
+					System.out.println("onConnected " + TXWebSocketManager.getInstance().getClient(mProductID, mDevName).getConnectionState());
+				}
+
+				@Override
+				public void onMessageArrived(String topic, MqttMessage message) {
+					System.out.println("onMessageArrived topic=" + topic);
+				}
+
+				@Override
+				public void onConnectionLost(Throwable cause) {
+					System.out.println("onConnectionLost" + TXWebSocketManager.getInstance().getClient(mProductID, mDevName).getConnectionState());
+				}
+
+				@Override
+				public void onDisconnected() {
+					System.out.println("onDisconnected" + TXWebSocketManager.getInstance().getClient(mProductID, mDevName).getConnectionState());
+				}
+			});
+			TXWebSocketManager.getInstance().getClient(mProductID, mDevName).connect();
+		} catch (MqttException e) {
+			e.printStackTrace();
+			System.out.println("MqttException " + e.toString());
+		}
+	}
+
+	public static class callBack extends TXMqttActionCallBack {
+
+		@Override
+		public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {
+			// TODO Auto-generated method stub
+			String topic = String.format("%s/%s/%s", mProductID, mDevName,"data");
+			System.out.println("ffffffffffff status " + status.toString());
+			System.out.println("ffffffffffff msg " + msg);
+			mqttconnection.subscribe(topic, 1, null);
+
+			// 订阅网关操作的结果
+			String gwTopic = GW_OPERATION_RES_PREFIX + mProductID + "/" + mDevName;
+			mqttconnection.subscribe(gwTopic, 1, "Subscribe GATEWAY result topic");
+
+			// 关注远程配置的回调
+			mqttconnection.concernConfig();
+
+			// 查询网关的拓扑关系
+			mqttconnection.gatewayGetSubdevRelation();
+			mqttconnection.getRemoteConfig();
+			System.out.println("path2Store=" + path2Store);
+			mqttconnection.initOTA(path2Store, oTACallBack);
+		}
+
+		private TXOTACallBack oTACallBack = new TXOTACallBack() {
+
+			@Override
+			public void onReportFirmwareVersion(int resultCode, String version, String resultMsg) {
+
+			}
+
+			@Override
+			public boolean onLastestFirmwareReady(String url, String md5, String version) {
+				System.out.println("onLastestFirmwareReady url=" + url + " version " + version);
+				mqttconnection.gatewayDownSubdevApp(url, path2Store + "/" + md5, md5, version);
+				return true; // false 自动触发下载升级文件  true 需要手动触发下载升级文件
+			}
+
+			@Override
+			public void onDownloadProgress(int percent, String version) {
+				mqttconnection.gatewaySubdevReportProgress(percent, version);
+			}
+
+			@Override
+			public void onDownloadCompleted(String outputFile, String version) {
+				mqttconnection.gatewaySubdevReportStart(version);
+				mqttconnection.gatewaySubdevReportSuccess(version);
+			}
+
+			@Override
+			public void onDownloadFailure(int errCode, String version) {
+				mqttconnection.gatewaySubdevReportFail(errCode, "", version);
+			}
+		};
+
+		@Override
+		public void onConnectionLost(Throwable cause) {
+			// TODO Auto-generated method stub
+			LOG.info("onConnectionLost1111111111111111111111");
+
+		}
+
+		@Override
+		public void onDisconnectCompleted(Status status, Object userContext, String msg) {
+			// TODO Auto-generated method stub
+			LOG.info("onDisconnectCompleted111111111111111");
+		}
+		
+		@Override
+		public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
+            String logInfo = String.format("onPublishCompleted, status[%s], topics[%s],   errMsg[%s]",
+                    status.name(), Arrays.toString(token.getTopics()),  errMsg);
+            dbgPrint(logInfo);
+        }
+
+        @Override
+        public void onSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+            String userContextInfo = "";
+
+            String logInfo = String.format("onSubscribeCompleted, status[%s], topics[%s], userContext[%s], errMsg[%s]",
+                    status.name(), Arrays.toString(asyncActionToken.getTopics()), userContextInfo, errMsg);
+            dbgPrint(logInfo);
+            
+			MqttMessage message = new MqttMessage();
+			// 这里添加获取到的数据
+			message.setPayload(jsonObject.toString().getBytes());
+			message.setQos(1);
+			String topic = String.format("%s/%s/%s", mProductID, mDevName,"data");
+
+			if(mqttconnection != null) {
+//				mqttconnection.publish(topic, message, null);
+				System.out.println("000000000000000000000000000");
+//				mqttconnection.gatewayBindSubdev(mSubProductID, mSubDevName, mSubDevProductKey);
+//				mqttconnection.gatewayUnbindSubdev(mSubProductID, mSubDevName);
+
+
+				for (String topicEls : asyncActionToken.getTopics()) {
+					if (topicEls.startsWith("$ota/update/")) {
+						mqttconnection.gatewaySubdevReportVer("0.0");
+					}
+				}
+
+			}
+        }
+        
+        @Override
+        public void onMessageReceived(final String topic, final MqttMessage message) {
+            String logInfo = String.format("receive message, topic[%s], message[%s]", topic, message.toString());
+            dbgPrint(logInfo);
+			MqttMessage msg = new MqttMessage();
+			pubCount += 1;
+			
+			try {
+				Thread.sleep(20000);
+			} catch (InterruptedException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+			if (pubCount > testCnt) {
+				return;
+			}
+
+			// 这里添加获取到的数据
+			msg.setPayload(jsonObject.toString().getBytes());
+			msg.setQos(1);
+
+			if(mqttconnection != null) {
+				mqttconnection.publish(topic, message, null);
+			}
+        }
+	}
+}
Index: iot_service/bintray.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/bintray.gradle	(date 1606400383025)
+++ iot_service/bintray.gradle	(date 1606400383025)
@@ -0,0 +1,138 @@
+group = PROJ_GROUP
+version = PROJ_VERSION
+project.archivesBaseName = PROJ_ARTIFACTID
+
+apply plugin: 'com.jfrog.bintray'
+apply plugin: "com.jfrog.artifactory"
+apply plugin: 'maven-publish'
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.sourceFiles
+    classifier = 'sources'
+}
+
+task javadoc(type: Javadoc) {
+    options.charSet = 'UTF-8'
+    options.encoding = "UTF-8"
+    source = android.sourceSets.main.java.srcDirs
+    classpath += configurations.compile
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+}
+
+task javadocJar(type: Jar, dependsOn: javadoc) {
+    classifier = 'javadoc'
+    from javadoc.destinationDir
+}
+
+task androidJniSymbolsJar(type: Jar) {
+    classifier = 'symbols'
+    from file('obj/local/')
+    include '**/*.so'
+}
+
+javadoc {
+    options {
+        encoding "UTF-8"
+        charSet 'UTF-8'
+        author true
+        version true
+        links "http://docs.oracle.com/javase/7/docs/api"
+        title "$PROJ_NAME $PROJ_VERSION"
+    }
+
+    exclude "**/*.aidl"
+}
+
+
+def pomConfig = {
+    licenses {
+        license {
+            name "MIT License"
+            url "http://opensource.org/licenses/MIT"
+            distribution "repo"
+        }
+    }
+    developers {
+        developer {
+            id DEVELOPER_ID
+            name DEVELOPER_NAME
+            email DEVELOPER_EMAIL
+        }
+    }
+}
+
+publishing {
+    publications {
+        mavenJava(MavenPublication) {
+            artifactId PROJ_ARTIFACTID
+            artifact javadocJar
+            artifact sourcesJar
+            artifact androidJniSymbolsJar
+
+            pom.withXml {
+                def root = asNode()
+                root.appendNode('description', PROJ_DESCRIPTION)
+                root.children().last() + pomConfig
+
+                def dependenciesNode = root.appendNode('dependencies')
+                configurations.compile.allDependencies.each {
+                    if (it.group && it.name && it.version) {
+                        def dependencyNode = dependenciesNode.appendNode('dependency')
+                        dependencyNode.appendNode('groupId', it.group)
+                        dependencyNode.appendNode('artifactId', it.name)
+                        dependencyNode.appendNode('version', it.version)
+                    }
+                }
+            }
+        }
+    }
+}
+
+afterEvaluate {
+    publishing.publications.mavenJava.artifact(bundleReleaseAar)
+}
+
+bintray {
+    Properties properties = new Properties()
+    if (rootProject.file("local.properties").exists()) {
+        properties.load(project.rootProject.file('local.properties').newDataInputStream())
+        user = properties.getProperty("bintray.user")
+        key = properties.getProperty("bintray.apikey")
+    }
+
+    publications = ['mavenJava']
+    publish = true
+
+    pkg {
+        repo = 'iot'
+        userOrg = 'qcloudplatform145'
+        name = PROJ_NAME
+        desc = PROJ_DESCRIPTION
+        websiteUrl = PROJ_WEBSITEURL
+        issueTrackerUrl = PROJ_ISSUETRACKERURL
+        vcsUrl = PROJ_VCSURL
+        licenses = ['MIT']
+        publicDownloadNumbers = true
+    }
+}
+
+artifactory {
+    contextUrl = 'http://oss.jfrog.org/artifactory'
+    resolve {
+        repository {
+            repoKey = 'libs-release'
+        }
+    }
+    publish {
+        repository {
+            repoKey = 'oss-snapshot-local' //The Artifactory repository key to publish to
+            username = bintray.user
+            password = bintray.key
+        }
+        defaults {
+            //这里的名字和上面红色的名字一致即可，会将其包含的输出上传到jfrog上去
+            publications('mavenJava')
+            publishArtifacts = true
+        }
+    }
+}
\ No newline at end of file
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXDisconnectedBufferOptions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXDisconnectedBufferOptions.java	(date 1606400383052)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXDisconnectedBufferOptions.java	(date 1606400383052)
@@ -0,0 +1,79 @@
+package com.tencent.iot.hub.device.java.service;
+
+
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+
+/**
+ * 该类负责序列化DisconnectedBufferOptions相关信息
+ */
+
+public class TXDisconnectedBufferOptions extends DisconnectedBufferOptions{
+    private int bufferSize = DISCONNECTED_BUFFER_SIZE_DEFAULT;
+    private boolean bufferEnabled = DISCONNECTED_BUFFER_ENABLED_DEFAULT;
+    private boolean persistBuffer = PERSIST_DISCONNECTED_BUFFER_DEFAULT;
+    private boolean deleteOldestMessages = DELETE_OLDEST_MESSAGES_DEFAULT;
+
+    public TXDisconnectedBufferOptions() {
+        super();
+    }
+
+    /**
+     * 转换为DisconnectedBufferOptions
+     *
+     * @return
+     */
+    public DisconnectedBufferOptions transToDisconnectedBufferOptions() {
+        DisconnectedBufferOptions disconnectedBufferOptions = new DisconnectedBufferOptions();
+        disconnectedBufferOptions.setBufferSize(bufferSize);
+        disconnectedBufferOptions.setBufferEnabled(bufferEnabled);
+        disconnectedBufferOptions.setPersistBuffer(persistBuffer);
+        disconnectedBufferOptions.setDeleteOldestMessages(deleteOldestMessages);
+        return disconnectedBufferOptions;
+    }
+
+    public int getBufferSize() {
+        return bufferSize;
+    }
+
+    public void setBufferSize(int bufferSize) {
+        if (bufferSize < 1) {
+            throw new IllegalArgumentException();
+        }
+        this.bufferSize = bufferSize;
+    }
+
+    public boolean isBufferEnabled() {
+        return bufferEnabled;
+    }
+
+    public void setBufferEnabled(boolean bufferEnabled) {
+        this.bufferEnabled = bufferEnabled;
+    }
+
+    public boolean isPersistBuffer() {
+        return persistBuffer;
+    }
+
+    public void setPersistBuffer(boolean persistBuffer) {
+        this.persistBuffer = persistBuffer;
+    }
+
+    public boolean isDeleteOldestMessages() {
+        return deleteOldestMessages;
+    }
+
+    public void setDeleteOldestMessages(boolean deleteOldestMessages) {
+        this.deleteOldestMessages = deleteOldestMessages;
+    }
+
+    @Override
+    public String toString() {
+        return "TXDisconnectedBufferOptions{" +
+                "bufferSize=" + bufferSize +
+                ", bufferEnabled=" + bufferEnabled +
+                ", persistBuffer=" + persistBuffer +
+                ", deleteOldestMessages=" + deleteOldestMessages +
+                '}';
+    }
+}
Index: iot_service/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/build.gradle	(date 1606841485773)
+++ iot_service/build.gradle	(date 1606841485773)
@@ -0,0 +1,158 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven-publish'
+apply plugin: 'signing'
+
+
+android {
+    compileSdkVersion 26
+    buildToolsVersion "26.0.3"
+
+    defaultConfig {
+        minSdkVersion 16
+        targetSdkVersion 29
+        versionCode 2
+        versionName "1.1"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+
+    sourceSets {
+        main {
+            java {
+                srcDirs = ["src/main/java", "src/main/aidl"]
+            }
+            jni {
+                srcDir "src/main/jni"
+            }
+        }
+    }
+    lintOptions {
+        abortOnError false
+    }
+}
+
+task androidJavadocs(type: Javadoc) {
+    failOnError false
+    source = android.sourceSets.main.java.srcDirs
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+    android.libraryVariants.all { variant ->
+        if (variant.name == 'release') {
+            owner.classpath += variant.javaCompile.classpath
+        }
+    }
+    exclude '**/R.html', '**/R.*.html', '**/index.html'
+}
+
+task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+    classifier = 'javadoc'
+    from androidJavadocs.destinationDir
+}
+
+task androidSourcesJar(type: Jar) {
+    classifier = 'sources'
+    from android.sourceSets.main.java.srcDirs
+}
+
+def libVersion = '3.2.1-SNAPSHOT'
+ext.isReleaseVersion = !libVersion.endsWith("SNAPSHOT")
+publishing {
+    publications {
+        aar(MavenPublication) {
+            groupId 'com.tencent.iot.hub'
+            artifactId 'hub-device-android-service'
+            version libVersion
+            artifact(androidSourcesJar)
+            artifact(androidJavadocsJar)
+            artifact file('build/outputs/aar/iot_service-release.aar')
+
+            pom {
+                name = 'hub device android service'
+                description = 'Hub Device Android Service library'
+                url = 'https://github.com/tencentyun/iot-device-java/tree/master/hub-device-android'
+                licenses {
+                    license {
+                        name = 'Tencent Binary License'
+                        url = 'https://github.com/tencentyun/iot-device-java/blob/master/hub-device-android/LICENSE'
+                    }
+                }
+                developers {
+                    developer {
+                        id = 'tencent_archurtan'
+                        name = 'Tencent archurtan'
+                        email = 'archurtan@tencent.com'
+                    }
+                }
+                scm {
+                    url = 'scm:git@github.com:tencentyun/iot-device-java.git'
+                    connection = 'scm:git@github.com:tencentyun/iot-device-java.git'
+                    developerConnection = 'scm:git@github.com:tencentyun/iot-device-java.git'
+                }
+            }
+
+            pom.withXml {
+                def dependenciesNode = asNode().appendNode('dependencies')
+                configurations.implementation.allDependencies.withType(ModuleDependency) { ModuleDependency dp ->
+                    if (dp.version != "unspecified") {
+                        def dependencyNode = dependenciesNode.appendNode('dependency')
+                        dependencyNode.appendNode('groupId', dp.group)
+                        dependencyNode.appendNode('artifactId', dp.name)
+                        dependencyNode.appendNode('version', dp.version)
+
+                        // for exclusions
+                        if (dp.excludeRules.size() > 0) {
+                            def exclusions = dependencyNode.appendNode('exclusions')
+                            dp.excludeRules.each { ExcludeRule ex ->
+                                def exclusion = exclusions.appendNode('exclusion')
+                                exclusion.appendNode('groupId', ex.group)
+                                exclusion.appendNode('artifactId', ex.module)
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    repositories {
+        maven {
+            def releasesRepoUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2"
+            def snapshotsRepoUrl = "https://oss.sonatype.org/content/repositories/snapshots"
+            url = libVersion.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
+            credentials {
+                username = System.getenv("IOT_SONATYPE_USERNAME")
+                password = System.getenv("IOT_SONATYPE_PASSWORD")
+            }
+        }
+    }
+}
+
+dependencies {
+    implementation fileTree(include: ['*.jar'], dir: 'libs')
+    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+        exclude group: 'com.android.support', module: 'support-annotations'
+    })
+    //noinspection GradleCompatible
+    implementation 'com.android.support:appcompat-v7:26.1.0'
+    implementation "org.eclipse.paho:org.eclipse.paho.client.mqttv3"
+    testImplementation 'junit:junit:4.13'
+
+    if (findProject(':hub-device-android') != null) {
+        implementation project(path: ':hub-device-android:iot_core')
+        implementation project(path: ':hub-device-java')
+    } else {
+        implementation 'com.tencent.iot.hub:hub-device-android-core:3.2.0'
+        implementation 'com.tencent.iot.hub:hub-device-java:1.0.0'
+    }
+}
+
+signing {
+    if (isReleaseVersion) {
+        sign publishing.publications.aar
+    }
+}
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttConnectOptions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttConnectOptions.java	(date 1606400383053)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttConnectOptions.java	(date 1606400383053)
@@ -0,0 +1,136 @@
+package com.tencent.iot.hub.device.java.service;
+
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+
+/**
+ * 该类负责序列化MqttConnectOptions相关信息
+ */
+
+public class TXMqttConnectOptions {
+
+    private int mConnectionTimeout = MqttConnectOptions.CONNECTION_TIMEOUT_DEFAULT;
+    private int mKeepAliveInterval = MqttConnectOptions.KEEP_ALIVE_INTERVAL_DEFAULT;
+    private boolean mAutomaticReconnect = false;
+    private boolean mCleanSession = MqttConnectOptions.CLEAN_SESSION_DEFAULT;
+
+    /**
+     * 是否使用shadow
+     */
+    private boolean mUseShadow = false;
+
+    /**
+     * 是否采用非对称加密
+     */
+    private boolean mAsymcEncryption = true;
+
+    /**
+     * 设备证书名
+     */
+    private String mDeviceCertName;
+
+    /**
+     * 设备私钥文件名
+     */
+    private String mDeviceKeyName;
+
+    /**
+     * 设备密码
+     */
+    private String mSecretKey;
+
+    public TXMqttConnectOptions() {
+    }
+
+    public TXMqttConnectOptions(int mConnectionTimeout, int mKeepAliveInterval, boolean mAutomaticReconnect, boolean mCleanSession,
+                                boolean mAsymcEncryption, String mDeviceCertName, String mDeviceKeyName, String mSecretKey) {
+        this.mConnectionTimeout = mConnectionTimeout;
+        this.mKeepAliveInterval = mKeepAliveInterval;
+        this.mAutomaticReconnect = mAutomaticReconnect;
+        this.mCleanSession = mCleanSession;
+        this.mAsymcEncryption = mAsymcEncryption;
+        this.mDeviceCertName = mDeviceCertName;
+        this.mDeviceKeyName = mDeviceKeyName;
+        this.mSecretKey = mSecretKey;
+    }
+
+    public int getConnectionTimeout() {
+        return mConnectionTimeout;
+    }
+
+    public TXMqttConnectOptions setConnectionTimeout(int mConnectionTimeout) {
+        this.mConnectionTimeout = mConnectionTimeout;
+        return this;
+    }
+
+    public int getKeepAliveInterval() {
+        return mKeepAliveInterval;
+    }
+
+    public TXMqttConnectOptions setKeepAliveInterval(int mKeepAliveInterval) {
+        this.mKeepAliveInterval = mKeepAliveInterval;
+        return this;
+    }
+
+    public boolean isAutomaticReconnect() {
+        return mAutomaticReconnect;
+    }
+
+    public TXMqttConnectOptions setAutomaticReconnect(boolean mAutomaticReconnect) {
+        this.mAutomaticReconnect = mAutomaticReconnect;
+        return this;
+    }
+
+    public boolean isCleanSession() {
+        return mCleanSession;
+    }
+
+    public TXMqttConnectOptions setCleanSession(boolean mCleanSession) {
+        this.mCleanSession = mCleanSession;
+        return this;
+    }
+
+    public boolean isAsymcEncryption() {
+        return mAsymcEncryption;
+    }
+
+    public TXMqttConnectOptions setAsymcEncryption(boolean mAsymcEncryption) {
+        this.mAsymcEncryption = mAsymcEncryption;
+        return this;
+    }
+
+    public String getDeviceCertName() {
+        return mDeviceCertName;
+    }
+
+    public TXMqttConnectOptions setDeviceCertName(String mDeviceCertName) {
+        this.mDeviceCertName = mDeviceCertName;
+        return this;
+    }
+
+    public String getDeviceKeyName() {
+        return mDeviceKeyName;
+    }
+
+    public TXMqttConnectOptions setDeviceKeyName(String mDeviceKeyName) {
+        this.mDeviceKeyName = mDeviceKeyName;
+        return this;
+    }
+
+    public String getSecretKey() {
+        return mSecretKey;
+    }
+
+    public TXMqttConnectOptions setSecretKey(String secretKey) {
+        this.mSecretKey = secretKey;
+        return this;
+    }
+
+    protected boolean isUseShadow() {
+        return mUseShadow;
+    }
+
+    protected TXMqttConnectOptions setUseShadow(boolean mUseShadow) {
+        this.mUseShadow = mUseShadow;
+        return this;
+    }
+}
Index: iot_service/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/.gitignore	(date 1606400383025)
+++ iot_service/.gitignore	(date 1606400383025)
@@ -0,0 +1,1 @@
+/build
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttClientOptions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttClientOptions.java	(date 1606400383053)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/service/TXMqttClientOptions.java	(date 1606400383053)
@@ -0,0 +1,84 @@
+package com.tencent.iot.hub.device.java.service;
+
+/**
+ * mqtt远程客户端选项
+ */
+
+public class TXMqttClientOptions {
+
+    /**
+     * 服务器URI
+     */
+    private String mServerURI;
+
+    /**
+     * Iot Hub控制台获取产品ID
+     */
+    private String mProductId;
+
+    /**
+     * 设备名，唯一
+     */
+    private String mDeviceName;
+
+    private String mSecretKey;
+
+   
+
+    public TXMqttClientOptions() {
+    }
+
+    public TXMqttClientOptions(String serverURI, String productId, String deviceName, String secretKey) {
+        this.mServerURI = serverURI;
+        this.mProductId = productId;
+        this.mDeviceName = deviceName;
+        this.mSecretKey = secretKey;
+    }
+
+
+    public String getServerURI() {
+        return mServerURI;
+    }
+
+    public TXMqttClientOptions serverURI(String serverURI) {
+        this.mServerURI = serverURI;
+        return this;
+    }
+
+    public String getProductId() {
+        return mProductId;
+    }
+
+    public TXMqttClientOptions productId(String productId) {
+        this.mProductId = productId;
+        return this;
+    }
+
+    public String getDeviceName() {
+        return mDeviceName;
+    }
+
+    public TXMqttClientOptions deviceName(String deviceName) {
+        this.mDeviceName = deviceName;
+        return this;
+    }
+
+    public String getSecretKey() {
+        return mSecretKey;
+    }
+
+    public TXMqttClientOptions secretKey(String secretKey) {
+        this.mSecretKey = secretKey;
+        return this;
+    }
+
+
+    @Override
+    public String toString() {
+        return "TXMqttClientOptions{" +
+                "mServerURI='" + mServerURI + '\'' +
+                ", mProductId='" + mProductId + '\'' +
+                ", mDeviceName='" + mDeviceName + '\'' +
+                '}';
+    }
+}
Index: hub-device-java/src/main/resources/log4j.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- hub-device-java/src/main/resources/log4j.properties	(date 1606400383058)
+++ hub-device-java/src/main/resources/log4j.properties	(date 1606400383058)
@@ -0,0 +1,25 @@
+### \u8BBE\u7F6E###
+log4j.rootLogger = debug,stdout,D,E
+
+### \u8F93\u51FA\u4FE1\u606F\u5230\u63A7\u5236\u62AC ###
+log4j.appender.stdout = org.apache.log4j.ConsoleAppender
+log4j.appender.stdout.Target = System.out
+log4j.appender.stdout.Threshold = DEBUG
+log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
+log4j.appender.stdout.layout.ConversionPattern = %d{dd/MM/yyyy HH:mm:ss,SSS} [%t] %-5p %c{1} %M %L %x - %m%n
+
+### \u8F93\u51FADEBUG \u7EA7\u522B\u4EE5\u4E0A\u7684\u65E5\u5FD7\u6587\u4EF6\u8BBE\u7F6E ###
+log4j.appender.D = com.tencent.iot.hub.device.java.utils.MyDailyRollingFileAppender
+log4j.appender.D.File = hub-device-java/data/log/gateway_debug.log
+log4j.appender.D.Append = true
+log4j.appender.D.Threshold = DEBUG
+log4j.appender.D.layout = org.apache.log4j.PatternLayout
+log4j.appender.D.layout.ConversionPattern = %d{HH:mm:ss,SSS} [%t] %-5p %c{1} %L %x - %m%n
+
+### \u8F93\u51FAERROR \u7EA7\u522B\u4EE5\u4E0A\u7684\u65E5\u5FD7\u6587\u4EF6\u8BBE\u7F6E ###
+log4j.appender.E = com.tencent.iot.hub.device.java.utils.MyDailyRollingFileAppender
+log4j.appender.E.File = hub-device-java/data/log/gateway_error.log
+log4j.appender.E.Append = true
+log4j.appender.E.Threshold = DEBUG
+log4j.appender.E.layout = org.apache.log4j.PatternLayout
+log4j.appender.E.layout.ConversionPattern = %d{dd/MM/yyyy HH:mm:ss,SSS} [%t] %-5p %c{1} %L %x - %m%n
Index: iot_service/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/proguard-rules.pro	(date 1606400383025)
+++ iot_service/proguard-rules.pro	(date 1606400383025)
@@ -0,0 +1,25 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/vinsonhuang/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/DeviceInterworkingApp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/DeviceInterworkingApp.java	(date 1606400383042)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/DeviceInterworkingApp.java	(date 1606400383042)
@@ -0,0 +1,90 @@
+package com.tencent.iot.hub.device.java;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.main.scenarized.Airconditioner;
+import com.tencent.iot.hub.device.java.main.scenarized.Door;
+
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+
+public class DeviceInterworkingApp {
+
+    // Demo
+    public static Airconditioner mAir;
+    public static Door mDoor;
+    private static int pubCount = 0;
+    private static final int testCnt = 1000;
+
+    public static void main(String[] args) {
+        mAir = new Airconditioner(new AirconditionerMqttActionCallBack());
+        mDoor = new Door();
+
+        try {
+            while(pubCount < testCnt) {
+                pubCount += 1;
+                Thread.sleep(20000);
+                if (pubCount > 1) {
+                    if (pubCount % 2 == 0) {
+                        mDoor.enterRoom();
+                    }
+                    if (pubCount % 2 == 1) {
+                        mDoor.leaveRoom();
+                    }
+                }
+            }
+        } catch (InterruptedException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        mAir.closeConnection();
+    }
+
+    private static class AirconditionerMqttActionCallBack extends TXMqttActionCallBack {
+
+        @Override
+        public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {
+            System.out.println(msg);
+
+            if (status.equals(Status.OK)) {
+                mAir.subScribeTopic();
+            }
+        }
+
+        @Override
+        public void onConnectionLost(Throwable cause) {
+            String logInfo = String.format("onConnectionLost, cause[%s]", cause.toString());
+            System.out.println(logInfo);
+        }
+
+        @Override
+        public void onDisconnectCompleted(Status status, Object userContext, String msg) {
+            String logInfo = String.format("onDisconnectCompleted, status[%s], msg[%s]", status.name(), msg);
+            System.out.println(logInfo);
+        }
+
+        @Override
+        public void onSubscribeCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+            String logInfo = String.format("onSubscribeCompleted, status[%s], message[%s]", status.name(), msg);
+            if (Status.ERROR == status) {
+                System.out.println(logInfo);
+            } else {
+                System.out.println(logInfo);
+            }
+        }
+
+        @Override
+        public void onMessageReceived(String topic, MqttMessage message) {
+            String logInfo = String.format("Airconditioner onMessageReceived, topic[%s], message[%s]", topic, message.toString());
+            System.out.println(logInfo);
+
+            if (message.toString().contains("come_home")) {
+                logInfo = "receive command: open airconditioner ";
+            } else {
+                logInfo = "receive command: close airconditioner ";
+            }
+
+            System.out.println(logInfo);
+        }
+    }
+}
Index: iot_service/gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/gradle.properties	(date 1606400383025)
+++ iot_service/gradle.properties	(date 1606400383025)
@@ -0,0 +1,23 @@
+# ��İ���
+PROJ_GROUP=com.qcloud.iot
+# ���ID
+PROJ_ARTIFACTID=iot-service
+# ��İ汾
+PROJ_VERSION=2.1.0
+### ��� gradle���õ���ʽ���� $PROJ_GROUP:$PROJ_ARTIFACTID:$PROJ_VERSION
+
+# ����
+PROJ_NAME=IoT-Service
+# �����Ŀ��ҳ
+PROJ_WEBSITEURL=https://github.com/tencentyun/qcloud-iot-sdk-android
+# ������ٵ�ַ
+PROJ_ISSUETRACKERURL=https://github.com/tencentyun/qcloud-iot-sdk-android/issues
+# VCS ��ַ
+PROJ_VCSURL=https://github.com/tencentyun/qcloud-iot-sdk-android.git
+# ��ļ�����
+PROJ_DESCRIPTION=
+
+# �����ߵ���Ϣ, ��������
+DEVELOPER_ID=shockcao
+DEVELOPER_NAME=Cao ShaoKun
+DEVELOPER_EMAIL=shockcao@tencent.com
\ No newline at end of file
Index: hub-device-java/src/main/java/com/tencent/iot/hub/device/java/ShadowApp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/src/main/java/com/tencent/iot/hub/device/java/ShadowApp.java	(date 1606400383042)
+++ hub-device-java/src/main/java/com/tencent/iot/hub/device/java/ShadowApp.java	(date 1606400383042)
@@ -0,0 +1,172 @@
+package com.tencent.iot.hub.device.java;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.log4j.LogManager;
+import org.apache.log4j.PropertyConfigurator;
+import org.bouncycastle.pqc.math.linearalgebra.GoppaCode.MaMaPe;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.eclipse.paho.client.mqttv3.logging.JSR47Logger;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONWriter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.shadow.DeviceProperty;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowActionCallBack;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowConnection;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowConstants;
+import com.tencent.iot.hub.device.java.core.util.AsymcSslUtils;
+
+
+public class ShadowApp {
+	private static final Logger LOG = LoggerFactory.getLogger(App.class);
+	private static TXShadowConnection mShadowConnection;
+	private static String testProductIDString = "YOUR_PRODUCT_ID";
+	private static String testDeviceNameString = "YOUR_DEVICE_NAME";
+	private static String testPSKString = "YOUR_PSK";
+	private static String testTopicString = testProductIDString + "/" + testDeviceNameString + "/data"; 
+	private static boolean testFinished = false;
+	private static int pubCount = 0;
+	private static final int testCnt = 1000;
+	
+	public static void main(String[] args) {
+		// TODO Auto-generated method stub
+		MqttConnectOptions options = new MqttConnectOptions();
+		options.setConnectionTimeout(8);
+		options.setKeepAliveInterval(240);
+		options.setAutomaticReconnect(false);
+		
+		options.setSocketFactory(AsymcSslUtils.getSocketFactory());
+		
+		mShadowConnection = new TXShadowConnection(testProductIDString, testDeviceNameString, testPSKString, new callback());
+		mShadowConnection.connect(options, null);
+		try {
+			while(pubCount < testCnt) {
+				pubCount += 1;
+				Thread.sleep(20000);
+
+				if (pubCount < 3) {  // 更新设备影子
+
+					List<DeviceProperty>  mDevicePropertyList = new ArrayList<>();
+
+					DeviceProperty deviceProperty1 = new DeviceProperty();
+					deviceProperty1.key("updateCount").data(String.valueOf(pubCount)).dataType(TXShadowConstants.JSONDataType.INT);
+					mShadowConnection.registerProperty(deviceProperty1);
+
+					DeviceProperty deviceProperty2 = new DeviceProperty();
+					deviceProperty2.key("energyConsumption").data(String.valueOf(10+pubCount)).dataType(TXShadowConstants.JSONDataType.INT);
+					mShadowConnection.registerProperty(deviceProperty2);
+
+					DeviceProperty deviceProperty3 = new DeviceProperty();
+					deviceProperty3.key("temperatureDesire").data(String.valueOf(25)).dataType(TXShadowConstants.JSONDataType.INT);
+					mShadowConnection.registerProperty(deviceProperty3);
+
+					mDevicePropertyList.add(deviceProperty1);
+					mDevicePropertyList.add(deviceProperty2);
+					mDevicePropertyList.add(deviceProperty3);
+
+					mShadowConnection.update(mDevicePropertyList, null);
+				}
+				if (pubCount == 4) {
+					mShadowConnection.get(null);
+				}
+			}
+		} catch (InterruptedException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		mShadowConnection.disConnect(null);
+	}
+
+	public static class callback extends TXShadowActionCallBack{
+		/**
+	     * 文档请求响应的回调接口
+	     *
+	     * @param type 文档操作方式, get/update/delete
+	     * @param result 请求响应结果, 0: 成功；非0：失败
+	     * @param jsonDocument   云端返回的json文档
+	     */
+	    public void onRequestCallback(String type, int result, String jsonDocument) {
+			System.out.println("onRequestCallback" + jsonDocument);
+	    }
+
+	    /**
+	     * 设备属性更新回调接口
+	     *
+	     * @param propertyJSONDocument 从云端收到的原始设备属性json文档
+	     * @param propertyList   更新后的设备属性集
+	     */
+	    public void onDevicePropertyCallback(String propertyJSONDocument, List<? extends DeviceProperty> propertyList) {
+			System.out.println("onDevicePropertyCallback " +propertyList);
+	    }
+
+
+	    /**
+	     * 收到来自云端的消息
+	     *
+	     * @param topic   主题名称
+	     * @param message 消息内容
+	     */
+	    public void onMessageReceived(String topic, MqttMessage message) {
+	    	System.out.println(topic + " arrived , message is " + message.toString());
+	    }
+
+
+	    /**
+	     * 发布消息完成回调
+	     *
+	     * @param status        Status.OK: 发布消息成功； Status.ERROR: 发布消息失败
+	     * @param token         消息token，包含消息内容结构体
+	     * @param userContext   用户上下文
+	     * @param msg           详细信息
+	     */
+	    public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+	    	System.out.println("Onpublish " + status + msg);
+	    }
+
+	    /**
+	     * 订阅主题完成回调
+	     *
+	     * @param status           Status.OK: 订阅成功； Status.ERROR: 订阅失败
+	     * @param token            消息token，包含消息内容结构体
+	     * @param userContext      用户上下文
+	     * @param msg              详细信息
+	     */
+	    public void onSubscribeCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+	    	System.out.println("OnSubscribe " + status + msg);
+	    	MqttMessage message = new MqttMessage();
+			// 这里添加获取到的数据
+			message.setPayload(("hello123").getBytes());
+			message.setQos(1);
+			mShadowConnection.publish(testTopicString, message, null);
+	    }
+
+	    /**
+	     * 取消订阅主题完成回调
+	     *
+	     * @param status           Status.OK: 取消订阅成功； Status.ERROR: 取消订阅失败
+	     * @param token            消息token，包含消息内容结构体
+	     * @param userContext      用户上下文
+	     * @param msg              详细信息
+	     */
+	    public void onUnSubscribeCompleted(Status status, IMqttToken token, Object userContext, String msg) {
+	    }
+		
+	    public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {
+	    	System.out.println("Connect Completed");
+	    	mShadowConnection.subcribe(testTopicString, 1, null);
+		}
+
+		public void onConnectionLost(Throwable cause) {
+		}
+	}
+}
Index: hub-device-java/docs/常见问题java.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/docs/常见问题java.md	(date 1606400383037)
+++ hub-device-java/docs/常见问题java.md	(date 1606400383037)
@@ -0,0 +1,27 @@
+## 常见问题
+
+#### 设备端与云端通信内容，在控制台内容日志中的内容显示base64的编码，为什么没有显示传递的json格式的数据？
+
+检查一下创建产品的时候数据格式是不是设置的自定义格式，如果是自定义格式的产品，数据传输到云端后会进行base编码。如果需要显示json格式的数据在创建产品的时候数据格式请选择json格式。
+
+#### 物联网通信Java SDK采用maven方式引入依赖，报错cannot resolve symbol "TXMqttConnection"，如何解决？
+
+请确认SDK对应的maven依赖地址和版本是否正确，下载下来的jar包是否完整，不完整请清除缓存，重新拉取jar包。如使用 IntelliJ IDEA 编辑器，建议点击 Invalidate and Restart 清除无效缓存并重启。
+
+#### 物联网通信有示例Demo吗
+
+java的示例对应可以运行 [App.java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/App.java) 和 [ShadowApp.java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/ShadowApp.java) 的main函数去查看。
+
+#### java的示例中mProductID，mDevName，mDevPSK需要填什么？
+
+mProductID对应填写产品ID，mDevName对应填写设备名称，mDevPSK对应填写设备密钥（使用密钥认证方式）。如果使用证书认证方式请参考 [java认证连接部分](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/README.md#认证连接)
+
+#### 设备为何一直上下线？
+
+物联网接入层有设备互踢的逻辑，如果是用同一个设备 ID 在不同地方登录，会导致其中一方被另一方踢下线。因此发现设备一直上下线时，需要确认是否有不同的人或者多线程在使用同一个设备 ID 执行登录操作。
+
+#### 动态注册的设备认证连接时报无权连接(5)，如何排查？
+
+在SDK中调用动态注册对应注册成功的日志会返回 `I/TXMQTT: Dynamic register OK! onGetDevicePSK, devicePSK[**********************]` 或者 `I/TXMQTT: Dynamic register OK!onGetDeviceCert, deviceCert[**********************] devicePriv[**********************]` 可以检查一下认证连接的时候，传入的密钥或证书是不是对应动态注册的得到的密钥或证书。
+
+
Index: hub-device-java/docs/自建服务器接入.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/docs/自建服务器接入.md	(date 1606400383038)
+++ hub-device-java/docs/自建服务器接入.md	(date 1606400383038)
@@ -0,0 +1,27 @@
+# 自建服务器接入
+
+本文主要描述，当您使用自建服务器时，如何接入SDK。
+
+## 传入自建服务器的Broker地址
+SDK提供传入自建服务器Broker地址的能力，可使用以下 TXMqttConnection 或 TXShadowConnection 的初始化方式，传入Broker地址：
+
+```
+TXMqttConnection(String serverURI, String productID, String deviceName, String secretKey, DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence, TXMqttActionCallBack callBack)
+TXShadowConnection(String serverURI, String productID, String deviceName, String secretKey, DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence, TXShadowActionCallBack callBack)
+```
+
+其中serverURI参数，即为将要传入的自建服务器Broker地址。
+
+## 传入自建服务器对应的CA证书
+
+SDK提供传入自建服务器对应的CA证书的能力，可调用AsymcSslUtils.getSocketFactory(String customCA)方法，示例代码如下：
+
+```
+String myCA = "您的CA证书文本"
+MqttConnectOptions options = new MqttConnectOptions();
+options.setSocketFactory(AsymcSslUtils.getSocketFactory(myCA));
+mShadowConnection = new TXShadowConnection(testProductIDString, testDeviceNameString, testPSKString, new callback());
+mShadowConnection.connect(options, null);
+```
+
+以上为设备及设备影子认证接入时，配置自建服务器对应CA证书的接口。
Index: hub-device-java/docs/设备互通.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/docs/设备互通.md	(date 1606400383039)
+++ hub-device-java/docs/设备互通.md	(date 1606400383039)
@@ -0,0 +1,167 @@
+* [设备互通](#设备互通)
+  * [操作场景](#操作场景)
+  * [编译运行示例程序](#编译运行示例程序)
+  * [填写认证连接设备的参数](#填写认证连接设备的参数)
+  * [连接认证介绍](#连接认证介绍)
+  * [体验 Door 设备进门](#体验-Door-设备进门)
+  * [体验 Door 设备出门](#体验-Door-设备出门)
+
+# 设备互通
+## 操作场景
+官网上假设的一个智能家居场景，结合腾讯云物联网通信设备端 IoT Hub JAVA-SDK 体验基于设备间的消息和规则引擎实现设备之间的联动。请参考官网 [场景一：设备互通](https://cloud.tencent.com/document/product/634/11913)
+
+体验设备互通，需要按照官网文档中创建两类智能设备（Door、AirConditioner）。 还需要配置规则引擎，请参考官网 [规则引擎概述](https://cloud.tencent.com/document/product/634/14446) 一章 , 将 [数据转发到另一Topic](https://cloud.tencent.com/document/product/634/14449)。
+
+## 编译运行示例程序
+
+#### 下载Hub JAVA SDK Demo示例代码
+
+示例代码及源码在 [hub-device-java](https://github.com/tencentyun/iot-device-java/tree/master/hub-device-java) 的module下。
+
+#### 准备开发环境
+
+本示例使用的开发环境如下：
+
+* 操作系统：macOS
+* JDK版本：[JDK13](https://www.oracle.com/java/technologies/javase-jdk13-downloads.html)
+* 集成开发环境：[IntelliJ IDEA CE](https://www.jetbrains.com/idea/)
+
+#### 检查SDK的依赖关系
+
+示例工程中使用的是源码依赖，也可以在maven中添加依赖，请参考 [README-工程配置](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/README.md#工程配置)
+
+## 填写认证连接设备的参数
+
+Door模型在SDK Demo示例中对应的是 [Door.java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/scenarized/Door.java) 文件，需要填好该文件中对应的参数。
+
+```
+public class Door {
+    private static final String PRODUCT_ID = "YOUR_PRODUCT_ID"; //产品ID
+    private static final String DEVICE_NAME = "YOUR_DEVICE_NAME"; //设备名称
+    private static final String SECRET_KEY = "YOUR_SECRET_KEY"; //设备密钥(密钥认证)
+    private static final String DEVICE_CERT_NAME = "YOUR_DEVICE_NAME_cert.crt"; //设备证书文件名称（证书认证）
+    private static final String DEVICE_KEY_NAME = "YOUR_DEVICE_NAME_private.key"; //设备私钥文件名称（证书认证）
+}
+```
+
+Airconditioner模型在SDK Demo示例中对应的是 [Airconditioner.java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/main/scenarized/Airconditioner.java) 文件，需要填好该文件中对应的参数。
+
+```
+public class Airconditioner {
+    private static final String PRODUCT_ID = "YOUR_PRODUCT_ID"; //产品ID
+    protected static final String DEVICE_NAME = "YOUR_DEVICE_NAME"; //设备名称
+    private static final String SECRET_KEY = "YOUR_SECRET_KEY"; //设备密钥(密钥认证)
+    private static final String DEVICE_CERT_NAME = "YOUR_DEVICE_NAME_cert.crt"; //设备证书文件名称（证书认证）
+    private static final String DEVICE_KEY_NAME = "YOUR_DEVICE_NAME_private.key"; //设备私钥文件名称（证书认证）
+}
+```
+
+## 连接认证介绍
+
+当 MQTT 认证方式为密钥认证时，在 MqttConnectOptions 中添加 SSL 配置 `options.setSocketFactory(AsymcSslUtils.getSocketFactory());`
+
+当 MQTT 认证方式为证书认证时，在 MqttConnectOptions 中添加 SSL 配置 `options.setSocketFactory(AsymcSslUtils.getSocketFactoryByAssetsFile(mContext, DEVICE_CERT_NAME, DEVICE_KEY_NAME));`
+
+运行 [DeviceInterworkingApp.java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/DeviceInterworkingApp.java) ，初始化Airconditioner，将 Airconditioner 进行 MQTT 认证连接，认证连接通过后就订阅自身 Topic `${productId}/${deviceName}/control`。示例代码如下：
+
+```
+public static void main(String[] args) {
+    mAir = new Airconditioner(new AirconditionerMqttActionCallBack()); // 初始化Airconditioner实例，会进行 MQTT 认证连接，设置 MQTT 回调
+    mDoor = new Door(); // 初始化Door实例，不会进行 MQTT 认证连接
+}
+
+private static class AirconditionerMqttActionCallBack extends TXMqttActionCallBack {
+    @Override
+    public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) { // MQTT 认证连接完成
+        if (status.equals(Status.OK)) {
+            mAir.subScribeTopic(); // 订阅自身 Topic
+        }
+    }
+    ...
+    @Override
+    public void onMessageReceived(String topic, MqttMessage message) { // 收到来自云端的消息
+        String logInfo = String.format("Airconditioner onMessageReceived, topic[%s], message[%s]", topic, message.toString());
+        System.out.println(logInfo);
+        if (message.toString().contains("come_home")) {
+            logInfo = "receive command: open airconditioner ";
+        } else {
+            logInfo = "receive command: close airconditioner ";
+        }
+        System.out.println(logInfo);
+    }
+}
+```
+
+观察Logcat日志。
+```
+TXMqttConnection connect 297  - Start connecting to ssl://XMN6AZ4M0Y.iotcloud.tencentdevices.com:8883
+[MQTT Call: XMN6AZ4M0YairConditioner1] INFO  TXMqttConnection onSuccess 268  - onSuccess!
+connected to ssl://XMN6AZ4M0Y.iotcloud.tencentdevices.com:8883
+TXMqttConnection subscribe 633  - Starting subscribe topic: XMN6AZ4M0Y/airConditioner1/control
+onSubscribeCompleted, status[OK], message[subscribe success]
+```
+以上日志为 Airconditioner 设备 MQTT 已连接 成功，订阅自身 Topic 成功，观察控制台中创建的 Airconditioner 设备的状态已更改为上线。
+
+## 体验 Door 设备进门
+
+Door 实例调用 enterRoom 方法，会进行 MQTT 认证连接，连接成功后发布自身 Topic：`${productId}/${deviceName}/event`，由于配置了规则引擎将数据转发，将会由云端规则引擎转发 Topic 消息给到 Airconditioner 设备。示例代码如下：
+```
+public void enterRoom() {
+    ...
+    mqttConnection = new TXMqttConnection(PRODUCT_ID, DEVICE_NAME, SECRET_KEY, new DoorMqttActionCallBack());
+    mqttConnection.connect(options, null);
+    ...
+    if (mqttConnection.getConnectStatus().equals(TXMqttConstants.ConnectStatus.kConnected)) { // 如果已经连接状态，就直接发布自身 Topic
+        ...
+        mqttConnection.publish(topic, message, null);
+    }
+    ...
+}
+
+private class DoorMqttActionCallBack extends TXMqttActionCallBack {
+    @Override
+    public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) { // MQTT 认证连接完成
+        if (status.equals(Status.OK)) { // 连接成功
+            if (!reconnect) { // 不是重连 就发布自身 Topic
+                MqttMessage message = new MqttMessage();
+                message.setPayload(COME_HOME_MESSAGE.getBytes());
+                String topic = String.format("%s/%s/%s", PRODUCT_ID, DEVICE_NAME, "event");
+                mqttConnection.publish(topic, message, null);
+            }
+         }
+    }
+...
+}
+```
+
+观察Logcat日志。
+```
+TXMqttConnection connect 297  - Start connecting to ssl://9RW4A8OOFK.iotcloud.tencentdevices.com:8883
+[MQTT Call: 9RW4A8OOFKdoor1] INFO  TXMqttConnection onSuccess 268  - onSuccess!
+TXMqttConnection publish 451  - Starting publish topic: 9RW4A8OOFK/door1/event Message: {"action": "come_home", "targetDevice": "airConditioner1"}
+Airconditioner onMessageReceived, topic[XMN6AZ4M0Y/airConditioner1/control], message[{"action":"come_home","targetDevice":"airConditioner1"}]
+receive command: open airconditioner 
+```
+以上日志为 Door 设备 MQTT 已连接 成功，Door 设备发布自身 Topic ，并携带了 action 为 come_home 的 message 消息，之后 Airconditioner 设备也接收到了由云端规则引擎转发来的 Topic 进门回家的消息，至此实现进门打开空调设备的目的。
+
+## 体验 Door 设备出门
+
+Door 实例调用 leaveRoom 方法，将会触发 Door 设备发布自身 Topic：`${productId}/${deviceName}/event`，由于配置了规则引擎将数据转发，将会由云端规则引擎转发 Topic 消息给到 Airconditioner 设备， Door 设备断开 MQTT 连接。示例代码如下：
+```
+public void leaveRoom() {
+    ...
+    MqttMessage message = new MqttMessage();
+    message.setPayload(LEAVE_HOME_MESSAGE.getBytes());
+    String topic = String.format("%s/%s/%s", PRODUCT_ID, DEVICE_NAME, "event");
+    mqttConnection.publish(topic, message, null); // 发布自身 Topic 携带 LEAVE_HOME_MESSAGE（leave_home） 的消息
+    closeConnection(); // 关闭 Door 设备的 MQTT 连接
+}
+```
+
+观察Logcat日志。
+```
+TXMqttConnection publish 451  - Starting publish topic: 9RW4A8OOFK/door1/event Message: {"action": "leave_home", "targetDevice": "airConditioner1"}
+Airconditioner onMessageReceived, topic[XMN6AZ4M0Y/airConditioner1/control], message[{"action":"leave_home","targetDevice":"airConditioner1"}]
+receive command: close airconditioner 
+```
+以上日志为 Door 设备发布订阅自身 Topic ，并携带了 action 为 leave_home 的 message 消息并断开 MQTT 连接，之后 Airconditioner 设备也接收到了由云端规则引擎转发来的 Topic 出门离开了的消息，至此实现出门关闭空调设备的目的。
Index: hub-device-java/docs/设备状态上报与状态设置.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/docs/设备状态上报与状态设置.md	(date 1606400383039)
+++ hub-device-java/docs/设备状态上报与状态设置.md	(date 1606400383039)
@@ -0,0 +1,112 @@
+* [设备状态上报与状态设置](#设备状态上报与状态设置)
+  * [操作场景](#操作场景)
+  * [编译运行示例程序](#编译运行示例程序)
+  * [填写认证连接设备的参数](#填写认证连接设备的参数)
+  * [设备上报状态信息](#设备上报状态信息)
+  * [设置设备目标温度](#设置设备目标温度)
+  * [获取设备影子文档](#获取设备影子文档)
+
+# 设备状态上报与状态设置
+## 操作场景
+官网上假设的一个智能家居场景，结合腾讯云物联网通信设备端 IoT Hub JAVA-SDK 体验更新设备属性信息与获取设备影子文档。请参考官网 [场景二：设备状态上报与状态设置](https://cloud.tencent.com/document/product/634/11914)
+
+体验前提，需要按照官网文档中创建产品设备。请参考官网 [控制台使用手册-设备接入准备](https://cloud.tencent.com/document/product/634/14442) 。
+
+## 编译运行示例程序
+
+下载Hub JAVA SDK Demo示例代码，准备开发环境，检查SDK的依赖关系，请参考 [设备互通](https://github.com/tencentyun/iot-device-java/tree/master/hub-device-java/docs/设备互通.md#编译运行示例程序) , [设备影子](https://cloud.tencent.com/document/product/634/11918) 以及 [设备影子数据流](https://cloud.tencent.com/document/product/634/14072) 了解设备影子开发。
+
+## 填写认证连接设备的参数
+
+请在 [ShadowApp.java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/ShadowApp.java) 文件中填入所需的参数。
+
+```
+public class ShadowApp {
+    private static String testProductIDString = "YOUR_PRODUCT_ID"; //产品ID
+    private static String testDeviceNameString = "YOUR_DEVICE_NAME"; //设备名称
+    private static String testPSKString = "YOUR_PSK"; //设备密钥(密钥认证)
+}
+```
+此处以密钥认证为例
+
+## 设备上报状态信息
+
+运行 [ShadowApp.java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/ShadowApp.java) ，初始化mShadowConnection，将 设备影子 进行 MQTT 认证连接，设备影子通过调用update接口更新设备属性信息，先订阅自身 Topic `$shadow/operation/result/${productId}/${deviceName}`， 然后将要上报的属性信息通过 Topic `$shadow/operation/${productId}/${deviceName}`发布出去。示例代码如下：
+
+```
+public static void main(String[] args) {
+...
+    mShadowConnection = new TXShadowConnection(testProductIDString, testDeviceNameString, testPSKString, new callback());
+    mShadowConnection.connect(options, null);
+
+    while(pubCount < testCnt) {
+        pubCount += 1;
+        Thread.sleep(20000);
+        if (pubCount < 3) {  // 更新设备影子
+            List<DeviceProperty>  mDevicePropertyList = new ArrayList<>();
+            DeviceProperty deviceProperty1 = new DeviceProperty();
+            deviceProperty1.key("updateCount").data(String.valueOf(pubCount)).dataType(TXShadowConstants.JSONDataType.INT);
+            mShadowConnection.registerProperty(deviceProperty1);
+            DeviceProperty deviceProperty2 = new DeviceProperty();
+            deviceProperty2.key("energyConsumption").data(String.valueOf(10+pubCount)).dataType(TXShadowConstants.JSONDataType.INT);
+            mShadowConnection.registerProperty(deviceProperty2);
+            DeviceProperty deviceProperty3 = new DeviceProperty();
+            deviceProperty3.key("temperatureDesire").data(String.valueOf(25)).dataType(TXShadowConstants.JSONDataType.INT);
+            mShadowConnection.registerProperty(deviceProperty3);
+            mDevicePropertyList.add(deviceProperty1);
+            mDevicePropertyList.add(deviceProperty2);
+            mDevicePropertyList.add(deviceProperty3);
+            mShadowConnection.update(mDevicePropertyList, null);
+        }
+...
+    }
+}
+public static class callback extends TXShadowActionCallBack{
+    /**
+     * 设备属性更新回调接口
+     * @param propertyJSONDocument 从云端收到的原始设备属性json文档
+     * @param propertyList   更新后的设备属性集
+     */
+    public void onDevicePropertyCallback(String propertyJSONDocument, List<DeviceProperty> propertyList) {
+        System.out.println("onDevicePropertyCallback " +propertyList);
+    }
+}
+```
+
+观察Logcat日志。
+```
+TXMqttConnection connect 297  - Start connecting to ssl://XMN6AZ4M0Y.iotcloud.tencentdevices.com:8883
+TXShadowConnection onConnectCompleted 633  - onConnectCompleted, status[OK], reconnect[false], msg[connected to ssl://XMN6AZ4M0Y.iotcloud.tencentdevices.com:8883]
+TXMqttConnection subscribe 633  - Starting subscribe topic: $shadow/operation/result/XMN6AZ4M0Y/airConditioner1
+TXMqttConnection subscribe 633  - Starting subscribe topic: XMN6AZ4M0Y/airConditioner1/data
+TXShadowConnection onSubscribeCompleted 675  - onSubscribeCompleted, status[OK], errMsg[subscribe success], topics[[$shadow/operation/result/XMN6AZ4M0Y/airConditioner1]]
+TXShadowConnection onSubscribeCompleted 675  - onSubscribeCompleted, status[OK], errMsg[subscribe success], topics[[XMN6AZ4M0Y/airConditioner1/data]]
+TXMqttConnection publish 451  - Starting publish topic: $shadow/operation/XMN6AZ4M0Y/airConditioner1 Message: {"clientToken":"XMN6AZ4M0YairConditioner1-0","state":{"reported":{"energyConsumption":11,"updateCount":1,"temperatureDesire":25}},"type":"update","version":0}
+```
+以上日志为 设备影子 MQTT 已连接 成功，发布自身 Topic 成功并携带相关属性信息，观察控制台中创建的对应设备的状态已更改为上线，并在控制台中设备影子观察到reported已上报最新的属性信息。
+
+## 设置设备目标温度
+
+前提，设备已认证连接在线，并订阅了 Topic `$shadow/operation/result/${productId}/${deviceName}`， 调用 restAPI 接口 [UpdateDeviceShadow](https://console.cloud.tencent.com/api/explorer?Product=iotcloud&Version=2018-06-14&Action=UpdateDeviceShadow&SignVersion=) 模拟家电管理后台发布目标温度配置，restAPI 请求参数例如：deviceName=airConditioner1, state={"desired" : {"temperatureDesire": 10}}, ProductId=XMN6AZ4M0Y, ShadowVersion要和控制台上最新的设备影子中的Version匹配，期望调整控制温度为 10°。
+
+观察Logcat日志。
+```
+TXMqttConnection messageArrived 879  - Received topic: $shadow/operation/result/XMN6AZ4M0Y/airConditioner1, id: 0, message: {"clientToken":"XMN6AZ4M0YairConditioner1-2","payload":{"state":{"delta":{"temperatureDesire":10},"desired":{"temperatureDesire":10},"reported":{"energyConsumption":12,"status":1,"temperatureDesire":25,"updateCount":2}},"timestamp":1603269222843,"version":25},"result":0,"timestamp":1603269269,"type":"get"}
+onDevicePropertyCallback [DeviceProperty{mKey='temperatureDesire', mData='10', mDataType=INT}]
+```
+以上日志为设备接收到云端下发的 delta 消息。期望更新的属性为temperatureDesire，期望设置目标温度10度。更新delta信息后，上报空的desired信息。
+
+## 获取设备影子文档
+
+设备向`$shadow/operation/${productId}/${deviceName} `主题发布 get 消息。示例代码如下：
+
+```
+mShadowConnection.get(null);
+```
+
+观察Logcat日志。
+```
+TXMqttConnection publish 451  - Starting publish topic: $shadow/operation/XMN6AZ4M0Y/airConditioner1 Message: {"clientToken":"XMN6AZ4M0YairConditioner1-2","type":"get"}
+onRequestCallback{"state":{"desired":{"temperatureDesire":10},"delta":{"temperatureDesire":10},"reported":{"energyConsumption":12,"updateCount":2,"temperatureDesire":25,"status":1}},"version":32,"timestamp":1603269797600}
+```
+以上日志为发布一条带有 type 为 get 的 Topic 消息成功。可以在控制台中查看最新的设备影子文档，和拉取得到的文档是一致的。
Index: hub-device-java/docs/网关子设备固件升级.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- hub-device-java/docs/网关子设备固件升级.md	(date 1606400383038)
+++ hub-device-java/docs/网关子设备固件升级.md	(date 1606400383038)
@@ -0,0 +1,142 @@
+* [OTA网关子设备固件升级](#OTA网关子设备固件升级)
+  * [操网关子设备固件升级简介](#网关子设备固件升级简介)
+  * [编译运行示例程序](#编译运行示例程序)
+  * [填写认证连接设备的参数](#填写认证连接设备的参数)
+  * [运行Demo认证连接并执行子设备固件升级](#运行Demo认证连接并执行子设备固件升级)
+
+# OTA网关子设备固件升级
+## 网关子设备固件升级简介
+
+设备固件升级又称 OTA，是物联网通信服务的重要组成部分。当物联设备有新功能或者需要修复漏洞时，设备可以通过 OTA 服务快速进行固件升级。请参考官网文档 控制台使用手册 [固件升级](https://cloud.tencent.com/document/product/634/14673)
+
+体验网关子设备固件升级需要在控制台中添加新的固件，请参考官网文档 开发者手册 [设备固件升级](https://cloud.tencent.com/document/product/634/14674)
+
+由于子设备无法直接和云端建立连接，网关设备延用设备OTA升级方式对子设备进行固件升级，支持网关子设备单台升级和批量升级。
+
+## 编译运行示例程序
+
+#### 下载Hub JAVA SDK Demo示例代码
+
+示例代码及源码在 [hub-device-java](https://github.com/tencentyun/iot-device-java/tree/master/hub-device-java) 的module下。
+
+#### 准备开发环境
+
+本示例使用的开发环境如下：
+
+* 操作系统：macOS
+* JDK版本：[JDK13](https://www.oracle.com/java/technologies/javase-jdk13-downloads.html)
+* 集成开发环境：[IntelliJ IDEA CE](https://www.jetbrains.com/idea/)
+
+#### 检查SDK的依赖关系
+
+示例工程中使用的是源码依赖，也可以在maven中添加依赖，请参考 [README-工程配置](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/README.md#工程配置)
+
+## 填写认证连接设备的参数
+
+请在 [App.java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/App.java) 文件中填入所需的参数。
+```
+public class App {
+    private static String mProductID = "YOUR_PRODUCT_ID"; //网关产品ID
+	private static String mDevName = "YOUR_DEVICE_NAME"; //网关设备名称
+	private static String mDevPSK = "YOUR_DEV_PSK"; //网关设备密钥(密钥认证)
+	private static String mSubProductID = "YOUR_SUB_PRODUCT_ID"; //子设备产品ID
+	private static String mSubDevName = "YOUR_SUB_DEV_NAME"; //子设备名称
+	private static String mSubDevProductKey = "YOUR_SUB_DEV_PSK"; //子设备密钥(密钥认证)
+}
+```
+
+## 运行Demo认证连接并执行子设备固件升级
+
+当 MQTT 认证方式为密钥认证时，在 MqttConnectOptions 中添加 SSL 配置 `options.setSocketFactory(AsymcSslUtils.getSocketFactory());`
+
+当 MQTT 认证方式为证书认证时，在 MqttConnectOptions 中添加 SSL 配置 `options.setSocketFactory(AsymcSslUtils.getSocketFactoryByFile(workDir + mCertFilePath, workDir + mPrivKeyFilePath));`
+
+运行 [App.java](https://github.com/tencentyun/iot-device-java/blob/master/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/App.java) ，将 网关设备 进行 MQTT 认证连接，认证连接后，初始化OTA并使网关设备和子设备都订阅 Topic `$ota/update/${productId}/${deviceName}`。示例代码如下：
+
+```
+public static void main(String[] args) {
+    mqttconnection = new TXMqttConnection(mProductID, mDevName, mDevPSK, new callBack());
+    mqttconnection.setSubDevName(mSubDevName);  //设置子设备名称
+    mqttconnection.setSubDevProductKey(mSubDevProductKey);  //设置子设备密钥(密钥认证)
+    mqttconnection.setSubProductID(mSubProductID);  //设置子设备产品ID
+    mqttconnection.connect(options, null);  //进行 MQTT 认证连接
+}
+
+public static class callBack extends TXMqttActionCallBack {
+
+    @Override
+    public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {  //进行 MQTT 认证连接回调
+        mqttconnection.initOTA(path2Store, oTACallBack);  //初始化OTA
+    }
+
+    private TXOTACallBack oTACallBack = new TXOTACallBack() {
+
+        @Override
+        public void onReportFirmwareVersion(int resultCode, String version, String resultMsg) { // 上报固件版本回调
+        }
+
+        @Override
+        public boolean onLastestFirmwareReady(String url, String md5, String version) {
+        	System.out.println("onLastestFirmwareReady url=" + url + " version " + version);
+        	mqttconnection.gatewayDownSubdevApp(url, path2Store + "/" + md5, md5, version);
+        	return true; // false 自动触发下载升级文件  true 需要手动触发下载升级文件
+        }
+
+        @Override
+        public void onDownloadProgress(int percent, String version) { // OTA升级包下载进度回调
+        	mqttconnection.gatewaySubdevReportProgress(percent, version);
+        }
+
+        @Override
+        public void onDownloadCompleted(String outputFile, String version) { // OTA升级包下载完成回调
+        	mqttconnection.gatewaySubdevReportStart(version);
+        	mqttconnection.gatewaySubdevReportSuccess(version);
+        }
+
+        @Override
+        public void onDownloadFailure(int errCode, String version) { // OTA升级包下载失败回调
+        	mqttconnection.gatewaySubdevReportFail(errCode, "", version);
+        }
+    };
+    @Override
+    public void onSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+        for (String topicEls : asyncActionToken.getTopics()) {
+            if (topicEls.startsWith("$ota/update/")) {
+                mqttconnection.gatewaySubdevReportVer("0.0"); // 上报当前的设备固件的版本号为0.0。
+            }
+        }
+    ...
+}
+```
+
+以下是子设备成功订阅 OTA 升级的 Topic 主题 和 上报当前版本号 的IDE控制台日志，示例中的版本号version传入的值为0.0。
+
+```
+TXMqttConnection connect 297  - Start connecting to ssl://AP9ZLEVFKT.iotcloud.tencentdevices.com:8883
+TXMqttConnection onSuccess 268  - onSuccess!
+ffffffffffff msg connected to ssl://AP9ZLEVFKT.iotcloud.tencentdevices.com:8883
+TXMqttConnection subscribe 633  - Starting subscribe topic: $ota/update/AP9ZLEVFKT/gateway1
+TXMqttConnection subscribe 633  - Starting subscribe topic: $ota/update/9RW4A8OOFK/door1
+onSubscribeCompleted, status[OK], topics[[$ota/update/AP9ZLEVFKT/gateway1]], userContext[], errMsg[subscribe success]
+onSubscribeCompleted, status[OK], topics[[$ota/update/9RW4A8OOFK/door1]], userContext[], errMsg[subscribe success]
+TXMqttConnection publish 451  - Starting publish topic: $ota/report/9RW4A8OOFK/door1 Message: {"report":{"version":"0.0"},"type":"report_version"}
+onPublishCompleted, status[OK], topics[[$ota/report/9RW4A8OOFK/door1]],   errMsg[publish success]
+```
+
+当在控制台中触发固件升级操作后，设备端会通过订阅的 OTA 升级的 Topic $ota/update/${productID}/${deviceName} 收到固件升级的消息
+
+```
+TXMqttConnection messageArrived 879  - Received topic: $ota/update/9RW4A8OOFK/door1, id: 0, message: {"file_size":234775,"md5sum":"f2f1b3317d4f1ef7f512bfae5050563b","type":"update_firmware","url":"https://ota-1255858890.cos.ap-guangzhou.myqcloud.com/100012619289_9RW4A8OOFK_0.0.1?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDdO8ldrUa0Uts4H5Gzx6FZ9nfedjpiCd7%26q-sign-time%3D1603710048%3B1603796448%26q-key-time%3D1603710048%3B1603796448%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Deb248051f6bef7756462b7f833f0608c81281cc1","version":"0.0.1"}
+TXOTAImpl run 501  - fileLength 234775 bytes
+TXOTAImpl run 510  - connect: https://ota-1255858890.cos.ap-guangzhou.myqcloud.com/100012619289_9RW4A8OOFK_0.0.1?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDdO8ldrUa0Uts4H5Gzx6FZ9nfedjpiCd7%26q-sign-time%3D1603710048%3B1603796448%26q-key-time%3D1603710048%3B1603796448%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Deb248051f6bef7756462b7f833f0608c81281cc1
+TXOTAImpl checkServerTrusted 434  - checkServerTrusted OK!!
+TXOTAImpl run 520  - totalLength 234775 bytes
+TXOTAImpl run 543  - download 7789 bytes. percent:3
+TXMqttConnection publish 451  - Starting publish topic: $ota/report/AP9ZLEVFKT/gateway1 Message: {"report":{"progress":{"result_msg":"","result_code":"0","state":"downloading","percent":"3"},"version":"0.0.1"},"type":"report_progress"}
+onPublishCompleted, status[OK], topics[[$ota/report/9RW4A8OOFK/door1]],   errMsg[publish success]
+...
+TXOTAImpl run 543  - download 234775 bytes. percent:100
+TXMqttConnection publish 451  - Starting publish topic: $ota/report/9RW4A8OOFK/door1 Message: {"report":{"progress":{"result_msg":"","result_code":"0","state":"done"},"version":"0.0.1"},"type":"report_progress"}
+onPublishCompleted, status[OK], topics[[$ota/report/9RW4A8OOFK/door1]],   errMsg[publish success]
+```
+以上日志为 收到固件升级的消息 ，下载并显示下载进度，下载新版本固件成功后，上报最新的版本号，此时示例中上报的最新版本号version为0.0.1。
\ No newline at end of file
Index: iot_core/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/.gitignore	(date 1606400383008)
+++ iot_core/.gitignore	(date 1606400383008)
@@ -0,0 +1,1 @@
+/build
Index: iot_core/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/proguard-rules.pro	(date 1606400383010)
+++ iot_core/proguard-rules.pro	(date 1606400383010)
@@ -0,0 +1,25 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in E:\android_sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
Index: iot_core/gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- iot_core/gradle.properties	(date 1606400383010)
+++ iot_core/gradle.properties	(date 1606400383010)
@@ -0,0 +1,23 @@
+# 库的包名
+PROJ_GROUP=com.qcloud.iot
+# 库的ID
+PROJ_ARTIFACTID=iot-core
+# 库的版本
+PROJ_VERSION=2.1.0
+### 最后 gradle引用的形式就是 $PROJ_GROUP:$PROJ_ARTIFACTID:$PROJ_VERSION
+
+# 库名
+PROJ_NAME=IoT-Core
+# 库的项目主页
+PROJ_WEBSITEURL=https://github.com/tencentyun/qcloud-iot-sdk-android
+# 问题跟踪地址
+PROJ_ISSUETRACKERURL=https://github.com/tencentyun/qcloud-iot-sdk-android/issues
+# VCS 地址
+PROJ_VCSURL=https://github.com/tencentyun/qcloud-iot-sdk-android.git
+# 库的简单描述
+PROJ_DESCRIPTION=
+
+# 开发者的信息, 可以随意
+DEVELOPER_ID=shockcao
+DEVELOPER_NAME=Cao ShaoKun
+DEVELOPER_EMAIL=shockcao@tencent.com
\ No newline at end of file
Index: iot_core/bintray.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/bintray.gradle	(date 1606400383008)
+++ iot_core/bintray.gradle	(date 1606400383008)
@@ -0,0 +1,136 @@
+group = PROJ_GROUP
+version = PROJ_VERSION
+project.archivesBaseName = PROJ_ARTIFACTID
+
+apply plugin: 'com.jfrog.bintray'
+apply plugin: "com.jfrog.artifactory"
+apply plugin: 'maven-publish'
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.sourceFiles
+    classifier = 'sources'
+}
+
+task javadoc(type: Javadoc) {
+    options.charSet = 'UTF-8'
+    options.encoding = "UTF-8"
+    source = android.sourceSets.main.java.srcDirs
+    classpath += configurations.compile
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+}
+
+task javadocJar(type: Jar, dependsOn: javadoc) {
+    classifier = 'javadoc'
+    from javadoc.destinationDir
+}
+
+task androidJniSymbolsJar(type: Jar) {
+    classifier = 'symbols'
+    from file('obj/local/')
+    include '**/*.so'
+}
+
+javadoc {
+    options{
+        encoding "UTF-8"
+        charSet 'UTF-8'
+        author true
+        version true
+        links "http://docs.oracle.com/javase/7/docs/api"
+        title "$PROJ_NAME $PROJ_VERSION"
+    }
+}
+
+
+def pomConfig = {
+    licenses {
+        license {
+            name "MIT License"
+            url "http://opensource.org/licenses/MIT"
+            distribution "repo"
+        }
+    }
+    developers {
+        developer {
+            id DEVELOPER_ID
+            name DEVELOPER_NAME
+            email DEVELOPER_EMAIL
+        }
+    }
+}
+
+publishing {
+    publications {
+        mavenJava(MavenPublication) {
+            artifactId PROJ_ARTIFACTID
+            artifact javadocJar
+            artifact sourcesJar
+            artifact androidJniSymbolsJar
+
+            pom.withXml {
+                def root = asNode()
+                root.appendNode('description', PROJ_DESCRIPTION)
+                root.children().last() + pomConfig
+
+                def dependenciesNode = root.appendNode('dependencies')
+                configurations.compile.allDependencies.each {
+                    if (it.group && it.name && it.version) {
+                        def dependencyNode = dependenciesNode.appendNode('dependency')
+                        dependencyNode.appendNode('groupId', it.group)
+                        dependencyNode.appendNode('artifactId', it.name)
+                        dependencyNode.appendNode('version', it.version)
+                    }
+                }
+            }
+        }
+    }
+}
+
+afterEvaluate {
+    publishing.publications.mavenJava.artifact(bundleReleaseAar)
+}
+
+bintray {
+    Properties properties = new Properties()
+    if (rootProject.file("local.properties").exists()) {
+        properties.load(project.rootProject.file('local.properties').newDataInputStream())
+        user = properties.getProperty("bintray.user")
+        key = properties.getProperty("bintray.apikey")
+    }
+
+    publications = ['mavenJava']
+    publish = true
+
+    pkg {
+        repo = 'iot'
+        userOrg= 'qcloudplatform145'
+        name = PROJ_NAME
+        desc = PROJ_DESCRIPTION
+        websiteUrl = PROJ_WEBSITEURL
+        issueTrackerUrl = PROJ_ISSUETRACKERURL
+        vcsUrl = PROJ_VCSURL
+        licenses = ['MIT']
+        publicDownloadNumbers = true
+    }
+}
+
+artifactory {
+    contextUrl = 'http://oss.jfrog.org/artifactory'
+    resolve {
+        repository {
+            repoKey = 'libs-release'
+        }
+    }
+    publish {
+        repository {
+            repoKey = 'oss-snapshot-local' //The Artifactory repository key to publish to
+            username = bintray.user
+            password = bintray.key
+        }
+        defaults {
+            //这里的名字和上面红色的名字一致即可，会将其包含的输出上传到jfrog上去
+            publications('mavenJava')
+            publishArtifacts = true
+        }
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/dou361/jjdxm_ijkplayer/mqtt/MQTTRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/dou361/jjdxm_ijkplayer/mqtt/MQTTRequest.java	(date 1606839553104)
+++ app/src/main/java/com/dou361/jjdxm_ijkplayer/mqtt/MQTTRequest.java	(date 1606839553104)
@@ -0,0 +1,49 @@
+package com.dou361.jjdxm_ijkplayer.mqtt;
+
+
+public class MQTTRequest {
+
+    private static final String TAG = MQTTRequest.class.getSimpleName();
+
+    /**
+     * 请求类型
+     */
+    private String requestType = "";
+
+    /**
+     * 请求ID
+     */
+    private int requestId = 0;
+
+    public MQTTRequest() {
+    }
+
+    public MQTTRequest(String requestType, int requestId) {
+        this.requestType = requestType;
+        this.requestId = requestId;
+    }
+
+    public String getRequestType() {
+        return requestType;
+    }
+
+    public void setRequestType(String requestType) {
+        this.requestType = requestType;
+    }
+
+    public int getRequestId() {
+        return requestId;
+    }
+
+    public void setRequestId(int requestId) {
+        this.requestId = requestId;
+    }
+
+    @Override
+    public String toString() {
+        return "MQTTRequest{" +
+                "requestType='" + requestType + '\'' +
+                ", requestId=" + requestId +
+                '}';
+    }
+}
Index: iot_core/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/build.gradle	(date 1606400383009)
+++ iot_core/build.gradle	(date 1606400383009)
@@ -0,0 +1,159 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven-publish'
+apply plugin: 'signing'
+
+
+android {
+    compileSdkVersion 29
+    buildToolsVersion "26.0.3"
+
+    defaultConfig {
+        minSdkVersion 16
+        targetSdkVersion 29
+        versionCode 2
+        versionName "1.1"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+
+    sourceSets {
+        main {
+            java {
+                srcDirs - ["src/main/java", "src/main/aidl"]
+            }
+            jni {
+                srcDir "src/main/jni"
+            }
+        }
+    }
+    lintOptions {
+        abortOnError false
+    }
+}
+
+task androidJavadocs(type: Javadoc) {
+    failOnError false
+    source = android.sourceSets.main.java.srcDirs
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+    android.libraryVariants.all { variant ->
+        if (variant.name == 'release') {
+            owner.classpath += variant.javaCompile.classpath
+        }
+    }
+    exclude '**/R.html', '**/R.*.html', '**/index.html'
+}
+
+task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+    classifier = 'javadoc'
+    from androidJavadocs.destinationDir
+}
+
+task androidSourcesJar(type: Jar) {
+    classifier = 'sources'
+    from android.sourceSets.main.java.srcDirs
+}
+
+def libVersion = '3.2.1-SNAPSHOT'
+ext.isReleaseVersion = !libVersion.endsWith("SNAPSHOT")
+publishing {
+    publications {
+        aar(MavenPublication) {
+            groupId 'com.tencent.iot.hub'
+            artifactId 'hub-device-android-core'
+            version libVersion
+            artifact(androidSourcesJar)
+            artifact(androidJavadocsJar)
+            artifact file('build/outputs/aar/iot_core-release.aar')
+
+            pom {
+                name = 'hub device android core'
+                description = 'Hub Device Android Core library'
+                url = 'https://github.com/tencentyun/iot-device-java/tree/master/hub-device-android'
+                licenses {
+                    license {
+                        name = 'Tencent Binary License'
+                        url = 'https://github.com/tencentyun/iot-device-java/blob/master/hub-device-android/LICENSE'
+                    }
+                }
+                developers {
+                    developer {
+                        id = 'tencent_archurtan'
+                        name = 'Tencent archurtan'
+                        email = 'archurtan@tencent.com'
+                    }
+                }
+                scm {
+                    url = 'scm:git@github.com:tencentyun/iot-device-java.git'
+                    connection = 'scm:git@github.com:tencentyun/iot-device-java.git'
+                    developerConnection = 'scm:git@github.com:tencentyun/iot-device-java.git'
+                }
+            }
+
+            pom.withXml {
+                def dependenciesNode = asNode().appendNode('dependencies')
+                configurations.implementation.allDependencies.withType(ModuleDependency) { ModuleDependency dp ->
+                    if (dp.version != "unspecified") {
+                        def dependencyNode = dependenciesNode.appendNode('dependency')
+                        dependencyNode.appendNode('groupId', dp.group)
+                        dependencyNode.appendNode('artifactId', dp.name)
+                        dependencyNode.appendNode('version', dp.version)
+
+                        // for exclusions
+                        if (dp.excludeRules.size() > 0) {
+                            def exclusions = dependencyNode.appendNode('exclusions')
+                            dp.excludeRules.each { ExcludeRule ex ->
+                                def exclusion = exclusions.appendNode('exclusion')
+                                exclusion.appendNode('groupId', ex.group)
+                                exclusion.appendNode('artifactId', ex.module)
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    repositories {
+        maven {
+            def releasesRepoUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2"
+            def snapshotsRepoUrl = "https://oss.sonatype.org/content/repositories/snapshots"
+            url = libVersion.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
+            credentials {
+                username = System.getenv("IOT_SONATYPE_USERNAME")
+                password = System.getenv("IOT_SONATYPE_PASSWORD")
+            }
+        }
+    }
+}
+
+dependencies {
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+        exclude group: 'com.android.support', module: 'support-annotations'
+    })
+    //noinspection GradleCompatible
+    implementation 'com.android.support:appcompat-v7:26.1.0'
+    testImplementation 'junit:junit:4.13'
+
+    implementation 'org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.3'
+    implementation "com.squareup.okhttp3:okhttp:3.12.2"
+    implementation 'org.bouncycastle:bcprov-jdk15on:1.65'
+    implementation 'org.bouncycastle:bcpkix-jdk15on:1.65'
+    if (findProject(':hub-device-java') != null) {
+        implementation project(path: ':hub-device-java')
+    } else {
+        implementation 'com.tencent.iot.hub:hub-device-java:1.0.0'
+    }
+}
+
+signing {
+    if (isReleaseVersion) {
+        sign publishing.publications.aar
+    }
+}
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"Encoding\">\r\n    <file url=\"PROJECT\" charset=\"UTF-8\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/encodings.xml	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ .idea/encodings.xml	(date 1606843501196)
@@ -1,6 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="Encoding">
+    <file url="file://$PROJECT_DIR$/build.gradle" charset="GBK" />
+    <file url="file://$PROJECT_DIR$/hub-device-java/src/main/java/com/tencent/iot/hub/device/java/App.java" charset="GBK" />
+    <file url="file://$PROJECT_DIR$/iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttService.java" charset="GBK" />
     <file url="PROJECT" charset="UTF-8" />
   </component>
 </project>
\ No newline at end of file
Index: iot_service/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/res/values/strings.xml	(date 1606400383035)
+++ iot_service/src/main/res/values/strings.xml	(date 1606400383035)
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">iot_service</string>
+</resources>
Index: iot_core/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/res/values/strings.xml	(date 1606400383023)
+++ iot_core/src/main/res/values/strings.xml	(date 1606400383023)
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">iot_core</string>
+</resources>
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"NullableNotNullManager\">\r\n    <option name=\"myDefaultNullable\" value=\"android.support.annotation.Nullable\" />\r\n    <option name=\"myDefaultNotNull\" value=\"android.support.annotation.NonNull\" />\r\n    <option name=\"myNullables\">\r\n      <value>\r\n        <list size=\"15\">\r\n          <item index=\"0\" class=\"java.lang.String\" itemvalue=\"org.jetbrains.annotations.Nullable\" />\r\n          <item index=\"1\" class=\"java.lang.String\" itemvalue=\"javax.annotation.Nullable\" />\r\n          <item index=\"2\" class=\"java.lang.String\" itemvalue=\"edu.umd.cs.findbugs.annotations.Nullable\" />\r\n          <item index=\"3\" class=\"java.lang.String\" itemvalue=\"android.support.annotation.Nullable\" />\r\n          <item index=\"4\" class=\"java.lang.String\" itemvalue=\"javax.annotation.CheckForNull\" />\r\n          <item index=\"5\" class=\"java.lang.String\" itemvalue=\"androidx.annotation.Nullable\" />\r\n          <item index=\"6\" class=\"java.lang.String\" itemvalue=\"android.annotation.Nullable\" />\r\n          <item index=\"7\" class=\"java.lang.String\" itemvalue=\"androidx.annotation.RecentlyNullable\" />\r\n          <item index=\"8\" class=\"java.lang.String\" itemvalue=\"org.checkerframework.checker.nullness.qual.Nullable\" />\r\n          <item index=\"9\" class=\"java.lang.String\" itemvalue=\"org.checkerframework.checker.nullness.compatqual.NullableDecl\" />\r\n          <item index=\"10\" class=\"java.lang.String\" itemvalue=\"org.checkerframework.checker.nullness.compatqual.NullableType\" />\r\n          <item index=\"11\" class=\"java.lang.String\" itemvalue=\"com.android.annotations.Nullable\" />\r\n          <item index=\"12\" class=\"java.lang.String\" itemvalue=\"org.eclipse.jdt.annotation.Nullable\" />\r\n          <item index=\"13\" class=\"java.lang.String\" itemvalue=\"io.reactivex.annotations.Nullable\" />\r\n          <item index=\"14\" class=\"java.lang.String\" itemvalue=\"io.reactivex.rxjava3.annotations.Nullable\" />\r\n        </list>\r\n      </value>\r\n    </option>\r\n    <option name=\"myNotNulls\">\r\n      <value>\r\n        <list size=\"14\">\r\n          <item index=\"0\" class=\"java.lang.String\" itemvalue=\"org.jetbrains.annotations.NotNull\" />\r\n          <item index=\"1\" class=\"java.lang.String\" itemvalue=\"javax.annotation.Nonnull\" />\r\n          <item index=\"2\" class=\"java.lang.String\" itemvalue=\"edu.umd.cs.findbugs.annotations.NonNull\" />\r\n          <item index=\"3\" class=\"java.lang.String\" itemvalue=\"android.support.annotation.NonNull\" />\r\n          <item index=\"4\" class=\"java.lang.String\" itemvalue=\"androidx.annotation.NonNull\" />\r\n          <item index=\"5\" class=\"java.lang.String\" itemvalue=\"android.annotation.NonNull\" />\r\n          <item index=\"6\" class=\"java.lang.String\" itemvalue=\"androidx.annotation.RecentlyNonNull\" />\r\n          <item index=\"7\" class=\"java.lang.String\" itemvalue=\"org.checkerframework.checker.nullness.qual.NonNull\" />\r\n          <item index=\"8\" class=\"java.lang.String\" itemvalue=\"org.checkerframework.checker.nullness.compatqual.NonNullDecl\" />\r\n          <item index=\"9\" class=\"java.lang.String\" itemvalue=\"org.checkerframework.checker.nullness.compatqual.NonNullType\" />\r\n          <item index=\"10\" class=\"java.lang.String\" itemvalue=\"com.android.annotations.NonNull\" />\r\n          <item index=\"11\" class=\"java.lang.String\" itemvalue=\"org.eclipse.jdt.annotation.NonNull\" />\r\n          <item index=\"12\" class=\"java.lang.String\" itemvalue=\"io.reactivex.annotations.NonNull\" />\r\n          <item index=\"13\" class=\"java.lang.String\" itemvalue=\"io.reactivex.rxjava3.annotations.NonNull\" />\r\n        </list>\r\n      </value>\r\n    </option>\r\n  </component>\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" default=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/build/classes\" />\r\n  </component>\r\n  <component name=\"ProjectType\">\r\n    <option name=\"id\" value=\"Android\" />\r\n  </component>\r\n  <component name=\"masterDetails\">\r\n    <states>\r\n      <state key=\"ScopeChooserConfigurable.UI\">\r\n        <settings>\r\n          <splitter-proportions>\r\n            <option name=\"proportions\">\r\n              <list>\r\n                <option value=\"0.2\" />\r\n              </list>\r\n            </option>\r\n          </splitter-proportions>\r\n        </settings>\r\n      </state>\r\n    </states>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ .idea/misc.xml	(date 1606840884014)
@@ -45,7 +45,7 @@
       </value>
     </option>
   </component>
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_7" default="false" project-jdk-name="1.8" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
   <component name="ProjectType">
Index: iot_core/src/main/aidl/com/tencent/iot/hub/device/android/core/shadow/DeviceProperty.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/aidl/com/tencent/iot/hub/device/android/core/shadow/DeviceProperty.aidl	(date 1606400383015)
+++ iot_core/src/main/aidl/com/tencent/iot/hub/device/android/core/shadow/DeviceProperty.aidl	(date 1606400383015)
@@ -0,0 +1,3 @@
+package com.tencent.iot.hub.device.android.core.shadow;
+
+parcelable DeviceProperty;
\ No newline at end of file
Index: iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttMessage.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttMessage.aidl	(date 1606400383031)
+++ iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttMessage.aidl	(date 1606400383031)
@@ -0,0 +1,4 @@
+// parcelable TXMqttMessage.aidl
+package com.tencent.iot.hub.device.android.service;
+
+parcelable TXMqttMessage;
Index: iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttToken.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttToken.aidl	(date 1606400383031)
+++ iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttToken.aidl	(date 1606400383031)
@@ -0,0 +1,4 @@
+// parcelable TXMqttToken.aidl
+package com.tencent.iot.hub.device.android.service;
+
+parcelable TXMqttToken;
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"CompilerConfiguration\">\r\n    <bytecodeTargetLevel target=\"1.8\">\r\n      <module name=\"zz_ijkplayer-master.hub-device-android.hub-demo\" target=\"1.8\" />\r\n      <module name=\"zz_ijkplayer-master.hub-device-android.iot_core\" target=\"1.8\" />\r\n      <module name=\"zz_ijkplayer-master.hub-device-android.iot_service\" target=\"1.8\" />\r\n      <module name=\"zz_ijkplayer-master.iot_core\" target=\"1.8\" />\r\n      <module name=\"zz_ijkplayer-master.iot_service\" target=\"1.8\" />\r\n    </bytecodeTargetLevel>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/compiler.xml	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ .idea/compiler.xml	(date 1606840884036)
@@ -1,12 +1,14 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CompilerConfiguration">
-    <bytecodeTargetLevel target="1.8">
+    <bytecodeTargetLevel target="1.7">
+      <module name="zz_ijkplayer-master.app" target="1.8" />
       <module name="zz_ijkplayer-master.hub-device-android.hub-demo" target="1.8" />
       <module name="zz_ijkplayer-master.hub-device-android.iot_core" target="1.8" />
       <module name="zz_ijkplayer-master.hub-device-android.iot_service" target="1.8" />
       <module name="zz_ijkplayer-master.iot_core" target="1.8" />
       <module name="zz_ijkplayer-master.iot_service" target="1.8" />
+      <module name="zz_ijkplayer-master.jjdxm-ijkplayer" target="1.8" />
     </bytecodeTargetLevel>
   </component>
 </project>
\ No newline at end of file
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"GradleMigrationSettings\" migrationVersion=\"1\" />\r\n  <component name=\"GradleSettings\">\r\n    <option name=\"linkedExternalProjectsSettings\">\r\n      <GradleProjectSettings>\r\n        <option name=\"testRunner\" value=\"PLATFORM\" />\r\n        <option name=\"distributionType\" value=\"DEFAULT_WRAPPED\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"modules\">\r\n          <set>\r\n            <option value=\"$PROJECT_DIR$\" />\r\n            <option value=\"$PROJECT_DIR$/app\" />\r\n            <option value=\"$PROJECT_DIR$/jjdxm-ijkplayer\" />\r\n          </set>\r\n        </option>\r\n        <option name=\"resolveModulePerSourceSet\" value=\"false\" />\r\n        <option name=\"useQualifiedModuleNames\" value=\"true\" />\r\n      </GradleProjectSettings>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/gradle.xml	(revision a1e11d489dc470917b01aa3a278ed8a97982f1e3)
+++ .idea/gradle.xml	(date 1606840884061)
@@ -11,6 +11,9 @@
           <set>
             <option value="$PROJECT_DIR$" />
             <option value="$PROJECT_DIR$/app" />
+            <option value="$PROJECT_DIR$/hub-device-java" />
+            <option value="$PROJECT_DIR$/iot_core" />
+            <option value="$PROJECT_DIR$/iot_service" />
             <option value="$PROJECT_DIR$/jjdxm-ijkplayer" />
           </set>
         </option>
Index: iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttConnectOptions.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttConnectOptions.aidl	(date 1606400383030)
+++ iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttConnectOptions.aidl	(date 1606400383030)
@@ -0,0 +1,4 @@
+// TXMqttConnectOptions.aidl
+package com.tencent.iot.hub.device.android.service;
+
+parcelable TXMqttConnectOptions;
Index: iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttClientOptions.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttClientOptions.aidl	(date 1606400383030)
+++ iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXMqttClientOptions.aidl	(date 1606400383030)
@@ -0,0 +1,4 @@
+// TXMqttClientOptions.aidl
+package com.tencent.iot.hub.device.android.service;
+
+parcelable TXMqttClientOptions;
Index: iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXOTAListener.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXOTAListener.aidl	(date 1606400383029)
+++ iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXOTAListener.aidl	(date 1606400383029)
@@ -0,0 +1,41 @@
+// ITXMqttListener.aidl
+package com.tencent.iot.hub.device.android.service;
+
+import com.tencent.iot.hub.device.android.service.TXMqttMessage;
+import com.tencent.iot.hub.device.android.service.TXMqttToken;
+
+interface ITXOTAListener {
+
+    /**
+     * 上报固件版本回调
+     *
+     * @param resultCode  上报结果码；0：成功；其它：失败
+     * @param version  版本；
+     * @param resultMsg  上报结果码描述
+     */
+    void onReportFirmwareVersion(int resultCode, String version, String resultMsg);
+
+    /**
+    * OTA升级包下载进度回调
+    *
+    * @param percent  下载进度（0 ~ 100）;
+    * @param version  版本；
+    */
+    void onDownloadProgress(int percent, String version);
+
+    /**
+    * OTA升级包下载完成回调
+    * @param outputFile  已下载完成的升级包文件名（包含全路径）；
+    * @param version  版本；
+    */
+    void onDownloadCompleted(String outputFile, String version);
+
+    /**
+    * OTA升级包下载失败回调
+    *
+    * @param errCode  失败错误码; -1: 下载超时; -2:文件不存在；-3:签名过期；-4:校验错误；
+    * @param version  版本；
+    */
+    void onDownloadFailure(int errCode, String version);
+
+}
Index: iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXMqttService.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXMqttService.aidl	(date 1606400383029)
+++ iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXMqttService.aidl	(date 1606400383029)
@@ -0,0 +1,153 @@
+// ITXMqttService.aidl
+package com.tencent.iot.hub.device.android.service;
+
+import com.tencent.iot.hub.device.android.service.TXDisconnectedBufferOptions;
+import com.tencent.iot.hub.device.android.service.ITXMqttActionListener;
+import com.tencent.iot.hub.device.android.service.ITXOTAListener;
+import com.tencent.iot.hub.device.android.service.ITXShadowActionListener;
+import com.tencent.iot.hub.device.android.service.TXMqttConnectOptions;
+import com.tencent.iot.hub.device.android.service.TXMqttClientOptions;
+import com.tencent.iot.hub.device.android.service.TXMqttMessage;
+import com.tencent.iot.hub.device.android.core.shadow.DeviceProperty;
+
+interface ITXMqttService {
+    /**
+     * 注册mqttAction监听器
+     */
+    void registerMqttActionListener(in ITXMqttActionListener mqttActionListener);
+
+    /**
+     * 注册shadowAction监听器
+     */
+    void registerShadowActionListener(in ITXShadowActionListener shadowActionListener);
+
+    /**
+     * 初始化设备信息
+     * @param clientOptions  客户端选项
+     */
+    void initDeviceInfo(in TXMqttClientOptions clientOptions);
+
+    /**
+     * 设置断连状态buffer缓冲区
+     */
+    void setBufferOpts(in TXDisconnectedBufferOptions bufferOptions);
+
+    /**
+     * 连接MQTT
+     * @param  options
+     * @param  userContextId
+     * @return status
+     */
+    String connect(in TXMqttConnectOptions options, in long userContextId);
+
+    /**
+     * 重新连接
+     */
+    String reconnect();
+
+    /**
+     * MQTT断连
+     * @param timeout       等待时间（必须>0）。单位：毫秒
+     * @param userContextId 用户上下文
+     */
+    String disConnect(in long timeout, in long userContextId);
+
+    /**
+     * 订阅广播主题
+     * @param qos
+     * @param userContextId
+     */
+    String subscribeBroadcastTopic(in int qos, in long userContextId);
+
+    /**
+     * 订阅主题
+     * @param topic
+     * @param qos
+     * @param userContextId
+     */
+    String subscribe(in String topic, in int qos, in long userContextId);
+
+    /**
+     * 取消订阅主题
+     */
+    String unSubscribe(in String topic, in long userContextId);
+
+    /**
+     * 发布主题
+     * @param topic
+     * @param message
+     * @param userContextId
+     */
+    String publish(in String topic, in TXMqttMessage message, in long userContextId);
+
+    /**
+     * 订阅RRPC主题
+     * @param qos
+     * @param userContextId
+     */
+    String subscribeRRPCTopic(in int qos, in long userContextId);
+
+    /**
+     * 获取连接状态
+     *
+     * @return 连接状态
+     */
+    String getConnectStatus();
+
+    /**
+     * 获取设备影子文档
+     */
+    String getShadow(in long userContextId);
+
+    /**
+     * 更新设备影子文档
+     * @param devicePropertyList
+     * @param userContextId
+     */
+    String updateShadow(in List<DeviceProperty> devicePropertyList, in long userContextId);
+
+    /**
+     * 注册设备属性
+     * @param deviceProperty
+     */
+    void registerDeviceProperty(in DeviceProperty deviceProperty);
+
+    /**
+     * 取消注册设备属性
+     * @param deviceProperty
+     */
+    void unRegisterDeviceProperty(in DeviceProperty deviceProperty);
+
+    /**
+     * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息
+     * @param reportJsonDoc 用户上报的JSON内容
+     */
+    String reportNullDesiredInfo(String reportJsonDoc);
+
+    /**
+     * 初始化OTA功能。
+     *
+     * @param storagePath OTA升级包存储路径(调用者必须确保路径已存在，并且具有写权限)
+     * @param listener    OTA事件回调
+     */
+    void initOTA(String storagePath, in ITXOTAListener listener);
+
+    /**
+     * 上报设备当前版本信息到后台服务器。
+     *
+     * @param currentFirmwareVersion 设备当前版本信息
+     * @return 发送成功时返回字符串"OK"; 其它返回值表示发送失败；
+     */
+    String reportCurrentFirmwareVersion(String currentFirmwareVersion);
+
+     /**
+     * 上报设备升级状态到后台服务器。
+     *
+     * @param state 状态
+     * @param resultCode 结果代码。0：表示成功；其它：表示失败；常见错误码：-1: 下载超时; -2:文件不存在；-3:签名过期；-4:校验错误；-5：更新固件失败
+     * @param resultMsg 结果描述
+     * @param version 版本号
+     * @return 发送成功时返回字符串"OK"; 其它返回值表示发送失败；
+     */
+    String reportOTAState(String state, int resultCode, String resultMsg, String version);
+}
Index: iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXDisconnectedBufferOptions.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXDisconnectedBufferOptions.aidl	(date 1606400383030)
+++ iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/TXDisconnectedBufferOptions.aidl	(date 1606400383030)
@@ -0,0 +1,4 @@
+// parcelable TXDisconnectedBufferOptions.aidl
+package com.tencent.iot.hub.device.android.service;
+
+parcelable TXDisconnectedBufferOptions;
Index: iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXShadowActionListener.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXShadowActionListener.aidl	(date 1606400383029)
+++ iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXShadowActionListener.aidl	(date 1606400383029)
@@ -0,0 +1,61 @@
+// ITXShadowListener.aidl
+package com.tencent.iot.hub.device.android.service;
+
+import com.tencent.iot.hub.device.android.service.TXMqttMessage;
+import com.tencent.iot.hub.device.android.service.TXMqttToken;
+import com.tencent.iot.hub.device.android.core.shadow.DeviceProperty;
+
+interface ITXShadowActionListener {
+
+    /**
+     * 文档请求响应的回调接口
+     *
+     * @param type     文档操作方式, get/update/delete
+     * @param result   请求响应结果, 0: 成功；非0：失败
+     * @param document 云端返回的JSON文档
+     */
+    void onRequestCallback(String type, int result, String document);
+
+    /**
+     * 设备属性处理回调接口
+     *
+     * @param propertyJSONDocument 设备属性json文档
+     * @param devicePropertyList   更新后的设备属性集
+     */
+    void onDevicePropertyCallback(String propertyJSONDocument, out List<DeviceProperty> devicePropertyList);
+
+    /**
+     * 发布消息完成回调
+     *
+     * @param status OK: 发布消息成功，ERROR: 发布消息失败
+     * @param token  消息token
+     * @param errMsg 详细信息
+     */
+    void onPublishCompleted(String status, inout TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 订阅主题完成回调
+     *
+     * @param status     OK: 订阅成功，ERROR: 订阅失败
+     * @param token      消息token
+     * @param errMsg     详细信息
+     */
+    void onSubscribeCompleted(String status, inout TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 取消订阅主题完成回调
+     *
+     * @param status    OK: 取消订阅成功，ERROR: 取消订阅失败
+     * @param token     消息token，包含消息内容结构体
+     * @param errMsg    详细信息
+     */
+    void onUnSubscribeCompleted(String status, inout TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 收到订阅主题的消息Push
+     *
+     * @param topic   主题名称
+     * @param message 消息内容
+     */
+    void onMessageReceived(String topic, inout TXMqttMessage message);
+}
Index: iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXMqttActionListener.aidl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXMqttActionListener.aidl	(date 1606400383029)
+++ iot_service/src/main/aidl/com/tencent/iot/hub/device/android/service/ITXMqttActionListener.aidl	(date 1606400383029)
@@ -0,0 +1,78 @@
+// ITXMqttListener.aidl
+package com.tencent.iot.hub.device.android.service;
+
+import com.tencent.iot.hub.device.android.service.TXMqttMessage;
+import com.tencent.iot.hub.device.android.service.TXMqttToken;
+
+interface ITXMqttActionListener {
+
+    /**
+     * MQTT Connect完成回调
+     *
+     * @param status    OK: 连接成功        ERROR: 连接失败
+     * @param reconnect true: 重新连接      false: 首次连接
+     * @param msg       连接信息
+     */
+    void onConnectCompleted(String status, boolean reconnect, long userContextId, String msg);
+
+    /**
+     * MQTT连接断开回调
+     *
+     * @param cause 连接断开原因
+     */
+    void onConnectionLost(String cause);
+
+    /**
+     * MQTT Disconnect完成回调
+     *
+     * @param status OK: 断连成功，ERROR: 断连失败
+     * @param msg    相信信息
+     */
+    void onDisconnectCompleted(String status, long userContextId, String msg);
+
+    /**
+     * 发布消息完成回调
+     *
+     * @param status OK: 发布消息成功，ERROR: 发布消息失败
+     * @param token  消息token
+     * @param errMsg 详细信息
+     */
+    void onPublishCompleted(String status, inout TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 订阅主题完成回调
+     *
+     * @param status  OK: 订阅成功，ERROR: 订阅失败
+     * @param token   消息token
+     * @param errMsg  详细信息
+     */
+    void onSubscribeCompleted(String status, inout TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 取消订阅主题完成回调
+     *
+     * @param status    OK: 取消订阅成功，ERROR: 取消订阅失败
+     * @param token     消息token
+     * @param errMsg    详细信息
+     */
+    void onUnSubscribeCompleted(String status, inout TXMqttToken token, long userContextId, String errMsg);
+
+    /**
+     * 收到订阅主题的消息Push
+     *
+     * @param topic   主题名称
+     * @param message 消息内容
+     */
+    void onMessageReceived(String topic, inout TXMqttMessage message);
+
+    /**
+     * 远程服务已启动回调接口
+     */
+    void onServiceStartedCallback();
+
+    /**
+     * 远程服务销毁回调接口
+     */
+    void onServiceDestroyCallback();
+
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLogCallBack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLogCallBack.java	(date 1606400383018)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLogCallBack.java	(date 1606400383018)
@@ -0,0 +1,37 @@
+package com.tencent.iot.hub.device.android.core.log;
+
+public abstract class  TXMqttLogCallBack {
+
+    /**
+     * 打印生成的日志和调试信息
+     * @param message 打印的信息
+     */
+    public abstract void printDebug(String message);
+
+    /**
+     * 设置密钥
+     * @return 返回密钥
+     */
+    public abstract String setSecretKey();
+
+    /**
+     * 断线时保存日志
+     * @param log 日志
+     * @return 返回存储的日志长度
+     */
+    public abstract boolean saveLogOffline(String log);
+
+
+    /**
+     * 读取断线时保存的日志
+     * @return 返回读取的日志内容
+     */
+    public abstract String readOfflineLog();
+
+    /**
+     * 删除断线时保存的日志
+     * @return 删除成功返回true，失败返回false
+     */
+    public abstract boolean delOfflineLog();
+
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLogImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLogImpl.java	(date 1606400383019)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLogImpl.java	(date 1606400383019)
@@ -0,0 +1,188 @@
+package com.tencent.iot.hub.device.android.core.log;
+
+import com.tencent.iot.hub.device.android.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.android.core.util.HmacSha1;
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+
+import java.io.IOException;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.TimeUnit;
+
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+public class TXMqttLogImpl {
+
+    public static final String TAG = TXMqttLogImpl.class.getName();
+
+    /**
+     * 定时上传时间：单位ms，30S一次
+     */
+    private long timeInterval = 30000;
+
+    /**
+     * 日志队列，容量10000条日志，剩余容量低于四分之一时触发一次日志上传
+     */
+    private LinkedBlockingDeque<String> logDeque;
+    private static int dequeSize = 10000; //最大容量10000条日志
+    private static int dequeThreshold = dequeSize/4; //剩余容量预警阈值
+
+    /**
+     * http客户端，用于上传日志到服务器
+     */
+    private OkHttpClient mOkHttpClient;
+
+    /**http 服务器 URL*/
+    private static final String MQTT_LOG_UPLOAD_SERVER_URL =  "http://devicelog.iot.cloud.tencent.com:80/cgi-bin/report-log";
+
+    /**Content Type*/
+    private static final MediaType MEDIA_TYPE_LOG = MediaType.parse("text/plain;charset=utf-8");
+
+    /**
+     * 固定头部
+     * 格式：[鉴权类型（1字符，C代表证书方式，P代表PSK方式）][预留（3字符，填充#）][产品ID（10字符，不足后面补#）][设备ID（48字符，不足后面补#）]
+     */
+    private String mFixedHead;
+
+    /**
+     * 签名密钥,最多保留24位
+     */
+    private String mSecretKey;
+
+    /**
+     * 上传标志，true表示立刻上传
+     */
+    private boolean mUploadFlag;
+
+    /**
+     * 日志上传回调函数，用于离线下的日志存储和上线后的日志上传
+     */
+    private TXMqttLogCallBack mMqttLogCallBack;
+
+    TXMqttLogImpl(TXMqttConnection mqttConnection) {
+        this.mOkHttpClient =  new OkHttpClient().newBuilder().connectTimeout(1, TimeUnit.SECONDS).build();
+        this.logDeque = new LinkedBlockingDeque<String>(dequeSize);
+        //固定头部格式：[鉴权类型（1字符，C代表证书方式，P代表PSK方式）][预留（3字符，填充#）][产品ID（10字符，不足后面补#）][设备ID（48字符，不足后面补#）]
+        this.mFixedHead = String.format("%c###%s%s",
+                mqttConnection.mSecretKey == null ? 'C' : 'P',
+                String.format("%-10s",mqttConnection.mProductId).replace(" ","#"),
+                String.format("%-48s", mqttConnection.mDeviceName).replace(" ","#")
+        );
+        this.mUploadFlag = false;
+        this.mMqttLogCallBack = mqttConnection.mMqttLogCallBack;
+        this.mSecretKey = mMqttLogCallBack.setSecretKey();
+        new UploaderToServer().start();
+    }
+
+    /**
+     * 完成日志上传的操作
+     */
+    class UploaderToServer extends Thread {
+        @Override
+        public void run() {
+
+            long nowCurrentMillis = System.currentTimeMillis();
+
+            while (true) {
+                if (mUploadFlag || (logDeque.size() > dequeSize - dequeThreshold)
+                    || (nowCurrentMillis < System.currentTimeMillis()- timeInterval)) {
+
+                    if (logDeque.size() == 0) {
+                        nowCurrentMillis = System.currentTimeMillis();
+                        mUploadFlag = false;
+                        continue;
+                    }
+
+                    StringBuffer log = new StringBuffer();
+
+                    //获取所有的log
+                    try {
+                        while (logDeque.size() > 0)
+                            log.append(logDeque.take());
+                    } catch (Exception e) {
+                        mMqttLogCallBack.printDebug( "Take log from deque failed");
+                    }
+
+                    //格式为[签名][固定头部][时间戳（10位）][日志]
+                    String payLoad = String.format("%s%s%s", mFixedHead, String.valueOf(System.currentTimeMillis()).substring(0, 10), log.toString());
+                    payLoad = HmacSha1.getSignature(payLoad.getBytes(), mSecretKey.getBytes()) + payLoad;
+
+                    Request request = new Request.Builder()
+                            .url(MQTT_LOG_UPLOAD_SERVER_URL)
+                            .post(RequestBody.create(MEDIA_TYPE_LOG, payLoad))
+                            .build();
+
+                    //发送请求
+                    try {
+                        Response response = mOkHttpClient.newCall(request).execute();
+                        if(!response.isSuccessful()) {
+                            mMqttLogCallBack.printDebug(String.format("Upload log to %s failed! Response:[%s]",MQTT_LOG_UPLOAD_SERVER_URL,response.body().string()));
+                        } else {
+                            mMqttLogCallBack.printDebug(String.format("Upload log to %s success!",MQTT_LOG_UPLOAD_SERVER_URL));
+                        }
+                    } catch (IOException e) {
+                        mMqttLogCallBack.saveLogOffline(log.toString()); //存在文本中
+                        mMqttLogCallBack.printDebug(String.format("Lost Connection! Call mMqttCallBack.saveLogOffline()"));
+                    }
+
+                    nowCurrentMillis = System.currentTimeMillis();
+                    mUploadFlag = false;
+
+                    //TXLog.i(TAG, "log upload :%s", log);
+                }
+
+                try {
+                    Thread.sleep(10); //休眠10ms
+                } catch (InterruptedException e) {
+                    TXLog.w(TAG, "The thread has been interrupted");
+                }
+            }
+        }
+    }
+
+    /**
+     * 添加日志到队列中，如果队列空间不足则上传
+     * @param log 日志
+     * @return 添加成功，返回true，添加失败，返回false
+     */
+    boolean appendToLogDeque(String log) {
+        try {
+            logDeque.add(log);
+            mMqttLogCallBack.printDebug(String.format("Add log to log Deque! %s",log).replace("\n\f",""));
+            return true;
+        } catch (Exception e) {
+            mMqttLogCallBack.printDebug(String.format("Add log to log Deque failed! %s" ,log).replace("\n\f",""));
+            return false;
+        }
+    }
+
+    /**
+     * 触发一次日志上传
+     */
+    void uploadMqttLog() {
+        mUploadFlag = true;
+    }
+
+    /**
+     * 上传离线日志
+     */
+    void uploadOfflineLog() {
+        String offlineLog = mMqttLogCallBack.readOfflineLog();
+        if (offlineLog != null) {
+            appendToLogDeque(offlineLog);
+            mMqttLogCallBack.delOfflineLog();
+        }
+        mUploadFlag = true;
+    }
+
+    /**
+     * 清空队列
+     */
+    void resetLogDeque() {
+        logDeque.clear();
+    }
+
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLog.java	(date 1606400383018)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLog.java	(date 1606400383018)
@@ -0,0 +1,140 @@
+package com.tencent.iot.hub.device.android.core.log;
+
+import android.text.TextUtils;
+
+import com.tencent.iot.hub.device.android.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.text.SimpleDateFormat;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class TXMqttLog {
+
+    public static final String TAG = TXMqttLog.class.getName();
+
+    private TXMqttLogImpl mqttLogImp;
+
+    private  TXMqttConnection mMqttConnection;
+
+    public static final String level_str[] = new String[] {"ERR", "ERR", "WRN", "INF", "DBG"};
+    private  int mLogLevel = TXMqttLogConstants.LEVEL_FATAL;
+
+    private static final String LOG_OPERATION_PREFIX = "$log/operation/";
+    private static final String LOG_OPERATION_RES_PREFIX = "$log/operation/result/";
+
+    private static final String CLIENT_TOKEN = "%s-%d";
+    private AtomicInteger mClientTokenNum = new AtomicInteger(0);
+
+    public TXMqttLog(TXMqttConnection mqttConnection) {
+        this.mMqttConnection = mqttConnection;
+        this.mqttLogImp = new TXMqttLogImpl(mqttConnection);
+    }
+
+    /**
+     * 日志上传初始化，订阅指令下行topic，向数据上行topic发布消息
+     * @return 初始化成功时返回Status.OK; 其它返回值表示初始化失败；
+     */
+    public Status initMqttLog() {
+        //初始化之前处理上次的离线日志
+        mqttLogImp.uploadOfflineLog();
+
+        Status status;
+        status = subscribeLogResultTopic(mMqttConnection);
+        if (status != Status.OK) {
+            return status;
+        }
+        return publishLogLevelGet(mMqttConnection);
+    }
+
+    /**
+     * 设置日志级别，在接受消息回调函数中调用
+     * @param logLevel 日志等级
+     */
+    public void setMqttLogLevel(int logLevel) {
+        this.mLogLevel = logLevel;
+    }
+
+    /**
+     * 将一条日志保存到日志队列中
+     */
+    public boolean saveMqttLog(final int logLevel, final String tag, final String format, final Object... obj) {
+        //低于设置日志信息等级的信息不存储
+        if(mMqttConnection != null && logLevel <= mLogLevel) {
+            String log = buildMqttLog(logLevel, tag, format, obj);
+            return mqttLogImp.appendToLogDeque(log);
+        }
+        return false;
+    }
+
+    /**
+     * 触发一次日志上传
+     */
+    public void uploadMqttLog() {
+        mqttLogImp.uploadMqttLog();
+    }
+
+    /**
+     * 构造一条日志消息
+     * 格式：[日志内容（每行日志格式为"LEVEL|DATETIME|TAG|CONTENT"，行与行之间采用"\n\f,"分隔）]”
+     */
+    private String buildMqttLog(final int logLevel,final String tag,final String format, final Object... obj) {
+        long nowCurrentMillis = System.currentTimeMillis();
+        SimpleDateFormat timeFormatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+        String logTime = timeFormatter.format(nowCurrentMillis);
+        String log = obj == null ? format : String.format(format, obj);
+        if (log == null) {
+            log = "";
+        }
+
+        return String.format("%s|%s|%s|%s\n\f", level_str[logLevel], logTime, tag, log);
+    }
+
+    /**
+     * 订阅指令上行topic
+     */
+    private Status subscribeLogResultTopic(TXMqttConnection mqttConnection) {
+        String topic = LOG_OPERATION_RES_PREFIX + mqttConnection.mProductId + "/" + mqttConnection.mDeviceName;
+        int qos = TXMqttConstants.QOS0;
+        return mqttConnection.subscribe(topic, qos, "Subscribe Log result topic");
+    }
+
+    /**
+     * 发布消息给数据上行topic
+     */
+    private Status publishLogLevelGet(TXMqttConnection mqttConnection) {
+        String topic = LOG_OPERATION_PREFIX + mqttConnection.mProductId + "/" + mqttConnection.mDeviceName;
+
+        String clientToken = String.format(CLIENT_TOKEN, mqttConnection.mClientId, mClientTokenNum.getAndIncrement());
+        String jsonDocument = buildGetJsonDocument(clientToken);
+
+        MqttMessage mqttMessage = new MqttMessage();
+        if (!TextUtils.isEmpty(jsonDocument)) {
+            mqttMessage.setPayload(jsonDocument.getBytes());
+        }
+        mqttMessage.setQos(TXMqttConstants.QOS0);
+
+        return  mqttConnection.publish(topic, mqttMessage, "Publish GET message");
+    }
+
+    private String buildGetJsonDocument(String clientToken) {
+        JSONObject documentJSONObj = new JSONObject();
+
+        try {
+            documentJSONObj.put(TXMqttLogConstants.TYPE, TXMqttLogConstants.GET_LOG_LEVEL);
+            documentJSONObj.put(TXMqttLogConstants.CLIENT_TOKEN, clientToken);
+        } catch (JSONException e) {
+            TXLog.e(TAG, e, "build report info failed");
+            return "";
+        }
+
+        return documentJSONObj.toString();
+    }
+
+}
+
Index: iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttToken.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttToken.java	(date 1606400383034)
+++ iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttToken.java	(date 1606400383034)
@@ -0,0 +1,107 @@
+package com.tencent.iot.hub.device.android.service;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttToken;
+
+import java.util.Arrays;
+
+/**
+ * 该类负责序列化MqttToken相关信息
+ */
+
+public class TXMqttToken implements Parcelable {
+
+    private String[] mTopics = null;
+    private volatile boolean mCompleted = false;
+    private int mMessageID = 0;
+    private int[] mGrantedQos = null;
+    private boolean mSessionPresent = false;
+
+    protected TXMqttToken(Parcel in) {
+        mTopics = in.createStringArray();
+        mCompleted = in.readByte() != 0;
+        mMessageID = in.readInt();
+        mGrantedQos = in.createIntArray();
+        mSessionPresent = in.readByte() != 0;
+    }
+
+    public TXMqttToken() {
+    }
+
+    public TXMqttToken(String[] topics, boolean mCompleted, int mMessageID, int[] mGrantedQos, boolean mSessionPresent) {
+        this.mTopics = topics;
+        this.mCompleted = mCompleted;
+        this.mMessageID = mMessageID;
+        this.mGrantedQos = mGrantedQos;
+        this.mSessionPresent = mSessionPresent;
+    }
+
+    public TXMqttToken(IMqttToken mqttToken) {
+        if (null != mqttToken.getTopics() && mqttToken.getTopics().length > 0) {
+            mTopics = new String[mqttToken.getTopics().length];
+            System.arraycopy(mqttToken.getTopics(), 0, mTopics, 0, mqttToken.getTopics().length);
+        }
+        mCompleted = mqttToken.isComplete();
+        mMessageID = mqttToken.getMessageId();
+        if (null != mqttToken.getGrantedQos() && mqttToken.getGrantedQos().length > 0) {
+            mGrantedQos = new int[mqttToken.getGrantedQos().length];
+            System.arraycopy(mqttToken.getGrantedQos(), 0, mGrantedQos, 0, mqttToken.getGrantedQos().length);
+        }
+        mSessionPresent = mqttToken.getSessionPresent();
+    }
+
+    public static final Creator<TXMqttToken> CREATOR = new Creator<TXMqttToken>() {
+        @Override
+        public TXMqttToken createFromParcel(Parcel in) {
+            return new TXMqttToken(in);
+        }
+
+        @Override
+        public TXMqttToken[] newArray(int size) {
+            return new TXMqttToken[size];
+        }
+    };
+
+    public MqttToken transToMqttToken() {
+        MqttToken mqttToken = new MqttToken("TXMqttToken");
+        mqttToken.internalTok.setTopics(mTopics);
+        mqttToken.internalTok.setMessageID(mMessageID);
+        return mqttToken;
+    }
+
+    @Override
+    public String toString() {
+        return "TXMqttToken{" +
+                "mTopics=" + Arrays.toString(mTopics) +
+                ", mCompleted=" + mCompleted +
+                ", mMessageID=" + mMessageID +
+                ", mGrantedQos=" + Arrays.toString(mGrantedQos) +
+                ", mSessionPresent=" + mSessionPresent +
+                '}';
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel parcel, int i) {
+        parcel.writeStringArray(mTopics);
+        parcel.writeByte((byte) (mCompleted ? 1 : 0));
+        parcel.writeInt(mMessageID);
+        parcel.writeIntArray(mGrantedQos);
+        parcel.writeByte((byte) (mSessionPresent ? 1 : 0));
+    }
+
+    public void readFromParcel(Parcel in) {
+        mTopics = in.createStringArray();
+        mCompleted = in.readByte() != 0;
+        mMessageID = in.readInt();
+        mGrantedQos = in.createIntArray();
+        mSessionPresent = in.readByte() != 0;
+    }
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/mqtt/TXAlarmPingSender.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/mqtt/TXAlarmPingSender.java	(date 1606400383019)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/mqtt/TXAlarmPingSender.java	(date 1606400383019)
@@ -0,0 +1,147 @@
+package com.tencent.iot.hub.device.android.core.mqtt;
+
+import android.annotation.SuppressLint;
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Build;
+import android.os.PowerManager;
+
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttPingSender;
+import org.eclipse.paho.client.mqttv3.internal.ClientComms;
+
+
+public class TXAlarmPingSender implements MqttPingSender {
+
+    public static final String TAG = "iot.TXAlarmPingSender";
+
+    private ClientComms mComms;
+    private Context mContext;
+    private BroadcastReceiver mAlarmReceiver;
+    private TXAlarmPingSender that;
+    private PendingIntent pendingIntent;
+    private volatile boolean hasStarted = false;
+
+    public TXAlarmPingSender(Context context) {
+        this.mContext = context;
+        that = this;
+    }
+
+    @Override
+    public void init(ClientComms comms) {
+        this.mComms = comms;
+        this.mAlarmReceiver = new AlarmReceiver();
+    }
+
+    @Override
+    public void start() {
+        String action = TXMqttConstants.PING_SENDER + mComms.getClient().getClientId();
+        TXLog.d(TAG, "Register alarmreceiver to Context " + action);
+        if (mContext != null && mAlarmReceiver != null) {
+            mContext.registerReceiver(mAlarmReceiver, new IntentFilter(action));
+        }
+
+        pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent(action), PendingIntent.FLAG_UPDATE_CURRENT);
+
+        schedule(mComms.getKeepAlive());
+        hasStarted = true;
+    }
+
+    @Override
+    public void stop() {
+
+        TXLog.d(TAG, "Unregister alarmreceiver to Context " + mComms.getClient().getClientId());
+        if(hasStarted){
+            if(pendingIntent != null){
+                // Cancel Alarm.
+                AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+                alarmManager.cancel(pendingIntent);
+            }
+
+            hasStarted = false;
+            try{
+                mContext.unregisterReceiver(mAlarmReceiver);
+            }catch(IllegalArgumentException e){
+                //Ignore unregister errors.			
+            }
+        }
+    }
+
+    @Override
+    public void schedule(long delayInMilliseconds) {
+        long nextAlarmInMilliseconds = System.currentTimeMillis() + delayInMilliseconds;
+        TXLog.d(TAG, "Schedule next alarm at " + nextAlarmInMilliseconds);
+        AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+
+        if(Build.VERSION.SDK_INT >= 23){
+            // In SDK 23 and above, dosing will prevent setExact, setExactAndAllowWhileIdle will force
+            // the device to run this task whilst dosing.
+            TXLog.d(TAG, "Alarm scheule using setExactAndAllowWhileIdle, next: " + delayInMilliseconds);
+            alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, nextAlarmInMilliseconds, pendingIntent);
+        } else if (Build.VERSION.SDK_INT >= 19) {
+            TXLog.d(TAG, "Alarm scheule using setExact, delay: " + delayInMilliseconds);
+            alarmManager.setExact(AlarmManager.RTC_WAKEUP, nextAlarmInMilliseconds, pendingIntent);
+        } else {
+            alarmManager.set(AlarmManager.RTC_WAKEUP, nextAlarmInMilliseconds, pendingIntent);
+        }
+    }
+
+    /**
+     * PingReq发送类
+     */
+    class AlarmReceiver extends BroadcastReceiver {
+
+        private PowerManager.WakeLock wakelock;
+
+        private final String wakeLockTag = TXMqttConstants.PING_WAKELOCK + that.mComms.getClient().getClientId();
+
+        @Override
+        @SuppressLint("Wakelock")
+        public void onReceive(Context context, Intent intent) {
+            // According to the docs, "Alarm Manager holds a CPU wake lock as
+            // long as the alarm receiver's onReceive() method is executing.
+            // This guarantees that the phone will not sleep until you have
+            // finished handling the broadcast.", but this class still get
+            // a wake lock to wait for ping finished.
+
+            TXLog.d(TAG, "Sending Ping at: " + System.currentTimeMillis());
+
+            PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+            wakelock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, wakeLockTag);
+            wakelock.acquire();
+
+            // Assign new callback to token to execute code after PingResq
+            // arrives. Get another wakelock even receiver already has one,
+            // release it until ping response returns.
+            IMqttToken token = mComms.checkForActivity(new IMqttActionListener() {
+
+                @Override
+                public void onSuccess(IMqttToken asyncActionToken) {
+                    TXLog.d(TAG, "Success. Release lock(" + wakeLockTag + "):" + System.currentTimeMillis());
+                    //Release wakelock when it is done.
+                    wakelock.release();
+                }
+
+                @Override
+                public void onFailure(IMqttToken asyncActionToken, Throwable exception) {
+                    TXLog.d(TAG, "Failure. Release lock(" + wakeLockTag + "):" + System.currentTimeMillis());
+                    //Release wakelock when it is done.
+                    wakelock.release();
+                }
+            });
+
+
+            if (token == null && wakelock.isHeld()) {
+                wakelock.release();
+            }
+        }
+    }
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/mqtt/TXMqttConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/mqtt/TXMqttConnection.java	(date 1606400383020)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/mqtt/TXMqttConnection.java	(date 1606400383020)
@@ -0,0 +1,509 @@
+package com.tencent.iot.hub.device.android.core.mqtt;
+
+import android.content.Context;
+import android.util.Base64;
+import android.util.Log;
+
+import com.tencent.iot.hub.device.android.core.log.TXMqttLog;
+import com.tencent.iot.hub.device.android.core.log.TXMqttLogCallBack;
+import com.tencent.iot.hub.device.android.core.log.TXMqttLogConstants;
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTACallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTAConstansts;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTAImpl;
+import com.tencent.iot.hub.device.java.core.util.HmacSha256;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttAsyncClient;
+import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
+import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttException;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.eclipse.paho.client.mqttv3.internal.wire.MqttSuback;
+import org.eclipse.paho.client.mqttv3.internal.wire.MqttWireMessage;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.MQTT_SDK_VER;
+
+
+public class TXMqttConnection extends com.tencent.iot.hub.device.java.core.mqtt.TXMqttConnection implements MqttCallbackExtended {
+
+    public static final String TAG = "TXMQTT_" + MQTT_SDK_VER;
+
+    protected Context mContext;
+    protected TXAlarmPingSender mPingSender = null;
+
+    private static int INVALID_MESSAGE_ID = -1;
+
+    protected boolean mMqttLogFlag;
+    public TXMqttLogCallBack mMqttLogCallBack = null;
+    private TXMqttLog mMqttLog = null;
+
+    /**
+     * 断连状态下buffer缓冲区，当连接重新建立成功后自动将buffer中数据写出
+     */
+    protected DisconnectedBufferOptions bufferOpts = null;
+
+    protected volatile TXMqttConstants.ConnectStatus mConnectStatus = TXMqttConstants.ConnectStatus.kConnectIdle;
+
+    /**
+     * @param context    用户上下文（这个参数在回调函数时透传给用户）
+     * @param productID  产品名
+     * @param deviceName 设备名，唯一
+	 * @param secretKey  密钥
+     * @param callBack   连接、消息发布、消息订阅回调接口
+     */
+    public TXMqttConnection(Context context, String productID, String deviceName, String secretKey, TXMqttActionCallBack callBack) {
+        this(context, productID, deviceName, secretKey, null, callBack);
+    }
+
+    /**
+     * @param context    用户上下文（这个参数在回调函数时透传给用户）
+     * @param productID  产品名
+     * @param deviceName 设备名，唯一
+	 * @param secretKey  密钥
+     * @param bufferOpts 发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+     * @param callBack   连接、消息发布、消息订阅回调接口
+     */
+    public TXMqttConnection(Context context, String productID, String deviceName, String secretKey, DisconnectedBufferOptions bufferOpts, TXMqttActionCallBack callBack) {
+        this(context, productID, deviceName, secretKey, bufferOpts, null, callBack);
+    }
+
+    /**
+     * 使用腾讯云物联网通信默认地址 "${ProductId}.iotcloud.tencentdevices.com:8883"  https://cloud.tencent.com/document/product/634/32546
+     * @param context           用户上下文（这个参数在回调函数时透传给用户）
+     * @param productID         产品名
+     * @param deviceName        设备名，唯一
+	 * @param secretKey         密钥
+     * @param bufferOpts        发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+     * @param clientPersistence 消息永久存储
+     * @param callBack          连接、消息发布、消息订阅回调接口
+     */
+    public TXMqttConnection(Context context, String productID, String deviceName, String secretKey,
+                            DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence, TXMqttActionCallBack callBack) {
+        this(context, null, productID, deviceName, secretKey, bufferOpts, clientPersistence, callBack);
+    }
+
+    /**
+     * @param context           用户上下文（这个参数在回调函数时透传给用户）
+     * @param serverURI         服务器URI
+     * @param productID         产品名
+     * @param deviceName        设备名，唯一
+     * @param secretKey         密钥
+     * @param bufferOpts        发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+     * @param clientPersistence 消息永久存储
+     * @param callBack          连接、消息发布、消息订阅回调接口
+     */
+    public TXMqttConnection(Context context, String serverURI, String productID, String deviceName, String secretKey,
+                            DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence,TXMqttActionCallBack callBack) {
+        this(context, serverURI, productID, deviceName, secretKey, bufferOpts, clientPersistence, false, null, callBack);
+    }
+
+    /**
+     * @param context           用户上下文（这个参数在回调函数时透传给用户）
+     * @param serverURI         服务器URI
+     * @param productID         产品名
+     * @param deviceName        设备名，唯一
+	 * @param secretKey         密钥
+     * @param bufferOpts        发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+     * @param clientPersistence 消息永久存储
+     * @param logCallBack       日子上传回调接口
+     * @param callBack          连接、消息发布、消息订阅回调接口
+     */
+    public TXMqttConnection(Context context, String serverURI, String productID, String deviceName, String secretKey,
+                            DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence, TXMqttLogCallBack logCallBack,TXMqttActionCallBack callBack) {
+        this(context, serverURI, productID, deviceName, secretKey, bufferOpts, clientPersistence, true, logCallBack, callBack);
+    }
+
+    /**
+     * @param context           用户上下文（这个参数在回调函数时透传给用户）
+     * @param serverURI         服务器URI
+     * @param productID         产品名
+     * @param deviceName        设备名，唯一
+     * @param secretKey         密钥
+     * @param bufferOpts        发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+     * @param clientPersistence 消息永久存储
+     * @param callBack          连接、消息发布、消息订阅回调接口
+     */
+    public TXMqttConnection(Context context, String serverURI, String productID, String deviceName, String secretKey,DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence, Boolean mqttLogFlag, TXMqttLogCallBack logCallBack, TXMqttActionCallBack callBack) {
+        super(serverURI, productID, deviceName, secretKey, bufferOpts, clientPersistence, callBack);
+        this.mContext = context;
+        this.mMqttLogFlag = mqttLogFlag;
+        this.mMqttLogCallBack = logCallBack;
+    }
+
+    /**
+     * 连接MQTT服务器，结果通过回调函数通知。
+     *
+     * @param options     连接参数
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public synchronized Status connect(MqttConnectOptions options, Object userContext) {
+        if (mConnectStatus.equals(TXMqttConstants.ConnectStatus.kConnecting)) {
+            TXLog.i(TAG, "The client is connecting. Connect return directly.");
+            return Status.MQTT_CONNECT_IN_PROGRESS;
+        }
+
+        if (mConnectStatus.equals(TXMqttConstants.ConnectStatus.kConnected)) {
+            TXLog.i(TAG, "The client is already connected. Connect return directly.");
+            return Status.OK;
+        }
+
+        this.mConnOptions = options;
+        if (mConnOptions == null) {
+            TXLog.e(TAG, "Connect options == null, will not connect.");
+            return Status.PARAMETER_INVALID;
+        }
+
+        Long timestamp;
+        if (options.isAutomaticReconnect()) {
+            timestamp = (long) Integer.MAX_VALUE;
+        } else {
+            timestamp = System.currentTimeMillis()/1000 + 600;
+        }
+        String userNameStr = mUserName + ";" + getConnectId() + ";" + timestamp;
+
+        mConnOptions.setUserName(userNameStr);
+
+        if (mSecretKey != null && mSecretKey.length() != 0) {
+            try {
+                String passWordStr = HmacSha256.getSignature(userNameStr.getBytes(), Base64.decode(mSecretKey, Base64.DEFAULT)) + ";hmacsha256";
+                mConnOptions.setPassword(passWordStr.toCharArray());
+            }
+            catch (IllegalArgumentException e) {
+                Log.d(TAG, "Failed to set password");
+            }
+        }
+
+        mConnOptions.setMqttVersion(MqttConnectOptions.MQTT_VERSION_3_1_1);
+
+        IMqttActionListener mActionListener = new IMqttActionListener() {
+            @Override
+            public void onSuccess(IMqttToken token) {
+                TXLog.i(TAG, "onSuccess!");
+                setConnectingState(TXMqttConstants.ConnectStatus.kConnected);
+                mActionCallBack.onConnectCompleted(Status.OK, false, token.getUserContext(), "connected to " + mServerURI);
+
+                // 连接建立后，如果需要日志，则初始化日志功能
+                if (mMqttLogFlag) {
+                    initMqttLog(TAG);
+                }
+            }
+
+            @Override
+            public void onFailure(IMqttToken token, Throwable exception) {
+                TXLog.e(TAG, exception, "onFailure!");
+                setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+                mActionCallBack.onConnectCompleted(Status.ERROR, false, token.getUserContext(), exception.toString());
+            }
+        };
+
+        if (mMqttClient == null) {
+            try {
+                mPingSender = new TXAlarmPingSender(mContext);
+                mMqttClient = new MqttAsyncClient(mServerURI, mClientId, mMqttPersist, mPingSender);
+                mMqttClient.setCallback(this);
+                mMqttClient.setBufferOpts(this.bufferOpts);
+                mMqttClient.setManualAcks(false);
+            } catch (Exception e) {
+                TXLog.e(TAG, "new MqttClient failed", e);
+                setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+                return Status.ERROR;
+            }
+        }
+
+        try {
+            TXLog.i(TAG, "Start connecting to %s", mServerURI);
+            setConnectingState(TXMqttConstants.ConnectStatus.kConnecting);
+            mMqttClient.connect(mConnOptions, userContext, mActionListener);
+        } catch (Exception e) {
+            TXLog.e(TAG, "MqttClient connect failed", e);
+            setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+            return Status.ERROR;
+        }
+
+        return Status.OK;
+    }
+
+    /**
+     * 初始化日志上传功能
+     * @param tag
+     */
+    protected void initMqttLog(final String tag) {
+        if (mMqttLog == null) {
+            this.mMqttLog = new TXMqttLog(this);
+        }
+
+        if (Status.OK != mMqttLog.initMqttLog()){
+            TXLog.i(tag,"Init MqttLog failed!" );
+        }
+    }
+
+    /**
+     * 生成一条设备日志
+     * @param logLevel 日志级别：
+     *                 MQTT错误：TXMqttLogConstants.LEVEL_FATAL    
+     *                 错误：TXMqttLogConstants.LEVEL_ERROR
+     *                 警告：TXMqttLogConstants.LEVEL_WARN
+     *                 通知：TXMqttLogConstants.LEVEL_INFO
+     *                 调试：TXMqttLogConstants.LEVEL_DEBUG
+     * @param tag
+     * @param format
+     * @param obj
+     */
+    public void mLog(int logLevel, final String tag,final String format, final Object... obj) {
+        if( mMqttLog != null) {
+            if( !(mMqttLog.saveMqttLog(logLevel, tag, format, obj))) {
+                TXLog.w(tag, "Save %s Level Log failed!", TXMqttLog.level_str[logLevel] );
+            }
+        }
+    }
+
+    public void mLog(int logLevel, final String tag,final String msg) {
+        if( mMqttLog != null) {
+            if( !(mMqttLog.saveMqttLog(logLevel, tag, msg))) {
+                TXLog.w(tag, "Save %s Level Log failed!", TXMqttLog.level_str[logLevel] );
+            }
+        }
+    }
+
+    /**
+     * 触发一次日志上传
+     */
+    public void uploadLog() {
+        if(mMqttLog != null) {
+            mMqttLog.uploadMqttLog();
+        }
+    }
+
+    /**
+     * 订阅RRPC Topic, 结果通过回调函数通知。
+     * topic格式: $rrpc/rxd/${ProductId}/${DeviceName}/+
+     *
+     * @param qos         QOS等级(仅支持QOS=0的消息)
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status subscribeRRPCTopic(final int qos, Object userContext) {
+        String topic = String.format("$rrpc/rxd/%s/%s/+", mProductId, mDeviceName);
+        return subscribe(topic, qos, userContext);
+    }
+
+
+    private Status publishRRPCToCloud(Object userContext, String processId, Map<String, String> replyMsg) {
+        // 应答topic格式: $rrpc/txd/${ProductId}/${DeviceName}/${messageid}
+        String topic  = String.format("$rrpc/txd/%s/%s/%s", mProductId, mDeviceName, processId);
+        //TODO 通过replyMsg构建mqtt messge
+        MqttMessage message = new MqttMessage();
+        JSONObject jsonObject = new JSONObject();
+        try {
+            jsonObject.put("test-key", "test-value"); // for test
+            for (Map.Entry<String, String> entrys : replyMsg.entrySet()) {
+                jsonObject.put(entrys.getKey(), entrys.getValue());
+            }
+        } catch (JSONException e) {
+            TXLog.e(TAG, e, "pack json data failed!");
+        }
+        message.setQos(TXMqttConstants.QOS0);
+        message.setPayload(jsonObject.toString().getBytes());
+        return publish(topic, message ,userContext);
+    }
+
+
+    /**
+     * 订阅广播Topic, 结果通过回调函数通知。
+     * 广播Topic格式: $broadcast/rxd/${ProductId}/${DeviceName}
+     *
+     * @param qos         QOS等级
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status subscribeBroadcastTopic(final int qos, Object userContext) {
+        String broadCastTopic = "";
+        if ((mMqttClient != null) && (mMqttClient.isConnected())) {
+            broadCastTopic = String.format("$broadcast/rxd/%s/%s", mProductId, mDeviceName);
+            try {
+                mMqttClient.subscribe(broadCastTopic, qos ,userContext, new QcloudMqttActionListener(TXMqttConstants.SUBSCRIBE));
+            } catch (Exception e) {
+                TXLog.e(TAG, e, "subscribe topic: %s failed.", broadCastTopic);
+                mLog(TXMqttLogConstants.LEVEL_FATAL, TAG, "subscribe topic: %s failed.", broadCastTopic);
+                return Status.ERROR;
+            }
+        } else {
+            TXLog.e(TAG, "subscribe topic: %s failed, because mMqttClient not connected.", broadCastTopic);
+            mLog(TXMqttLogConstants.LEVEL_FATAL, TAG, "subscribe topic: %s failed, because mMqttClient not connected.", broadCastTopic);
+            return Status.MQTT_NO_CONN;
+        }
+        return Status.OK;
+    }
+
+    @Override
+    public void connectComplete(boolean reconnect, String serverURI) {
+        TXLog.i(TAG, "connectComplete. reconnect flag is " + reconnect);
+        setConnectingState(TXMqttConstants.ConnectStatus.kConnected);
+
+        if (!reconnect) {
+            return;
+        }
+
+        Iterator<String> it = mSubscribedTopicMap.keySet().iterator();
+        while (it.hasNext()) {
+            String topic = it.next();
+            Integer qos = mSubscribedTopicMap.get(topic);
+            try {
+                TXLog.i(TAG, "subscribe to %s...", topic);
+                mMqttClient.subscribe(topic, qos, null, new QcloudMqttActionListener(TXMqttConstants.SUBSCRIBE));
+            } catch (Exception e) {
+                TXLog.e(TAG, "subscribe to %s failed.", topic);
+                mLog(TXMqttLogConstants.LEVEL_FATAL, TAG,"subscribe to %s failed.", topic);
+            }
+        }
+
+        mActionCallBack.onConnectCompleted(Status.OK, reconnect, null, "connected to " + serverURI);
+
+        //重新连接，处理离线日志，重新获取日志级别
+        if (mMqttLogFlag) {
+            initMqttLog(TAG);
+        }
+    }
+
+    /**
+     * 收到MQTT消息
+     *
+     * @param topic   消息主题
+     * @param message 消息内容结构体
+     * @throws Exception
+     */
+    @Override
+    public void messageArrived(String topic, MqttMessage message) throws Exception {
+        if (message.getQos() > 0 && message.getId() == mLastReceivedMessageId) {
+            TXLog.e(TAG, "Received topic: %s, id: %d, message: %s, discard repeated message!!!", topic, message.getId(), message);
+            mLog(TXMqttLogConstants.LEVEL_FATAL, TAG,"Received topic: %s, id: %d, message: %s, discard repeated message!!!", topic, message.getId(), message);
+            return;
+        }
+
+        TXLog.i(TAG, "Received topic: %s, id: %d, message: %s", topic, message.getId(), message);
+
+        if (topic != null && topic.contains("rrpc/rxd")) {
+            String[] items = topic.split("/");
+            String processId = items[items.length-1];
+            //TODO：数据格式暂不确定
+            Map<String, String> replyMessage = new HashMap<>();
+            publishRRPCToCloud(null, processId, replyMessage);
+        }
+
+        mLastReceivedMessageId = message.getId();
+
+        boolean consumed = false;
+        if (mOTAImpl != null ) {
+            consumed = mOTAImpl.processMessage(topic, message);
+        }
+
+        if (mActionCallBack != null) {
+            if (!consumed) {
+                mActionCallBack.onMessageReceived(topic, message);
+            }
+        }
+
+        //判断获取日志等级
+        if (mMqttLog != null) {
+            if (topic.startsWith("$" + TXMqttLogConstants.LOG)) {
+                String jsonStr = new String(message.getPayload());
+
+                try {
+                    JSONObject jsonObj = new JSONObject(jsonStr);
+
+                    if (jsonObj.has(TXMqttLogConstants.LOG_LEVEL)) {
+                        int logLevel = jsonObj.getInt(TXMqttLogConstants.LOG_LEVEL);
+                        mMqttLog.setMqttLogLevel(logLevel);
+                        uploadLog();
+                        TXLog.d(TAG, "******Set mqttLogLevel to " + logLevel);
+                        return;
+                    }
+
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+            TXLog.d(TAG, "******Get mqttLogLevel failed ");
+        }
+    }
+
+    /**
+     * 事件回调
+     */
+    private class QcloudMqttActionListener implements IMqttActionListener {
+        private int command;
+
+        public QcloudMqttActionListener(int command) {
+            this.command = command;
+        }
+
+        @Override
+        public void onSuccess(IMqttToken token) {
+
+            MqttWireMessage mqttWireMessage = token.getResponse();
+
+            switch (command) {
+                case TXMqttConstants.PUBLISH:
+                    mActionCallBack.onPublishCompleted(Status.OK, token, token.getUserContext(), TXMqttConstants.PUBLISH_SUCCESS);
+                    break;
+
+                case TXMqttConstants.SUBSCRIBE:
+                    int[] qos = ((MqttSuback) mqttWireMessage).getGrantedQos();
+                    if (null != qos && qos.length >= 1 && qos[0] == 128) {
+                        mActionCallBack.onSubscribeCompleted(Status.ERROR, token, token.getUserContext(), TXMqttConstants.SUBSCRIBE_FAIL);
+                    } else {
+                        mActionCallBack.onSubscribeCompleted(Status.OK, token, token.getUserContext(), TXMqttConstants.SUBSCRIBE_SUCCESS);
+
+                        if (mOTAImpl != null) {
+                            mOTAImpl.onSubscribeCompleted(Status.OK, token, token.getUserContext(), TXMqttConstants.SUBSCRIBE_SUCCESS);
+                        }
+                    }
+                    break;
+
+                case TXMqttConstants.UNSUBSCRIBE:
+                    mActionCallBack.onUnSubscribeCompleted(Status.OK, token, token.getUserContext(), TXMqttConstants.UNSUBSCRIBE_SUCCESS);
+                    break;
+
+                default:
+                    TXLog.e(TAG, "Unknown message on Success:" + token);
+                    mLog(TXMqttLogConstants.LEVEL_FATAL, TAG,"Unknown message on Success:" + token);
+                    break;
+            }
+        }
+
+        @Override
+        public void onFailure(IMqttToken token, Throwable exception) {
+            switch (command) {
+                case TXMqttConstants.PUBLISH:
+                    mActionCallBack.onPublishCompleted(Status.ERROR, token, token.getUserContext(), exception.toString());
+                    break;
+                case TXMqttConstants.SUBSCRIBE:
+                    mActionCallBack.onSubscribeCompleted(Status.ERROR, token, token.getUserContext(), exception.toString());
+                    break;
+                case TXMqttConstants.UNSUBSCRIBE:
+                    mActionCallBack.onUnSubscribeCompleted(Status.ERROR, token, token.getUserContext(), exception.toString());
+                    break;
+                default:
+                    TXLog.e(TAG, "Unknown message on onFailure:" + token);
+                    mLog(TXMqttLogConstants.LEVEL_FATAL, TAG,"Unknown message on onFailure:" + token);
+                    break;
+            }
+        }
+    }
+
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLogConstants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLogConstants.java	(date 1606400383019)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/log/TXMqttLogConstants.java	(date 1606400383019)
@@ -0,0 +1,21 @@
+package com.tencent.iot.hub.device.android.core.log;
+
+public interface TXMqttLogConstants {
+    /**
+     * 请求日志等级相关
+     */
+    String TYPE = "type";
+    String LOG = "log";
+    String LOG_LEVEL= "log_level";
+    String GET_LOG_LEVEL = "get_log_level";
+    String CLIENT_TOKEN = "clientToken";
+
+    /**
+     * 日志等级
+     */
+    int LEVEL_FATAL = 0;
+    int LEVEL_ERROR = 1;
+    int LEVEL_WARN  = 2;
+    int LEVEL_INFO  = 3;
+    int LEVEL_DEBUG = 4;
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/TXLogImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/TXLogImpl.java	(date 1606400383021)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/TXLogImpl.java	(date 1606400383021)
@@ -0,0 +1,404 @@
+package com.tencent.iot.hub.device.android.core.util;
+
+import java.util.concurrent.LinkedBlockingDeque;
+
+import android.content.Context;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.Looper;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class TXLogImpl implements TXLog.LogImp {
+
+    private static volatile Context sContext;
+
+    private static String packageName = "";
+
+    static LinkedBlockingDeque<String> logDeque = new LinkedBlockingDeque<String>(15000);
+
+    private static final int[] INTERVAL_RETRY_INIT = new int[]{1, 2, 4, 8, 16, 29}; //重试时间
+
+    private static AtomicInteger retryInitTimes = new AtomicInteger(0);
+
+    public static final SimpleDateFormat timeFormatter = new SimpleDateFormat("yy-MM-dd HH:mm:ss");
+
+    private static String logTime = "";
+
+    private static String logPath = "";
+
+    static String nowUsedFile = "";
+
+    static final ReentrantLock lock = new ReentrantLock();
+
+    protected static Object formatterLock = new Object();
+
+    private static long nextDayTime;
+
+    private static long nextSecondMinuteTime;
+
+    static long lastWriterErrorTime = 0;
+
+    private static FileWriter writer;
+
+    private static Handler retryInitHandler = new Handler(Looper.getMainLooper());
+
+    private int logLevel = TXLog.LEVEL_INFO;
+
+    /**
+     * 初始化日志
+     */
+    public static void init(Context context) {
+        sContext = context;
+        initRunnable.run();
+    }
+
+    /**
+     * 将日志写到文件
+     */
+    private synchronized static void writeLogToFile(String log) {
+        try {
+            // 如果SD卡不可用，则不写日志，以免每次都抛出异常，影响性能
+            if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
+                System.out.println("writeLogToFile not ready");
+                return;
+            }
+
+            if (null == writer) {
+                System.out.println("can not write log.");
+                long now = System.currentTimeMillis();
+                if (lastWriterErrorTime == 0) {
+                    lastWriterErrorTime = now;
+                } else if (now - lastWriterErrorTime > 60 * 1000) {
+                    try {
+                        initLogFile(System.currentTimeMillis());
+                    } catch (IOException e1) {
+                        e1.printStackTrace();
+                    }
+                    lastWriterErrorTime = now;
+                }
+            } else {
+                long now = System.currentTimeMillis();
+                if (now > nextDayTime) {
+                    initLogFile(now);
+                }
+                //加入消息的时候记录时间
+                if (lock.tryLock()) {
+                    try {
+                        writer.write(log);
+                        writer.flush();
+                    } finally {
+                        lock.unlock();
+                    }
+                } else {
+                    if (!insertLogToCacheHead(log)) {
+                        System.out.println("insertLogToCacheHead failed!");
+                    }
+                }
+            }
+
+        } catch (Throwable e) {
+            if (e instanceof IOException && e.getMessage().contains("ENOSPC")) {
+                e.printStackTrace();
+            } else {
+                try {
+                    initLogFile(System.currentTimeMillis());
+                } catch (Throwable e1) {
+                    e1.printStackTrace();
+                }
+            }
+        }
+    }
+
+    /**
+     * 写日志线程
+     */
+    static Thread takeThread = new Thread() {
+        public void run() {
+            while (true) {
+                synchronized (this) {
+                    try {
+                        String log;
+                        log = logDeque.take();
+                        if (null != log) {
+                            writeLogToFile(log);
+                        }
+                    } catch (Exception e) {
+                        System.out.println("write log file error: " + e.toString());
+                    } catch (AssertionError ignore) {
+                        System.out.println("--------------");
+                    }
+                }
+            }
+        }
+    };
+
+    private static String getDateStr(long nowCurrentMillis) {
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis(nowCurrentMillis);
+        SimpleDateFormat logFileFormatter = new SimpleDateFormat("yyyyMMdd");
+        SimpleDateFormat timeFormatter = new SimpleDateFormat("yy-MM-dd HH:mm:ss");
+        logTime = timeFormatter.format(nowCurrentMillis);
+        String thisLogName = logFileFormatter.format(calendar.getTime());
+        setNextSecond(calendar);
+        setNextHour(calendar);
+        return thisLogName;
+    }
+
+    private static void setNextHour(Calendar setSecondedCalendar) {
+        setSecondedCalendar.add(Calendar.DAY_OF_MONTH, 1);
+        nextDayTime = setSecondedCalendar.getTimeInMillis();
+    }
+
+    private static void setNextSecond(Calendar calendar) {
+        calendar.set(Calendar.MILLISECOND, 0);
+        nextSecondMinuteTime = calendar.getTimeInMillis() + 1000;
+    }
+
+    public static String getLogFileName(String dataStr) {
+        return "iot_" + dataStr + ".log";
+    }
+
+    private static synchronized void checkNextMinuteTime(long currentTimeMillis) {
+        if (currentTimeMillis > nextSecondMinuteTime) {
+            synchronized (formatterLock) {
+                logTime = timeFormatter.format(currentTimeMillis);
+                nextSecondMinuteTime = nextSecondMinuteTime + 1000;
+            }
+        }
+    }
+
+    public static String getLogPath() {
+        return logPath;
+    }
+
+
+    /**
+     * 初始化日志文件
+     */
+    static synchronized void initLogFile(long nowCurrentTimeMillis) throws IOException {
+        logPath = Environment.getExternalStorageDirectory().getPath() + "/tencent/" + packageName.replace(".", "/")
+                + "/";
+        File tmpeFile = new File(logPath);
+        if (!tmpeFile.exists()) {
+            tmpeFile.mkdirs();
+        }
+        nowUsedFile = logPath + getLogFileName(getDateStr(nowCurrentTimeMillis));
+        try {
+            tmpeFile = new File(nowUsedFile);
+            if (!tmpeFile.exists()) {
+                boolean b = tmpeFile.createNewFile();
+                if (null != writer) {
+                    writer.write(logTime + "|" + "|D|" + android.os.Build.MODEL + " " + android.os.Build.VERSION.RELEASE + " create newLogFile " + tmpeFile.getName() + " " + b + "\n");
+                    writer.flush();
+                }
+            } else {
+                if (null != writer) {
+                    writer.write(logTime + "|" + "|E|" + android.os.Build.MODEL + " " + android.os.Build.VERSION.RELEASE + "|newLogFile " + tmpeFile.getName() + " is existed.\n");
+                    writer.flush();
+                }
+            }
+        } catch (Throwable e) {
+            e.printStackTrace();
+        }
+        writer = new FileWriter(tmpeFile, true);
+    }
+
+    static void delete7DaysBeforeFiles(long today) {
+        logPath = Environment.getExternalStorageDirectory().getPath() + "/tencent/" + packageName.replace(".", "/");
+        long day = (long) 1 * 24 * 60 * 60 * 1000;
+        File tmpeFile;
+        //删除前一个月的
+        for (long i = (today - 7 * day); i > today - 37 * day; i = i - day) {
+            String date = getDateStr(i);
+            nowUsedFile = logPath + getLogFileName(date);
+            try {
+                tmpeFile = new File(nowUsedFile);
+                if (tmpeFile.exists()) {
+                    tmpeFile.delete();
+                }
+            } catch (Throwable e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    /**
+     * 日志初始化Runnable
+     */
+    public static Runnable initRunnable = new Runnable() {
+        @Override
+        public void run() {
+            if (null == sContext) {
+                return;
+            }
+
+            new Thread("QLogInitThread") {
+                @Override
+                public void run() {
+                    try {
+                        try {
+                            packageName = sContext.getPackageName();
+                        } catch (Exception e) {
+                            packageName = "unknown";
+                        }
+                        delete7DaysBeforeFiles(System.currentTimeMillis());
+                        initLogFile(System.currentTimeMillis());
+
+                        takeThread.setName("logWriteThread");
+                        takeThread.start();
+                        retryInitHandler.removeCallbacks(initRunnable);
+                    } catch (Exception e) {
+                        int times = retryInitTimes.get();
+                        System.out.println("QLogImpl init post retry " + times + " times, interval " + INTERVAL_RETRY_INIT[times]);
+                        retryInitHandler.removeCallbacks(initRunnable);
+                        retryInitHandler.postDelayed(initRunnable, INTERVAL_RETRY_INIT[times] * 60000);
+                        times++;
+                        if (times >= INTERVAL_RETRY_INIT.length) {
+                            times = 0;
+                        }
+                        retryInitTimes.set(times);
+                    }
+                }
+            }.start();
+        }
+    };
+
+    public static void writeLog(String level, String tag, String msg, Throwable tr) {
+        long now = System.currentTimeMillis();
+        if (now >= nextSecondMinuteTime) {
+            checkNextMinuteTime(now);
+        }
+
+        long threadId = Thread.currentThread().getId();
+        String message = logTime + "|" + level + "|" + String.valueOf(threadId) + "|" + tag + "|" + msg + "\n";
+        if (null != tr) {
+            message = msg + "\n" + Log.getStackTraceString(tr) + "\n";
+        }
+        addLogToCache(message);
+    }
+
+    /**
+     * 添加日志到缓存
+     */
+    private static boolean addLogToCache(String log) {
+        try {
+            logDeque.add(log);
+            return true;
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    /**
+     * 添加缓冲头部
+     */
+    private static boolean insertLogToCacheHead(String log) {
+        try {
+            logDeque.addFirst(log);
+            return true;
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    enum LogLevel {
+
+        OFF("OFF"),
+        ERROR("ERROR"),
+        WARN("WARN"),
+        INFO("INFO"),
+        DEBUG("DEBUG"),
+        VERBOSE("VERBOSE");
+
+        private String descr = "INFO";
+
+        private LogLevel(String descr){
+            this.descr = descr;
+        }
+    }
+
+    @Override
+    public void logV(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log) {
+        long now = System.currentTimeMillis();
+        if (now >= nextSecondMinuteTime) {
+            checkNextMinuteTime(now);
+        }
+
+        String message = logTime + "|" + LogLevel.VERBOSE + "|" + pid + "|" + tid + "|" + tag + "|" + log + "\n";
+        addLogToCache(message);
+    }
+
+    @Override
+    public void logI(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log) {
+        long now = System.currentTimeMillis();
+        if (now >= nextSecondMinuteTime) {
+            checkNextMinuteTime(now);
+        }
+
+        String message = logTime + "|" + LogLevel.INFO + "|" + pid + "|" + tid + "|" + tag + "|" + log + "\n";
+        addLogToCache(message);
+    }
+
+    @Override
+    public void logD(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log) {
+        long now = System.currentTimeMillis();
+        if (now >= nextSecondMinuteTime) {
+            checkNextMinuteTime(now);
+        }
+
+        String message = logTime + "|" + LogLevel.DEBUG + "|" + pid + "|" + tid + "|" + tag + "|" + log + "\n";
+        addLogToCache(message);
+    }
+
+    @Override
+    public void logW(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log) {
+        long now = System.currentTimeMillis();
+        if (now >= nextSecondMinuteTime) {
+            checkNextMinuteTime(now);
+        }
+
+        String message = logTime + "|" + LogLevel.WARN + "|" + pid + "|" + tid + "|" + tag + "|" + log + "\n";
+        addLogToCache(message);
+    }
+
+    @Override
+    public void logE(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log) {
+        long now = System.currentTimeMillis();
+        if (now >= nextSecondMinuteTime) {
+            checkNextMinuteTime(now);
+        }
+
+        String message = logTime + "|" + LogLevel.ERROR + "|" + pid + "|" + tid + "|" + tag + "|" + log + "\n";
+        addLogToCache(message);
+    }
+
+    @Override
+    public void logF(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log) {
+        long now = System.currentTimeMillis();
+        if (now >= nextSecondMinuteTime) {
+            checkNextMinuteTime(now);
+        }
+
+        String message = logTime + "|" + LogLevel.OFF + "|" + pid + "|" + tid + "|" + tag + "|" + log + "\n";
+        addLogToCache(message);
+    }
+
+    @Override
+    public int getLogLevel() {
+        return logLevel;
+    }
+
+    @Override
+    public void setLogLevel(int level) {
+        logLevel = level;
+    }
+}
+
Index: iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXShadowClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXShadowClient.java	(date 1606400383035)
+++ iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXShadowClient.java	(date 1606400383035)
@@ -0,0 +1,341 @@
+package com.tencent.iot.hub.device.android.service;
+
+import android.content.Context;
+import android.content.ServiceConnection;
+import android.os.RemoteException;
+
+import com.tencent.iot.hub.device.android.core.shadow.DeviceProperty;
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTACallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTAConstansts;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowActionCallBack;
+
+import java.util.List;
+
+/**
+ * Shadow远程服务客户端
+ */
+public class TXShadowClient {
+
+    private static final String TAG = TXShadowClient.class.getSimpleName();
+
+    /**
+     * mqtt客户端，ShadowClient所有功能均通过该成员变量进行
+     */
+    private TXMqttClient mMqttClient = null;
+
+    /**
+     * shadowAction监听器，用于跨进程调用
+     */
+    private ITXShadowActionListener mShadowActionListener = null;
+
+    /**
+     * shadowAction回调接口，用于外部回调
+     */
+    private TXShadowActionCallBack mShadowActionCallBack = null;
+
+    public TXShadowClient() {
+        this.mMqttClient = new TXMqttClient();
+    }
+
+    public TXShadowClient(TXMqttClient mMqttClient) {
+        this.mMqttClient = mMqttClient;
+    }
+
+    /**
+     * 设置ShadowAction回调接口
+     *
+     * @param mShadowActionCallBack shadowAction回调接口
+     * @return
+     */
+    public TXShadowClient setShadowActionCallBack(TXShadowActionCallBack mShadowActionCallBack) {
+        this.mShadowActionCallBack = mShadowActionCallBack;
+        return this;
+    }
+
+    /**
+     * 设置远程服务连接回调接口
+     *
+     * @param serviceConnection 远程服务连接回调接口
+     * @return
+     */
+    public TXShadowClient setServiceConnection(ServiceConnection serviceConnection) {
+        mMqttClient.setServiceConnection(serviceConnection);
+        return this;
+    }
+
+    /**
+     * 获取Mqtt客户端实例
+     *
+     * @return
+     */
+    public TXMqttClient getMqttClient() {
+        return mMqttClient;
+    }
+
+    /**
+     * 初始化远程服务客户端
+     *
+     * @param context
+     * @param clientOptions 客户端选项
+     */
+    public void init(Context context, TXMqttClientOptions clientOptions) {
+        initListener();
+        mMqttClient.init(context, clientOptions, mShadowActionListener);
+    }
+
+    /**
+     * 开启远程服务
+     */
+    public void startRemoteService() {
+        mMqttClient.startRemoteService();
+    }
+
+    /**
+     * 停止远程服务
+     */
+    public void stopRemoteService() {
+        mMqttClient.stopRemoteService();
+    }
+
+    /**
+     * 设置断连状态buffer缓冲区
+     *
+     * @param bufferOpts
+     */
+    public void setBufferOpts(TXDisconnectedBufferOptions bufferOpts) {
+        mMqttClient.setBufferOpts(bufferOpts);
+    }
+
+    /**
+     * 与云端建立连接，结果通过回调函数通知
+     *
+     * @param connectOptions 连接参数
+     * @param userContext    用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status connect(TXMqttConnectOptions connectOptions, Object userContext) {
+        connectOptions.setUseShadow(true);
+        return mMqttClient.connect(connectOptions, userContext);
+    }
+
+    /**
+     * 断开连接请求，结果通过回调函数通知。
+     *
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status disConnect(Object userContext) {
+        return mMqttClient.disConnect(userContext);
+    }
+
+    /**
+     * 获取连接状态
+     *
+     * @return 连接状态
+     */
+    public TXMqttConstants.ConnectStatus getConnectStatus() {
+        TXMqttConstants.ConnectStatus status = TXMqttConstants.ConnectStatus.kDisconnected;
+        try {
+            String statusStr = mMqttClient.mRemoteServer.getConnectStatus();
+            status = Status.valueOf(TXMqttConstants.ConnectStatus.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[getConnectStatus] failed!");
+        }
+        return status;
+    }
+
+    /**
+     * 获取设备影子
+     */
+    public Status get(Object userContext) {
+        Status status = Status.ERROR;
+        try {
+            long requestId = mMqttClient.addUserContext(userContext);
+            String statusStr = mMqttClient.mRemoteServer.getShadow(requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[getShadow] failed!");
+        }
+        return status;
+    }
+
+    /**
+     * 更新设备属性信息，结果通过回调函数通知。
+     *
+     * @param devicePropertyList 需要更新的设备属性集
+     * @param userContext        用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status update(List<DeviceProperty> devicePropertyList, Object userContext) {
+        Status status = Status.ERROR;
+        try {
+            long requestId = mMqttClient.addUserContext(userContext);
+            String statusStr = mMqttClient.mRemoteServer.updateShadow(devicePropertyList, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[updateShadow] failed!");
+        }
+        return status;
+    }
+
+    /**
+     * 注册设备属性
+     *
+     * @param deviceProperty
+     */
+    public void registerProperty(DeviceProperty deviceProperty) {
+        try {
+            mMqttClient.mRemoteServer.registerDeviceProperty(deviceProperty);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[registerDeviceProperty] failed!");
+        }
+    }
+
+    /**
+     * 取消注册设备属性
+     *
+     * @param deviceProperty
+     */
+    public void unRegisterProperty(DeviceProperty deviceProperty) {
+        try {
+            mMqttClient.mRemoteServer.unRegisterDeviceProperty(deviceProperty);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[unRegisterDeviceProperty] failed!");
+        }
+    }
+
+    /**
+     * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息。
+     *
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportNullDesiredInfo() {
+        return reportNullDesiredInfo(null);
+    }
+
+    /**
+     * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息。
+     *
+     * @param reportJsonDoc 用户上报的JSON内容
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportNullDesiredInfo(String reportJsonDoc) {
+        Status status = Status.ERROR;
+        try {
+            String statusStr = mMqttClient.mRemoteServer.reportNullDesiredInfo(reportJsonDoc);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[reportNullDesiredInfo] failed!");
+        }
+        return status;
+    }
+
+    /**
+     * 释放资源
+     */
+    public void clear() {
+        mMqttClient.clear();
+    }
+
+    /**
+     * 初始化OTA功能。
+     *
+     * @param storagePath OTA升级包存储路径(调用者必确保路径已存在，并且具有写权限)
+     * @param callback    OTA事件回调
+     */
+    public void initOTA(String storagePath, TXOTACallBack callback) {
+
+        mMqttClient.initOTA(storagePath, callback);
+    }
+
+    /**
+     * 上报设备当前版本信息到后台服务器。
+     *
+     * @param currentFirmwareVersion 设备当前版本信息
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportCurrentFirmwareVersion(String currentFirmwareVersion)  {
+
+        return mMqttClient.reportCurrentFirmwareVersion(currentFirmwareVersion);
+    }
+
+    /**
+     * 上报设备升级状态到后台服务器。
+     *
+     * @param state
+     * @param resultCode
+     * @param resultMsg
+     * @param version
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportOTAState(TXOTAConstansts.ReportState state, int resultCode, String resultMsg, String version) {
+
+        return mMqttClient.reportOTAState(state, resultCode, resultMsg, version);
+    }
+
+    /**
+     * 初始化监听器
+     */
+    private void initListener() {
+        mShadowActionListener = new ITXShadowActionListener.Stub() {
+            @Override
+            public void onRequestCallback(String type, int result, String document) throws RemoteException {
+                TXLog.d(TAG, "onRequestCallback, type[%s], result[%d], document[%s]", type, result, document);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onRequestCallback(type, result, document);
+                }
+            }
+
+            @Override
+            public void onDevicePropertyCallback(String propertyJSONDocument, List<DeviceProperty> devicePropertyList) throws RemoteException {
+                TXLog.d(TAG, "onDevicePropertyCallback, propertyJSONDocument[%s], devicePropertyList size[%d]",
+                        propertyJSONDocument, devicePropertyList.size());
+                for (DeviceProperty deviceProperty : devicePropertyList) {
+                    TXLog.d(TAG, deviceProperty.toString());
+                }
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onDevicePropertyCallback(propertyJSONDocument, devicePropertyList);
+                }
+            }
+
+            @Override
+            public void onPublishCompleted(String status, TXMqttToken token, long userContextId, String errMsg) throws RemoteException {
+                TXLog.d(TAG, "onPublishCompleted, status[%s], token[%s], errMsg[%s]", status, token, errMsg);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onPublishCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(),
+                            mMqttClient.getUserContext(Long.valueOf(userContextId)), errMsg);
+                }
+            }
+
+            @Override
+            public void onSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg) throws RemoteException {
+                TXLog.d(TAG, "onSubscribeCompleted, status[%s], token[%s], errMsg[%s]", status, token, errMsg);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onSubscribeCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(),
+                            mMqttClient.getUserContext(Long.valueOf(userContextId)), errMsg);
+                }
+            }
+
+            @Override
+            public void onUnSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg) throws RemoteException {
+                TXLog.d(TAG, "onUnSubscribeCompleted, status[%s], token[%s], errMsg[%s]", status, token, errMsg);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onUnSubscribeCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(),
+                            mMqttClient.getUserContext(Long.valueOf(userContextId)), errMsg);
+                }
+            }
+
+            @Override
+            public void onMessageReceived(String topic, TXMqttMessage message) throws RemoteException {
+                TXLog.d(TAG, "onMessageReceived, topic[%s], message[%s]", topic, message);
+                if (null != mShadowActionCallBack) {
+                    mShadowActionCallBack.onMessageReceived(topic, message.transToMqttMessage());
+                }
+            }
+        };
+    }
+
+}
Index: iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttService.java	(date 1606842659966)
+++ iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttService.java	(date 1606842659966)
@@ -0,0 +1,918 @@
+package com.tencent.iot.hub.device.android.service;
+
+import android.app.Service;
+import android.content.Context;
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.tencent.iot.hub.device.android.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.android.core.shadow.TXShadowConnection;
+import com.tencent.iot.hub.device.android.core.util.AsymcSslUtils;
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.android.core.shadow.DeviceProperty;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTACallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTAConstansts;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowActionCallBack;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowConstants;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import java.util.List;
+
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.MQTT_SERVER_PORT_TLS;
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.PREFIX;
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.QCLOUD_IOT_MQTT_DIRECT_DOMAIN;
+
+/**
+ * MQTT 远程服务
+ * <p>
+ * 如需将MQTT功能运行在独立进程中时，使用TXMqttService开启服务；
+ * 不需要时，直接调用TXMqttConnection或TXShadowConnection中相关接口即可。
+ */
+public class TXMqttService extends Service {
+
+    private static final String TAG = TXMqttService.class.getSimpleName();
+
+    private Context mContext = null;
+
+    /**
+     * 服务器URI
+     */
+    private String mServerURI;
+
+    /**
+     * Iot Hub控制台获取产品ID
+     */
+    private String mProductId;
+
+    /**
+     * 设备名，唯一
+     */
+    private String mDeviceName;
+
+    private String mSecretKey;
+
+    /**
+     * MQTT 连接器
+     */
+    private TXMqttConnection mMqttConnection = null;
+
+    /**
+     * shadow连接器
+     */
+    private TXShadowConnection mShadowConnection = null;
+
+    /**
+     * mqttAction回调接口
+     */
+    private TXMqttActionCallBack mMqttActionCallBack = null;
+
+    /**
+     * shadowAction回调接口
+     */
+    private TXShadowActionCallBack mShadowActionCallBack = null;
+
+    /**
+     * 客户端MqttAction监听器
+     */
+    private ITXMqttActionListener mMqttActionListener = null;
+
+    /**
+     * 客户端ShadowAction监听器
+     */
+    private ITXShadowActionListener mShadowActionListener = null;
+
+    /**
+     * 断连缓存选项
+     */
+    private DisconnectedBufferOptions mDisconnectedBufferOptions = null;
+
+    private MqttClientPersistence mClientPersistence = null;
+
+    /**
+     * MQTT
+     */
+    private ITXMqttService.Stub mMqttService = null;
+
+    /**
+     * 是否使用shadow
+     */
+    private boolean mUseShadow = false;
+
+    private boolean isInit = false;
+
+
+    private ITXOTAListener mOTAListener = null;
+    private TXOTACallBack mInternalOTACallback = new TXOTACallBack() {
+        @Override
+        public void onReportFirmwareVersion(int resultCode, String version, String resultMsg) {
+            if (mOTAListener != null) {
+                try {
+                    mOTAListener.onReportFirmwareVersion(resultCode, version, resultMsg);
+                }catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        @Override
+        public boolean onLastestFirmwareReady(String url, String md5, String version) {
+            TXLog.e(TAG, "TXMqttService onLastestFirmwareReady");
+            return false;
+        }
+
+        @Override
+        public void onDownloadProgress(int percent, String version) {
+            if (mOTAListener != null) {
+                try {
+                    mOTAListener.onDownloadProgress(percent, version);
+                }catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        @Override
+        public void onDownloadCompleted(String outputFile, String version) {
+            try {
+                mOTAListener.onDownloadCompleted(outputFile, version);
+            }catch (Exception e) {
+
+            }
+        }
+
+        @Override
+        public void onDownloadFailure(int errCode, String version) {
+            try {
+                mOTAListener.onDownloadFailure(errCode, version);
+            }catch (Exception e) {
+
+            }
+        }
+    };
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        TXLog.d(TAG, "onCreate");
+        init();
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        String intentStr = (null == intent) ? "" : intent.toString();
+        TXLog.d(TAG, "onStartCommand, intent[%s], flags[%d], startId[%d]", intentStr, flags, startId);
+        if (startId > 1 && null != mMqttActionListener) {
+            try {
+                mMqttActionListener.onServiceStartedCallback();
+            } catch (RemoteException e) {
+                TXLog.e(TAG, e, "invoke remote method[onServiceStartedCallback] failed!");
+            }
+        }
+        return START_STICKY;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        TXLog.d(TAG, "onBind");
+        return mMqttService;
+    }
+
+    @Override
+    public boolean onUnbind(Intent intent) {
+        TXLog.d(TAG, "onUnbind");
+        return super.onUnbind(intent);
+    }
+
+    @Override
+    public void onDestroy() {
+        TXLog.d(TAG, "onDestroy");
+        super.onDestroy();
+        if (mUseShadow) {
+            if (null != mShadowConnection) {
+                mShadowConnection.disConnect(null);
+            }
+        } else {
+            if (null != mMqttConnection) {
+                mMqttConnection.disConnect(null);
+            }
+        }
+
+        try {
+            mMqttActionListener.onServiceDestroyCallback();
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote method[onServiceDestroyCallback] failed!");
+        }
+
+        mMqttService = null;
+        mClientPersistence = null;
+        mDisconnectedBufferOptions = null;
+
+        mMqttConnection = null;
+        mShadowConnection = null;
+        mMqttActionListener = null;
+        mShadowActionListener = null;
+    }
+
+    /**
+     * 初始化设备信息
+     *
+     * @param mqttClientOptions
+     */
+    private void initDeviceInfo(TXMqttClientOptions mqttClientOptions) {
+        mProductId = mqttClientOptions.getProductId();
+        mDeviceName = mqttClientOptions.getDeviceName();
+        mServerURI = mqttClientOptions.getServerURI();
+        mSecretKey = mqttClientOptions.getSecretKey();
+        TXLog.d(TAG, "initDeviceInfo, productId[%s], deviceName[%s], serverURI[%s]", mProductId, mDeviceName, mServerURI);
+        isInit = true;
+    }
+
+    /**
+     * mqtt连接服务器
+     *
+     * @param options
+     * @param userContextId
+     */
+    private String connect(TXMqttConnectOptions options, long userContextId) {
+        Status status = Status.ERROR;
+        if (!isInit) {
+            TXLog.d(TAG, "device is not initialized!");
+            return status.name();
+        }
+
+        // 检查连接类型是否发生改变，若发生改变，则先关闭之前的连接
+        if (mUseShadow != options.isUseShadow()) {
+            if (mUseShadow && null != mShadowConnection
+                    && mShadowConnection.getConnectStatus() == TXMqttConstants.ConnectStatus.kConnected) {
+                mShadowConnection.disConnect(null);
+            } else if (null != mMqttConnection
+                    && mMqttConnection.getConnectStatus() == TXMqttConstants.ConnectStatus.kConnected) {
+                mMqttConnection.disConnect(null);
+            }
+        }
+
+        MqttConnectOptions connectOptions = new MqttConnectOptions();
+        connectOptions.setConnectionTimeout(options.getConnectionTimeout());
+        connectOptions.setAutomaticReconnect(options.isAutomaticReconnect());
+        connectOptions.setCleanSession(options.isCleanSession());
+        connectOptions.setKeepAliveInterval(options.getKeepAliveInterval());
+
+        if (options.isAsymcEncryption()) {
+
+            String certFile = options.getDeviceCertName();
+            String keyFile  = options.getDeviceKeyName();
+            String secretKey = options.getSecretKey();
+
+            if (secretKey != null) {
+                connectOptions.setSocketFactory(AsymcSslUtils.getSocketFactory());
+            }else {
+
+                if (certFile.startsWith("/")) {
+                    connectOptions.setSocketFactory(AsymcSslUtils.getSocketFactoryByFile(certFile, keyFile));
+                } else if (certFile.startsWith("file://")) {
+                    certFile = certFile.substring(7);
+                    keyFile = keyFile.substring(7);
+                    connectOptions.setSocketFactory(AsymcSslUtils.getSocketFactoryByFile(certFile, keyFile));
+                } else {
+                    connectOptions.setSocketFactory(AsymcSslUtils.getSocketFactoryByAssetsFile(mContext, certFile, keyFile));
+                }
+            }
+        }
+
+        mUseShadow = options.isUseShadow();
+        if (mUseShadow) {
+            if (TextUtils.isEmpty(mServerURI)) {
+                mShadowConnection = new TXShadowConnection(mContext, PREFIX + mProductId + QCLOUD_IOT_MQTT_DIRECT_DOMAIN + MQTT_SERVER_PORT_TLS, mProductId, mDeviceName, mSecretKey,
+                        mDisconnectedBufferOptions, mClientPersistence, mShadowActionCallBack);
+            } else {
+                mShadowConnection = new TXShadowConnection(mContext, mServerURI, mProductId, mDeviceName, mSecretKey,
+                        mDisconnectedBufferOptions, mClientPersistence, mShadowActionCallBack);
+            }
+            status = mShadowConnection.connect(connectOptions, null);
+        } else {
+            mMqttConnection = new TXMqttConnection(mContext, mProductId, mDeviceName, mSecretKey, mMqttActionCallBack);
+            status = mMqttConnection.connect(connectOptions, Long.valueOf(userContextId));
+        }
+        return status.name();
+    }
+
+    /**
+     * 重新连接
+     *
+     * @return
+     */
+    private String reconnect() {
+        Status status = Status.ERROR;
+        if (!isInit) {
+            TXLog.d(TAG, "device is not initialized!");
+            return status.name();
+        }
+
+        if (!mUseShadow && null != mMqttConnection) {
+            status = mMqttConnection.reconnect();
+        }
+        return status.name();
+    }
+
+    /**
+     * mqtt断连
+     */
+    private String disConnect(long timeout, long userContextId) {
+        Status status = Status.ERROR;
+        if (!isInit) {
+            TXLog.d(TAG, "device is not initialized!");
+            return status.name();
+        }
+
+        if (mUseShadow && null != mShadowConnection) {
+            status = mShadowConnection.disConnect(null);
+        } else if (null != mMqttConnection) {
+            status = mMqttConnection.disConnect(timeout, Long.valueOf(userContextId));
+        }
+        return status.name();
+    }
+
+    private String publish(String topic, TXMqttMessage txMessage, long userContext) {
+        Status status = Status.ERROR;
+        if (!isInit) {
+            TXLog.d(TAG, "device is not initialized!");
+            return status.name();
+        }
+
+        MqttMessage message = txMessage.transToMqttMessage();
+        if (mUseShadow && null != mShadowConnection) {
+            status = mShadowConnection.getMqttConnection().publish(topic, message, userContext);
+        } else if (null != mMqttConnection) {
+            status = mMqttConnection.publish(topic, message, userContext);
+        }
+        return status.name();
+    }
+
+    /**
+     * 初始化OTA功能。
+     *
+     * @param storagePath OTA升级包存储路径(调用者必确保路径已存在，并且具有写权限)
+     * @param otaListener OTA事件回调
+     */
+    public void initOTA(String storagePath, ITXOTAListener otaListener) {
+        if (!isInit) {
+            TXLog.d(TAG, "device is not initialized!");
+            return;
+        }
+        
+        mOTAListener = otaListener;
+
+        if (mUseShadow && null != mShadowConnection) {
+            mShadowConnection.getMqttConnection().initOTA(storagePath, mInternalOTACallback);
+        } else if (null != mMqttConnection) {
+            mMqttConnection.initOTA(storagePath, mInternalOTACallback);
+        }
+    }
+
+    /**
+     * 上报设备当前版本信息到后台服务器。
+     *
+     * @param currentFirmwareVersion 设备当前版本信息
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportCurrentFirmwareVersion(String currentFirmwareVersion) {
+        Status status = Status.ERROR;
+
+        if (mUseShadow && null != mShadowConnection) {
+            status = mShadowConnection.getMqttConnection().reportCurrentFirmwareVersion(currentFirmwareVersion);
+        } else if (null != mMqttConnection) {
+            status = mMqttConnection.reportCurrentFirmwareVersion(currentFirmwareVersion);
+        }
+        return status;
+    }
+
+    /**
+     * 上报设备升级状态到后台服务器。
+     *
+     * @param state
+     * @param resultCode
+     * @param resultMsg
+     * @param version
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportOTAState(String state, int resultCode, String resultMsg, String version) {
+        Status status = Status.ERROR;
+
+
+        if (mUseShadow && null != mShadowConnection) {
+            status = mShadowConnection.getMqttConnection().reportOTAState(TXOTAConstansts.ReportState.valueOf(TXOTAConstansts.ReportState.class, state), resultCode, resultMsg, version);
+        } else if (null != mMqttConnection) {
+            status = mMqttConnection.reportOTAState(TXOTAConstansts.ReportState.valueOf(TXOTAConstansts.ReportState.class, state), resultCode, resultMsg, version);
+        }
+        return status;
+    }
+
+    private String subscribeBroadcastTopic(int qos, long userContextId) {
+        Status status = Status.ERROR;
+        if (!isInit) {
+            TXLog.d(TAG, "device is not initialized!");
+            return status.name();
+        }
+        if (mUseShadow && null != mShadowConnection) {
+            status = mShadowConnection.getMqttConnection().subscribeBroadcastTopic(qos, Long.valueOf(userContextId));
+        } else if (null != mMqttConnection) {
+            status = mMqttConnection.subscribeBroadcastTopic(qos, Long.valueOf(userContextId));
+        }
+        return status.name();
+    }
+
+    private String subscribe(String topic, int qos, long userContextId) {
+        Status status = Status.ERROR;
+        if (!isInit) {
+            TXLog.d(TAG, "device is not initialized!");
+            return status.name();
+        }
+
+        if (mUseShadow && null != mShadowConnection) {
+            status = mShadowConnection.getMqttConnection().subscribe(topic, qos, Long.valueOf(userContextId));
+        } else if (null != mMqttConnection) {
+            status = mMqttConnection.subscribe(topic, qos, Long.valueOf(userContextId));
+        }
+
+        return status.name();
+    }
+
+    private String unSubscribe(String topic, long userContextId) {
+        Status status = Status.ERROR;
+        if (!isInit) {
+            TXLog.d(TAG, "device is not initialized!");
+            return status.name();
+        }
+
+        if (mUseShadow && null != mShadowConnection) {
+            status = mShadowConnection.getMqttConnection().unSubscribe(topic, Long.valueOf(userContextId));
+        } else if (null != mMqttConnection) {
+            status = mMqttConnection.unSubscribe(topic, Long.valueOf(userContextId));
+        }
+
+        return status.name();
+    }
+
+    private String subscribeRRPCTopic(int qos, long userContextId) {
+        Status status = Status.ERROR;
+        if (!isInit) {
+            TXLog.d(TAG, "device is not initialized!");
+            return status.name();
+        }
+
+        if (mUseShadow && null != mShadowConnection) {
+            status = mShadowConnection.getMqttConnection().subscribeRRPCTopic(qos, Long.valueOf(userContextId));
+        } else if (null != mMqttConnection) {
+            status = mMqttConnection.subscribeRRPCTopic(qos, Long.valueOf(userContextId));
+        }
+
+        return status.name();
+    }
+
+    private void handlePublishCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
+        if (null == userContext) {
+            return;
+        }
+
+        if (mUseShadow) {
+            if (null == mShadowActionListener) {
+                TXLog.d(TAG, "ITXShadowActionListener instance is null!");
+                return;
+            }
+
+            try {
+                if (userContext instanceof Long) {
+                    mShadowActionListener.onPublishCompleted(status.name(), new TXMqttToken(token),
+                            ((Long) userContext).longValue(), errMsg);
+                }
+            } catch (RemoteException e) {
+                TXLog.e(TAG, e, "invoke remote method[onPublishCompleted] failed!");
+            } catch (Exception ex) {
+                TXLog.e(TAG, ex, "invoke remote method[onPublishCompleted] failed!");
+            }
+
+            return;
+        }
+
+        if (null == mMqttActionListener) {
+            TXLog.d(TAG, "ITXMqttActionListener instance is null!");
+            return;
+        }
+
+        try {
+            if (userContext instanceof Long) {
+                mMqttActionListener.onPublishCompleted(status.name(), new TXMqttToken(token), ((Long) userContext).longValue(), errMsg);
+            }
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote method[onPublishCompleted] failed!");
+        } catch (Exception ex) {
+            TXLog.e(TAG, ex, "invoke remote method[onPublishCompleted] failed!");
+        }
+    }
+
+    private void handleSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+        if (null == userContext) {
+            return;
+        }
+
+        if (mUseShadow) {
+            if (null == mShadowActionListener) {
+                TXLog.d(TAG, "ITXShadowActionListener instance is null!");
+                return;
+            }
+
+            try {
+                if (userContext instanceof Long) {
+                    mShadowActionListener.onSubscribeCompleted(status.name(), new TXMqttToken(asyncActionToken), ((Long) userContext).longValue(), errMsg);
+                }
+            } catch (RemoteException e) {
+                TXLog.e(TAG, e, "invoke remote method[onSubscribeCompleted] failed!");
+            } catch (Exception ex) {
+                TXLog.e(TAG, ex, "invoke remote method[onSubscribeCompleted] failed!");
+            }
+
+            return;
+        }
+
+        if (null == mMqttActionListener) {
+            TXLog.d(TAG, "ITXMqttActionListener instance is null!");
+            return;
+        }
+
+        try {
+            if (userContext instanceof Long) {
+                mMqttActionListener.onSubscribeCompleted(status.name(), new TXMqttToken(asyncActionToken),
+                        ((Long) userContext).longValue(), errMsg);
+            }
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote method[onSubscribeCompleted] failed!");
+        } catch (Exception ex) {
+            TXLog.e(TAG, ex, "invoke remote method[onSubscribeCompleted] failed!");
+        }
+    }
+
+    private void handleUnSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+        if (null == userContext) {
+            return;
+        }
+
+        if (mUseShadow) {
+            if (null == mShadowActionListener) {
+                TXLog.d(TAG, "ITXShadowActionListener instance is null!");
+                return;
+            }
+
+            try {
+                if (userContext instanceof Long) {
+                    mShadowActionListener.onUnSubscribeCompleted(status.name(), new TXMqttToken(asyncActionToken), ((Long) userContext).longValue(), errMsg);
+                }
+            } catch (RemoteException e) {
+                TXLog.e(TAG, e, "invoke remote method[onUnSubscribeCompleted] failed!");
+            } catch (Exception ex) {
+                TXLog.e(TAG, ex, "invoke remote method[onUnSubscribeCompleted] failed!");
+            }
+
+            return;
+        }
+
+        if (null == mMqttActionListener) {
+            TXLog.d(TAG, "ITXMqttActionListener instance is null!");
+            return;
+        }
+
+        try {
+            if (userContext instanceof Long) {
+                mMqttActionListener.onUnSubscribeCompleted(status.name(), new TXMqttToken(asyncActionToken), ((Long) userContext).longValue(), errMsg);
+            }
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote method[onUnSubscribeCompleted] failed!");
+        } catch (Exception ex) {
+            TXLog.e(TAG, ex, "invoke remote method[onUnSubscribeCompleted] failed!");
+        }
+    }
+
+    private void handleMessageReceived(String topic, MqttMessage message) {
+        if (mUseShadow) {
+            if (null == mShadowActionListener) {
+                TXLog.d(TAG, "ITXShadowActionListener instance is null!");
+                return;
+            }
+
+            try {
+                mShadowActionListener.onMessageReceived(topic, new TXMqttMessage(message));
+            } catch (RemoteException e) {
+                TXLog.e(TAG, e, "invoke remote method[onUnSubscribeCompleted] failed!");
+            } catch (Exception ex) {
+                TXLog.e(TAG, ex, "invoke remote method[onUnSubscribeCompleted] failed!");
+            }
+
+            return;
+        }
+
+
+        if (null == mMqttActionListener) {
+            TXLog.d(TAG, "ITXMqttActionListener instance is null!");
+            return;
+        }
+
+        try {
+            mMqttActionListener.onMessageReceived(topic, new TXMqttMessage(message));
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote method[onMessageReceived] failed!");
+        }
+    }
+
+    private void init() {
+        mContext = this.getApplicationContext();
+
+        mMqttActionCallBack = new TXMqttActionCallBack() {
+            @Override
+            public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {
+                if (null == mMqttActionListener) {
+                    TXLog.d(TAG, "ITXMqttActionListener instance is null!");
+                    return;
+                }
+
+                try {
+                    if (userContext instanceof Long) {
+                        mMqttActionListener.onConnectCompleted(status.name(), reconnect, ((Long) userContext).longValue(), msg);
+                    }
+                } catch (RemoteException e) {
+                    TXLog.e(TAG, e, "invoke remote method[onConnectCompleted] failed!");
+                }
+            }
+
+            @Override
+            public void onConnectionLost(Throwable cause) {
+                if (null == mMqttActionListener) {
+                    TXLog.d(TAG, "ITXMqttActionListener instance is null!");
+                    return;
+                }
+
+                try {
+                    mMqttActionListener.onConnectionLost(cause.getMessage());
+                } catch (RemoteException e) {
+                    TXLog.e(TAG, e, "invoke remote method[onConnectionLost] failed!");
+                }
+            }
+
+            @Override
+            public void onDisconnectCompleted(Status status, Object userContext, String msg) {
+                if (null == mMqttActionListener) {
+                    TXLog.d(TAG, "ITXMqttActionListener instance is null!");
+                    return;
+                }
+
+                try {
+                    if (userContext instanceof Long) {
+                        mMqttActionListener.onDisconnectCompleted(status.name(), ((Long) userContext).longValue(), msg);
+                    }
+                } catch (RemoteException e) {
+                    TXLog.e(TAG, e, "invoke remote method[onDisconnectCompleted] failed!");
+                }
+            }
+
+            @Override
+            public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
+                TXMqttService.this.handlePublishCompleted(status, token, userContext, errMsg);
+            }
+
+            @Override
+            public void onSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+                TXMqttService.this.handleSubscribeCompleted(status, asyncActionToken, userContext, errMsg);
+            }
+
+            @Override
+            public void onUnSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+                TXMqttService.this.handleUnSubscribeCompleted(status, asyncActionToken, userContext, errMsg);
+            }
+
+            @Override
+            public void onMessageReceived(String topic, MqttMessage message) {
+                TXMqttService.this.handleMessageReceived(topic, message);
+            }
+        };
+
+        mShadowActionCallBack = new TXShadowActionCallBack() {
+            @Override
+            public void onRequestCallback(String type, int result, String document) {
+                if (null == mShadowActionListener) {
+                    TXLog.d(TAG, "ITXShadowActionListener instance is null!");
+                    return;
+                }
+
+                try {
+                    mShadowActionListener.onRequestCallback(type, result, document);
+                } catch (RemoteException e) {
+                    TXLog.e(TAG, e, "invoke remote method[onRequestCallback] failed!");
+                }
+            }
+
+            @Override
+            public void onDevicePropertyCallback(String propertyJSONDocument, List<? extends com.tencent.iot.hub.device.java.core.shadow.DeviceProperty> devicePropertyList) {
+                if (null == mShadowActionListener) {
+                    TXLog.d(TAG, "ITXShadowActionListener instance is null!");
+                    return;
+                }
+
+                try {
+                    mShadowActionListener.onDevicePropertyCallback(propertyJSONDocument, (List<DeviceProperty>) devicePropertyList);
+                } catch (RemoteException e) {
+                    TXLog.e(TAG, e, "invoke remote method[onRequestCallback] failed!");
+                }
+            }
+
+            @Override
+            public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
+                TXMqttService.this.handlePublishCompleted(status, token, userContext, errMsg);
+            }
+
+            @Override
+            public void onSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+                TXMqttService.this.handleSubscribeCompleted(status, asyncActionToken, userContext, errMsg);
+            }
+
+            @Override
+            public void onUnSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
+                TXMqttService.this.handleUnSubscribeCompleted(status, asyncActionToken, userContext, errMsg);
+            }
+
+            @Override
+            public void onMessageReceived(String topic, MqttMessage message) {
+                TXMqttService.this.handleMessageReceived(topic, message);
+            }
+        };
+
+        mMqttService = new ITXMqttService.Stub() {
+            @Override
+            public void registerMqttActionListener(ITXMqttActionListener mqttActionListener) throws RemoteException {
+                mMqttActionListener = mqttActionListener;
+            }
+
+            @Override
+            public void registerShadowActionListener(ITXShadowActionListener shadowActionListener) throws RemoteException {
+                mShadowActionListener = shadowActionListener;
+            }
+
+            /**
+             * 初始化设备信息
+             *
+             * @param mqttClientOptions   mqtt客户端选项
+             * @throws RemoteException
+             */
+            @Override
+            public void initDeviceInfo(TXMqttClientOptions mqttClientOptions) throws RemoteException {
+                TXMqttService.this.initDeviceInfo(mqttClientOptions);
+            }
+
+            @Override
+            public void setBufferOpts(TXDisconnectedBufferOptions bufferOptions) throws RemoteException {
+                if (mUseShadow && null != mShadowConnection) {
+                    mShadowConnection.setBufferOpts(bufferOptions.transToDisconnectedBufferOptions());
+                } else if (null != mMqttConnection) {
+                    mMqttConnection.setBufferOpts(bufferOptions.transToDisconnectedBufferOptions());
+                }
+            }
+
+            @Override
+            public String connect(TXMqttConnectOptions options, long userContextId) throws RemoteException {
+                return TXMqttService.this.connect(options, userContextId);
+            }
+
+            @Override
+            public String reconnect() throws RemoteException {
+                return TXMqttService.this.reconnect();
+            }
+
+            @Override
+            public String disConnect(long timeout, long userContextId) throws RemoteException {
+                return TXMqttService.this.disConnect(timeout, userContextId);
+            }
+
+            @Override
+            public String subscribeBroadcastTopic(int qos, long userContextId) throws RemoteException {
+                return TXMqttService.this.subscribeBroadcastTopic(qos, userContextId);
+            }
+
+            @Override
+            public String subscribe(String topic, int qos, long userContextId) throws RemoteException {
+                return TXMqttService.this.subscribe(topic, qos, userContextId);
+            }
+
+            @Override
+            public String unSubscribe(String topic, long userContextId) throws RemoteException {
+                return TXMqttService.this.unSubscribe(topic, userContextId);
+            }
+
+            @Override
+            public String publish(String topic, TXMqttMessage message, long userContextId) throws RemoteException {
+                return TXMqttService.this.publish(topic, message, userContextId);
+            }
+
+            @Override
+            public String subscribeRRPCTopic(int qos, long userContextId) throws RemoteException {
+                return TXMqttService.this.subscribeRRPCTopic(qos, userContextId);
+            }
+
+            @Override
+            public String getConnectStatus() throws RemoteException {
+                return mShadowConnection.getConnectStatus().name();
+            }
+
+            @Override
+            public String updateShadow(List<DeviceProperty> devicePropertyList, long userContextId) throws RemoteException {
+                for (DeviceProperty deviceProperty : devicePropertyList) {
+                    TXLog.d(TAG, "updateShadow, deviceProperty[%s]", deviceProperty.toString());
+
+                    if (deviceProperty.mDataType == TXShadowConstants.JSONDataType.OBJECT) {
+                        try {
+                            deviceProperty.mData = new JSONObject((String) deviceProperty.mData);
+                        }catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                    }else if (deviceProperty.mDataType == TXShadowConstants.JSONDataType.ARRAY) {
+                        try {
+                            deviceProperty.mData = new JSONArray((String) deviceProperty.mData);
+                        }catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                    }
+                }
+
+                Status status = Status.ERROR;
+                if (mUseShadow && null != mShadowConnection) {
+                    status = mShadowConnection.update(devicePropertyList, Long.valueOf(userContextId));
+                }
+                return status.name();
+            }
+
+            @Override
+            public String getShadow(long userContextId) throws RemoteException {
+                Status status = Status.ERROR;
+                if (mUseShadow && null != mShadowConnection) {
+                    status = mShadowConnection.get(Long.valueOf(userContextId));
+                }
+                return status.name();
+            }
+
+            @Override
+            public void registerDeviceProperty(DeviceProperty deviceProperty) throws RemoteException {
+                if (mUseShadow && null != mShadowConnection) {
+                    mShadowConnection.registerProperty(deviceProperty);
+                }
+            }
+
+            @Override
+            public void unRegisterDeviceProperty(DeviceProperty deviceProperty) throws RemoteException {
+                if (mUseShadow && null != mShadowConnection) {
+                    mShadowConnection.unRegisterProperty(deviceProperty);
+                }
+            }
+
+            @Override
+            public String reportNullDesiredInfo(String reportJsonDoc) throws RemoteException {
+                Status status = Status.ERROR;
+                if (mUseShadow && null != mShadowConnection) {
+                    if (TextUtils.isEmpty(reportJsonDoc)) {
+                        status = mShadowConnection.reportNullDesiredInfo();
+                    } else {
+                        status = mShadowConnection.reportNullDesiredInfo(reportJsonDoc);
+                    }
+                }
+                return status.name();
+            }
+
+            @Override
+            public void initOTA(String storagePath, ITXOTAListener listener) throws RemoteException {
+
+                TXMqttService.this.initOTA(storagePath, listener);
+            }
+
+            @Override
+            public String reportCurrentFirmwareVersion(String currentFirmwareVersion) throws RemoteException {
+                Status status = TXMqttService.this.reportCurrentFirmwareVersion(currentFirmwareVersion);
+                return status.name();
+            }
+
+            @Override
+            public String reportOTAState(String state, int resultCode, String resultMsg, String version) throws RemoteException {
+                Status status = TXMqttService.this.reportOTAState(state, resultCode, resultMsg, version);
+                return status.name();
+            }
+        };
+    }
+
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/HmacSha1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/HmacSha1.java	(date 1606400383021)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/HmacSha1.java	(date 1606400383021)
@@ -0,0 +1,50 @@
+package com.tencent.iot.hub.device.android.core.util;
+
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+
+public class HmacSha1 {
+
+    private static final String HMAC_SHA1= "HmacSHA1";
+
+    /**
+     * 生成签名数据
+     *
+     * @param data 待加密的数据
+     * @param key  加密使用的key
+     * @return 生成16进制编码的字符串
+     */
+    public static String getSignature(byte[] data, byte[] key)  {
+        try {
+            SecretKeySpec signingKey = new SecretKeySpec(key, HMAC_SHA1);
+            Mac mac = Mac.getInstance(HMAC_SHA1);
+            mac.init(signingKey);
+
+            byte[] rawHmac = mac.doFinal(data);
+
+            return bytesToHexString(rawHmac);
+        }catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        return null;
+    }
+
+    /**
+     * byte[]数组转换为16进制的字符串
+     *
+     * @param bytes 要转换的字节数组
+     * @return 转换后的结果
+     */
+    private static String bytesToHexString(byte[] bytes) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < bytes.length; i++) {
+            String hex = Integer.toHexString(0xFF & bytes[i]);
+            if (hex.length() == 1) {
+                sb.append('0');
+            }
+            sb.append(hex);
+        }
+        return sb.toString();
+    }
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/TXLog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/TXLog.java	(date 1606400383021)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/TXLog.java	(date 1606400383021)
@@ -0,0 +1,242 @@
+package com.tencent.iot.hub.device.android.core.util;
+
+import android.content.Context;
+import android.os.Looper;
+import android.os.Process;
+import android.util.Log;
+
+public class TXLog {
+    private static final String TAG = "mars.xlog.log";
+
+    public static final int LEVEL_VERBOSE = 0;
+    public static final int LEVEL_DEBUG = 1;
+    public static final int LEVEL_INFO = 2;
+    public static final int LEVEL_WARNING = 3;
+    public static final int LEVEL_ERROR = 4;
+    public static final int LEVEL_FATAL = 5;
+    public static final int LEVEL_NONE = 6;
+
+    public static Context toastSupportContext = null;
+
+    public interface LogImp {
+
+        void logV(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log);
+
+        void logI(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log);
+
+        void logD(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log);
+
+        void logW(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log);
+
+        void logE(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log);
+
+        void logF(String tag, String filename, String funcname, int line, int pid, long tid, long maintid, String log);
+
+        int getLogLevel();
+
+        void setLogLevel(final int level);
+
+    }
+
+    private static LogImp logImp = new TXLogImpl();
+
+    public static void setLogImp(LogImp imp) {
+        logImp = imp;
+    }
+
+    public static LogImp getImpl() {
+        return logImp;
+    }
+
+    public static int getLogLevel() {
+        if (logImp != null) {
+            return logImp.getLogLevel();
+        }
+        return LEVEL_NONE;
+    }
+
+    public static void setLevel(final int level) {
+        logImp.setLogLevel(level);
+    }
+
+    /**
+     * use f(tag, format, obj) instead
+     *
+     * @param tag
+     * @param msg
+     */
+    public static void f(final String tag, final String msg) {
+        f(tag, msg, (Object[]) null);
+    }
+
+    /**
+     * use e(tag, format, obj) instead
+     *
+     * @param tag
+     * @param msg
+     */
+    public static void e(final String tag, final String msg) {
+        e(tag, msg, (Object[]) null);
+    }
+
+    public static void e(final String tag, final String msg, Throwable tr) {
+        e(tag, tr, msg, (Object[]) null);
+    }
+
+    /**
+     * use w(tag, format, obj) instead
+     *
+     * @param tag
+     * @param msg
+     */
+    public static void w(final String tag, final String msg) {
+        w(tag, msg, (Object[]) null);
+    }
+
+    /**
+     * use i(tag, format, obj) instead
+     *
+     * @param tag
+     * @param msg
+     */
+    public static void i(final String tag, final String msg) {
+        i(tag, msg, (Object[]) null);
+    }
+
+    /**
+     * use d(tag, format, obj) instead
+     *
+     * @param tag
+     * @param msg
+     */
+    public static void d(final String tag, final String msg) {
+        d(tag, msg, (Object[]) null);
+    }
+
+    /**
+     * use v(tag, format, obj) instead
+     *
+     * @param tag
+     * @param msg
+     */
+    public static void v(final String tag, final String msg) {
+        v(tag, msg, (Object[]) null);
+    }
+
+    public static void f(String tag, final String format, final Object... obj) {
+        if (logImp != null) {
+            final String log = obj == null ? format : String.format(format, obj);
+            logImp.logF(tag, "", "", 0, Process.myPid(), Thread.currentThread().getId(), Looper.getMainLooper().getThread().getId(), log);
+        }
+    }
+
+    public static void e(String tag, final String format, final Object... obj) {
+        if (logImp != null) {
+            String log = obj == null ? format : String.format(format, obj);
+            if (log == null) {
+                log = "";
+            }
+
+            Log.e(tag, log);
+
+            logImp.logE(tag, "", "", 0, Process.myPid(), Thread.currentThread().getId(), Looper.getMainLooper().getThread().getId(), log);
+        }
+    }
+
+    public static void w(String tag, final String format, final Object... obj) {
+        if (logImp != null) {
+            String log = obj == null ? format : String.format(format, obj);
+            if (log == null) {
+                log = "";
+            }
+
+            Log.w(tag, log);
+
+            logImp.logW(tag, "", "", 0, Process.myPid(), Thread.currentThread().getId(), Looper.getMainLooper().getThread().getId(), log);
+        }
+    }
+
+    public static void i(String tag, final String format, final Object... obj) {
+        if (logImp != null) {
+            String log = obj == null ? format : String.format(format, obj);
+            if (log == null) {
+                log = "";
+            }
+
+            Log.i(tag, log);
+
+            logImp.logI(tag, "", "", 0, Process.myPid(), Thread.currentThread().getId(), Looper.getMainLooper().getThread().getId(), log);
+        }
+    }
+
+    public static void d(String tag, final String format, final Object... obj) {
+        if (logImp != null) {
+            String log = obj == null ? format : String.format(format, obj);
+            if (log == null) {
+                log = "";
+            }
+
+            Log.d(tag, log);
+
+            logImp.logD(tag, "", "", 0, Process.myPid(), Thread.currentThread().getId(), Looper.getMainLooper().getThread().getId(), log);
+        }
+    }
+
+    public static void v(String tag, final String format, final Object... obj) {
+        if (logImp != null) {
+            String log = obj == null ? format : String.format(format, obj);
+            if (log == null) {
+                log = "";
+            }
+
+            Log.v(tag, log);
+
+            logImp.logV(tag, "", "", 0, Process.myPid(), Thread.currentThread().getId(), Looper.getMainLooper().getThread().getId(), log);
+        }
+    }
+
+    public static void e(String tag, Throwable tr, final String format, final Object... obj) {
+        if (logImp != null) {
+            String log = obj == null ? format : String.format(format, obj);
+            if (log == null) {
+                log = "";
+            }
+
+            Log.e(tag, log, tr);
+
+            log += "\n" + Log.getStackTraceString(tr);
+            logImp.logE(tag, "", "", 0, Process.myPid(), Thread.currentThread().getId(), Looper.getMainLooper().getThread().getId(), log);
+        }
+    }
+
+    private static final String SYS_INFO;
+
+    static {
+        final StringBuilder sb = new StringBuilder();
+        try {
+            sb.append("VERSION.RELEASE:[" + android.os.Build.VERSION.RELEASE);
+            sb.append("] VERSION.CODENAME:[" + android.os.Build.VERSION.CODENAME);
+            sb.append("] VERSION.INCREMENTAL:[" + android.os.Build.VERSION.INCREMENTAL);
+            sb.append("] BOARD:[" + android.os.Build.BOARD);
+            sb.append("] DEVICE:[" + android.os.Build.DEVICE);
+            sb.append("] DISPLAY:[" + android.os.Build.DISPLAY);
+            sb.append("] FINGERPRINT:[" + android.os.Build.FINGERPRINT);
+            sb.append("] HOST:[" + android.os.Build.HOST);
+            sb.append("] MANUFACTURER:[" + android.os.Build.MANUFACTURER);
+            sb.append("] MODEL:[" + android.os.Build.MODEL);
+            sb.append("] PRODUCT:[" + android.os.Build.PRODUCT);
+            sb.append("] TAGS:[" + android.os.Build.TAGS);
+            sb.append("] TYPE:[" + android.os.Build.TYPE);
+            sb.append("] USER:[" + android.os.Build.USER + "]");
+        } catch (Throwable e) {
+            e.printStackTrace();
+        }
+
+        SYS_INFO = sb.toString();
+    }
+
+    public static String getSysInfo() {
+        return SYS_INFO;
+    }
+}
+
Index: iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttMessage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttMessage.java	(date 1606400383033)
+++ iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttMessage.java	(date 1606400383033)
@@ -0,0 +1,124 @@
+package com.tencent.iot.hub.device.android.service;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+
+import java.util.Arrays;
+
+/**
+ * 该类负责序列化MqttMessage相关信息
+ */
+
+public class TXMqttMessage implements Parcelable {
+    private byte[] mPayload;
+    private int mQos = 1;
+    private boolean mRetained = false;
+    private int mMessageId;
+
+    protected TXMqttMessage(Parcel in) {
+        mPayload = in.createByteArray();
+        mQos = in.readInt();
+        mRetained = in.readByte() != 0;
+        mMessageId = in.readInt();
+    }
+
+    public TXMqttMessage() {
+        setPayload(new byte[]{});
+    }
+
+    public TXMqttMessage(MqttMessage mqttMessage) {
+        mPayload = mqttMessage.getPayload();
+        mQos = mqttMessage.getQos();
+        mRetained = mqttMessage.isRetained();
+        mMessageId = mqttMessage.getId();
+    }
+
+    public static final Creator<TXMqttMessage> CREATOR = new Creator<TXMqttMessage>() {
+        @Override
+        public TXMqttMessage createFromParcel(Parcel in) {
+            return new TXMqttMessage(in);
+        }
+
+        @Override
+        public TXMqttMessage[] newArray(int size) {
+            return new TXMqttMessage[size];
+        }
+    };
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel parcel, int i) {
+        parcel.writeByteArray(mPayload);
+        parcel.writeInt(mQos);
+        parcel.writeByte((byte) (mRetained ? 1 : 0));
+        parcel.writeInt(mMessageId);
+    }
+
+    public void readFromParcel(Parcel in) {
+        mPayload = in.createByteArray();
+        mQos = in.readInt();
+        mRetained = in.readByte() != 0;
+        mMessageId = in.readInt();
+    }
+
+    public MqttMessage transToMqttMessage() {
+        MqttMessage mqttMessage = new MqttMessage();
+        mqttMessage.setQos(mQos);
+        mqttMessage.setPayload(mPayload);
+        mqttMessage.setId(mMessageId);
+        mqttMessage.setRetained(mRetained);
+        return mqttMessage;
+    }
+
+    public byte[] getPayload() {
+        return mPayload;
+    }
+
+    public TXMqttMessage setPayload(byte[] payload) {
+        this.mPayload = payload;
+        return this;
+    }
+
+    public int getQos() {
+        return mQos;
+    }
+
+    public TXMqttMessage setQos(int qos) {
+        this.mQos = qos;
+        return this;
+    }
+
+    public boolean isRetained() {
+        return mRetained;
+    }
+
+    public TXMqttMessage setRetained(boolean retained) {
+        this.mRetained = retained;
+        return this;
+    }
+
+    public int getMessageId() {
+        return mMessageId;
+    }
+
+    public TXMqttMessage setMessageId(int messageId) {
+        this.mMessageId = messageId;
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return "TXMqttMessage{" +
+                ", mPayload=" + Arrays.toString(mPayload) +
+                ", mQos=" + mQos +
+                ", mRetained=" + mRetained +
+                ", mMessageId=" + mMessageId +
+                '}';
+    }
+}
Index: iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttClient.java	(date 1606400383033)
+++ iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttClient.java	(date 1606400383033)
@@ -0,0 +1,675 @@
+package com.tencent.iot.hub.device.android.service;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.RemoteException;
+
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTACallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXOTAConstansts;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * mqtt远程服务客户端
+ */
+
+public class TXMqttClient {
+
+    private static final String TAG = TXMqttClient.class.getSimpleName();
+
+    private Context mContext = null;
+
+    /**
+     * mqtt客户端选项
+     */
+    private TXMqttClientOptions mMqttClientOptions = null;
+
+    private Intent mServiceIntent = null;
+
+    /**
+     * 内部service连接回调接口
+     */
+    private ServiceConnection mInternalServiceConnection = null;
+
+    /**
+     * 外部service连接回调接口，用于回调service连接状态，便于外部进行mqtt操作
+     */
+    private ServiceConnection mExternalServiceConnection = null;
+
+    /**
+     * mqttAction监听器，用于跨进程调用
+     */
+    private ITXMqttActionListener mMqttActionListener = null;
+
+    /**
+     * mqttAction回调接口，用于外部回调
+     */
+    private TXMqttActionCallBack mMqttActionCallBack = null;
+
+    private AtomicLong mRequestId = null;
+
+    /**
+     * 因userContext在外部定义，sdk内部不便于实现序列化。
+     * 因此在客户端保存requestId与userContext的映射关系，在跨进程调用时通过requestId代替userContext进行传递。
+     */
+    private Map<Long, Object> mUserContextMap = null;
+
+    /**
+     * mqtt远程服务
+     */
+    protected ITXMqttService mRemoteServer = null;
+
+    private TXOTACallBack mOTACallback = null;
+
+    private ITXOTAListener mOTAListener = new ITXOTAListener.Stub() {
+        @Override
+        public void onReportFirmwareVersion(int resultCode, String version, String resultMsg) {
+            if (mOTACallback != null) {
+                mOTACallback.onReportFirmwareVersion(resultCode, version, resultMsg);
+            }
+        }
+
+        @Override
+        public void onDownloadProgress(int percent, String version) throws RemoteException {
+            if (mOTACallback != null) {
+                mOTACallback.onDownloadProgress(percent, version);
+            }
+        }
+
+        @Override
+        public void onDownloadCompleted(String outputFile, String version) throws RemoteException {
+            if (mOTACallback != null) {
+                mOTACallback.onDownloadCompleted(outputFile, version);
+            }
+        }
+
+        @Override
+        public void onDownloadFailure(int errCode, String version) throws RemoteException {
+            if (mOTACallback != null) {
+                mOTACallback.onDownloadFailure(errCode, version);
+            }
+        }
+    };
+
+    public TXMqttClient() {
+    }
+
+    /**
+     * 设置MqttAction回调接口
+     *
+     * @param mMqttActionCallBack mqttAction回调接口
+     * @return
+     */
+    public TXMqttClient setMqttActionCallBack(TXMqttActionCallBack mMqttActionCallBack) {
+        this.mMqttActionCallBack = mMqttActionCallBack;
+        return this;
+    }
+
+    /**
+     * 设置远程服务连接回调接口
+     *
+     * @param serviceConnection 远程服务连接回调接口
+     * @return
+     */
+    public TXMqttClient setServiceConnection(ServiceConnection serviceConnection) {
+        mExternalServiceConnection = serviceConnection;
+        return this;
+    }
+
+    /**
+     * 初始化远程服务客户端
+     *
+     * @param context
+     * @param clientOptions 客户端选项
+     */
+    public void init(Context context, TXMqttClientOptions clientOptions) {
+
+        internalInit(context, clientOptions);
+
+        mInternalServiceConnection = new ServiceConnection() {
+
+            @Override
+            public void onServiceDisconnected(ComponentName name) {
+                TXLog.d(TAG, "onServiceDisconnected, ComponentName[%s]", name.getClassName());
+                mRemoteServer = null;
+                if (null != mExternalServiceConnection) {
+                    mExternalServiceConnection.onServiceDisconnected(name);
+                }
+            }
+
+            @Override
+            public void onServiceConnected(ComponentName name, IBinder service) {
+                TXLog.d(TAG, "onServiceConnected, ComponentName[%s]", name.getClassName());
+
+                if (null != mExternalServiceConnection) {
+                    mExternalServiceConnection.onServiceConnected(name, null);
+                }
+
+                // 再次开启远程服务时，会回调ITXMqttActionListener.aidl的onServiceStartedCallback()接口，用于返回服务已开启状态
+                // 同时该接口会调用mInternalServiceConnection的onServiceConnected()接口，此时传递的IBinder为null，因此需判断service是否为空。
+                if (null == service) {
+                    return;
+                }
+
+                mRemoteServer = ITXMqttService.Stub.asInterface(service);
+
+                try {
+                    mRemoteServer.registerMqttActionListener(mMqttActionListener);
+                    mRemoteServer.initDeviceInfo(mMqttClientOptions);
+                } catch (RemoteException e) {
+                    TXLog.e(TAG, e, "invoke remote service failed!");
+                }
+            }
+        };
+    }
+
+    /**
+     * 初始化远程服务客户端（内部接口不对外，仅供TXShadowClient调用）
+     *
+     * @param context
+     * @param clientOptions        客户端选项
+     * @param shadowActionListener shadowAction监听器
+     */
+    protected void init(Context context, TXMqttClientOptions clientOptions, final ITXShadowActionListener shadowActionListener) {
+
+        internalInit(context, clientOptions);
+
+        mInternalServiceConnection = new ServiceConnection() {
+
+            @Override
+            public void onServiceDisconnected(ComponentName name) {
+                TXLog.d(TAG, "onServiceDisconnected, ComponentName[%s]", name.getClassName());
+                mRemoteServer = null;
+
+                if (null != mExternalServiceConnection) {
+                    mExternalServiceConnection.onServiceDisconnected(name);
+                }
+            }
+
+            @Override
+            public void onServiceConnected(ComponentName name, IBinder service) {
+                TXLog.d(TAG, "onServiceConnected, ComponentName[%s]", name.getClassName());
+
+                // 再次开启远程服务时，会回调ITXMqttActionListener.aidl的onServiceStartedCallback()接口，用于返回服务已开启状态
+                // 同时该接口会调用mInternalServiceConnection的onServiceConnected()接口，此时传递的IBinder为null，因此需判断service是否为空。
+                if (null == service) {
+                    if (null != mExternalServiceConnection) {
+                        mExternalServiceConnection.onServiceConnected(name, null);
+                    }
+
+                    return;
+                }
+
+                mRemoteServer = ITXMqttService.Stub.asInterface(service);
+
+                try {
+                    mRemoteServer.registerMqttActionListener(mMqttActionListener);
+                    mRemoteServer.registerShadowActionListener(shadowActionListener);
+                    mRemoteServer.initDeviceInfo(mMqttClientOptions);
+
+                } catch (RemoteException e) {
+                    TXLog.e(TAG, e, "invoke remote service failed!");
+                }
+
+                if (null != mExternalServiceConnection) {
+                    mExternalServiceConnection.onServiceConnected(name, null);
+                }
+            }
+        };
+
+    }
+
+    /**
+     * 开启远程服务
+     */
+    public void startRemoteService() {
+        if (null == mContext) {
+            TXLog.e(TAG, "TXMqttClient is not initialized!");
+            return;
+        }
+
+        if (null == mServiceIntent) {
+            mServiceIntent = new Intent(mContext, TXMqttService.class);
+        }
+
+        try {
+            mContext.startService(mServiceIntent);
+            mContext.bindService(mServiceIntent, mInternalServiceConnection, Context.BIND_AUTO_CREATE);
+        } catch (Exception e) {
+            TXLog.e(TAG, e, "start remote service failed!");
+        }
+    }
+
+    /**
+     * 停止远程服务
+     */
+    public void stopRemoteService() {
+        if (null == mContext || null == mRemoteServer) {
+            TXLog.e(TAG, "remote service is not start!");
+            return;
+        }
+
+        try {
+            mContext.unbindService(mInternalServiceConnection);
+            mContext.stopService(mServiceIntent);
+        } catch (Exception e) {
+            TXLog.e(TAG, e, "stop and unbind remote service is failed!");
+        }
+    }
+
+    /**
+     * 设置断连状态buffer缓冲区
+     *
+     * @param bufferOpts
+     */
+    public void setBufferOpts(TXDisconnectedBufferOptions bufferOpts) {
+        if (null == bufferOpts) {
+            return;
+        }
+        try {
+            mRemoteServer.setBufferOpts(bufferOpts);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[setBufferOpts] failed!");
+        }
+    }
+
+    /**
+     * 连接MQTT服务器，结果通过回调函数通知。
+     *
+     * @param connectOptions 连接参数
+     * @param userContext    用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status connect(TXMqttConnectOptions connectOptions, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            TXLog.e(TAG, "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+
+        try {
+            String statusStr = mRemoteServer.connect(connectOptions, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[connect] failed!");
+        }
+
+        return status;
+    }
+
+    /**
+     * 重新连接, 结果通过回调函数通知。
+     *
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reconnect() {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            TXLog.e(TAG, "remote service is not start!");
+            return status;
+        }
+
+        try {
+            String statusStr = mRemoteServer.reconnect();
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[reconnect] failed!");
+        }
+
+        return status;
+    }
+
+    /**
+     * MQTT断连，结果通过回调函数通知。
+     *
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status disConnect(Object userContext) {
+        return disConnect(0, userContext);
+    }
+
+    /**
+     * MQTT断连, 结果通过回调函数通知。
+     *
+     * @param timeout     等待时间（必须大于0）。单位：毫秒
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status disConnect(long timeout, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            TXLog.e(TAG, "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        try {
+            String statusStr = mRemoteServer.disConnect(timeout, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[disConnect] failed!");
+        }
+        return status;
+    }
+
+    /**
+     * 订阅广播Topic, 结果通过回调函数通知。
+     * 广播Topic格式: $broadcast/rxd/${ProductId}/${DeviceName}
+     *
+     * @param qos         QOS等级
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status subscribeBroadcastTopic(final int qos, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            TXLog.e(TAG, "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        String broadCastTopic = String.format("$broadcast/rxd/%s/%s", mMqttClientOptions.getProductId(),
+                mMqttClientOptions.getDeviceName());
+        try {
+            String statusStr = mRemoteServer.subscribe(broadCastTopic, qos, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[subscribe] failed!");
+        }
+        return status;
+    }
+
+    /**
+     * 订阅Topic, 结果通过回调函数通知。
+     *
+     * @param topic       topic名称
+     * @param qos         QOS等级
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status subscribe(String topic, int qos, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            TXLog.e(TAG, "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        try {
+            String statusStr = mRemoteServer.subscribe(topic, qos, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[subscribe] failed!");
+        }
+        return status;
+    }
+
+    /**
+     * 取消订阅主题, 结果通过回调函数通知。
+     *
+     * @param topic       要取消订阅的主题
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status unSubscribe(String topic, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            TXLog.e(TAG, "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        try {
+            String statusStr = mRemoteServer.unSubscribe(topic, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[unSubscribe] failed!");
+        }
+
+        return status;
+    }
+
+    /**
+     * 发布MQTT消息接口, 结果通过回调函数通知。
+     *
+     * @param topic       topic名称
+     * @param message     消息内容
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status publish(String topic, TXMqttMessage message, Object userContext) {
+        Status status = Status.ERROR;
+        if (null == mRemoteServer) {
+            TXLog.e(TAG, "remote service is not start!");
+            return status;
+        }
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        try {
+            String statusStr = mRemoteServer.publish(topic, message, requestId);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[publish] failed!");
+        }
+
+        return status;
+    }
+
+    /**
+     * 订阅RRPC主题, 结果通过回调函数通知。
+     * topic格式: $rrpc/rxd/${ProductId}/${DeviceName}/+
+     *
+     * @param qos         QOS等级
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status subscribeRRPCTopic(int qos, Object userContext) {
+        String rrpcTopic = String.format("$rrpc/rxd/%s/%s/+", mMqttClientOptions.getProductId(),
+                mMqttClientOptions.getDeviceName());
+        return subscribe(rrpcTopic, qos, userContext);
+    }
+
+    /**
+     * 释放资源
+     */
+    public void clear() {
+        mUserContextMap.clear();
+    }
+
+
+    /**
+     * 初始化OTA功能。
+     *
+     * @param storagePath OTA升级包存储路径(调用者必须确保路径已存在，并且具有写权限)
+     * @param callback    OTA事件回调
+     */
+    public void initOTA(String storagePath, TXOTACallBack callback) {
+        mOTACallback = callback;
+
+        try {
+            mRemoteServer.initOTA(storagePath, mOTAListener);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[initOTA] failed!");
+        }
+    }
+
+    /**
+     * 上报设备当前版本信息到后台服务器。
+     *
+     * @param currentFirmwareVersion 设备当前版本信息
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportCurrentFirmwareVersion(String currentFirmwareVersion)  {
+        Status status = Status.ERROR;
+
+        try {
+            String statusStr = mRemoteServer.reportCurrentFirmwareVersion(currentFirmwareVersion);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[reportCurrentFirmwareVersion] failed!");
+        }
+
+        return status;
+    }
+
+    /**
+     * 上报设备升级状态到后台服务器。
+     *
+     * @param state 状态
+     * @param resultCode 结果代码。0：表示成功；其它：表示失败；常见错误码：-1:下载超时; -2:文件不存在；-3:签名过期；-4:校验错误；-5:更新固件失败
+     * @param resultMsg 结果描述
+     * @param version 版本号
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportOTAState(TXOTAConstansts.ReportState state, int resultCode, String resultMsg, String version) {
+        Status status = Status.ERROR;
+
+        try {
+            String statusStr = mRemoteServer.reportOTAState(state.name(), resultCode, resultMsg, version);
+            status = Status.valueOf(Status.class, statusStr);
+        } catch (RemoteException e) {
+            TXLog.e(TAG, e, "invoke remote service[reportOTAState] failed!");
+        }
+
+        return status;
+    }
+
+    /**
+     * 添加用户上下文
+     *
+     * @param userContext
+     * @return
+     */
+    protected long addUserContext(Object userContext) {
+        long requestId = mRequestId.getAndIncrement();
+        mUserContextMap.put(requestId, userContext);
+        return requestId;
+    }
+
+    /**
+     * 获取用户上下文
+     *
+     * @param userContextId
+     * @return
+     */
+    protected Object getUserContext(long userContextId) {
+        return mUserContextMap.get(userContextId);
+    }
+
+    /**
+     * 内部初始化
+     */
+    private void internalInit(Context context, TXMqttClientOptions clientOptions) {
+        mContext = context.getApplicationContext();
+        mMqttClientOptions = clientOptions;
+        mUserContextMap = new HashMap<Long, Object>();
+        mRequestId = new AtomicLong(0);
+
+        mMqttActionListener = new ITXMqttActionListener.Stub() {
+
+            @Override
+            public void onConnectCompleted(String status, boolean reconnect, long userContextId, String msg) throws RemoteException {
+                TXLog.d(TAG, "onConnectCompleted, status[%s], reconnect[%b], msg[%s]", status, reconnect, msg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onConnectCompleted(Status.valueOf(Status.class, status),
+                            reconnect, userContext, msg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            @Override
+            public void onConnectionLost(String cause) throws RemoteException {
+                TXLog.d(TAG, "onConnectionLost, cause[%s]", cause);
+                if (null != mMqttActionCallBack) {
+                    mMqttActionCallBack.onConnectionLost(new Throwable(cause));
+                }
+            }
+
+            @Override
+            public void onDisconnectCompleted(String status, long userContextId, String msg) throws RemoteException {
+                TXLog.d(TAG, "onDisconnectCompleted, status[%s], msg[%s]", status, msg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onDisconnectCompleted(Status.valueOf(Status.class, status), userContext, msg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            @Override
+            public void onPublishCompleted(String status, TXMqttToken token, long userContextId, String errMsg) throws RemoteException {
+                TXLog.d(TAG, "onPublishCompleted, status[%s], token[%s], errMsg[%s]", status, token, errMsg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onPublishCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(), userContext, errMsg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            @Override
+            public void onSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg) throws RemoteException {
+                TXLog.d(TAG, "onSubscribeCompleted, status[%s], token[%s], errMsg[%s]", status, token, errMsg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onSubscribeCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(), userContext, errMsg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            @Override
+            public void onUnSubscribeCompleted(String status, TXMqttToken token, long userContextId, String errMsg) throws RemoteException {
+                TXLog.d(TAG, "onUnSubscribeCompleted, status[%s], token[%s], errMsg[%s]", status, token, errMsg);
+                if (null != mMqttActionCallBack) {
+                    Object userContext = mUserContextMap.get(Long.valueOf(userContextId));
+                    mMqttActionCallBack.onUnSubscribeCompleted(Status.valueOf(Status.class, status), token.transToMqttToken(), userContext, errMsg);
+                    mUserContextMap.remove(Long.valueOf(userContextId));
+                }
+            }
+
+            @Override
+            public void onMessageReceived(String topic, TXMqttMessage message) throws RemoteException {
+                TXLog.d(TAG, "onMessageReceived, topic[%s], message[%s]", topic, message);
+                if (null != mMqttActionCallBack) {
+                    mMqttActionCallBack.onMessageReceived(topic, message.transToMqttMessage());
+                }
+            }
+
+            @Override
+            public void onServiceStartedCallback() throws RemoteException {
+                if (null != mInternalServiceConnection) {
+                    ComponentName componentName = null;
+                    if (null != mServiceIntent) {
+                        componentName = mServiceIntent.getComponent();
+                    }
+                    if (null != componentName) {
+                        mInternalServiceConnection.onServiceConnected(componentName, null);
+                    }
+                }
+            }
+
+            @Override
+            public void onServiceDestroyCallback() throws RemoteException {
+                TXLog.d(TAG, "onServiceDestroyCallback");
+                if (null != mInternalServiceConnection) {
+                    ComponentName componentName = null;
+                    if (null != mServiceIntent) {
+                        componentName = mServiceIntent.getComponent();
+                    }
+                    if (null != componentName) {
+                        mInternalServiceConnection.onServiceDisconnected(componentName);
+                    }
+                }
+            }
+        };
+    }
+}
Index: iot_service/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/AndroidManifest.xml	(date 1606400383027)
+++ iot_service/src/main/AndroidManifest.xml	(date 1606400383027)
@@ -0,0 +1,10 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+
+    package="com.tencent.iot.hub.device.android.service">
+
+    <application android:allowBackup="true" android:label="@string/app_name"
+        android:supportsRtl="true">
+
+    </application>
+
+</manifest>
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/dynreg/TXMqttDynregCallback.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/dynreg/TXMqttDynregCallback.java	(date 1606400383017)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/dynreg/TXMqttDynregCallback.java	(date 1606400383017)
@@ -0,0 +1,34 @@
+package com.tencent.iot.hub.device.android.core.dynreg;
+
+/**
+ * Created by willssong on 2019/7/15
+ * willssong@tencent.com
+ */
+public abstract class TXMqttDynregCallback {
+
+    /**
+     * Callback on getting device PSK
+     * @param devicePsk
+     */
+    public abstract void onGetDevicePSK(String devicePsk);
+
+    /**
+     * Callback on getting deivce cert and priv
+     * @param deivceCert
+     * @param devicePriv
+     */
+    public abstract void onGetDeviceCert(String deivceCert, String devicePriv);
+
+    /**
+     * Callback on dynamic register failed
+     * @param cause
+     * @param errMsg
+     */
+    public abstract void onFailedDynreg(Throwable cause, String errMsg);
+
+    /**
+     * Callback on dynamic register failed
+     * @param cause
+     */
+    public abstract void onFailedDynreg(Throwable cause);
+}
Index: iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXDisconnectedBufferOptions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXDisconnectedBufferOptions.java	(date 1606400383032)
+++ iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXDisconnectedBufferOptions.java	(date 1606400383032)
@@ -0,0 +1,114 @@
+package com.tencent.iot.hub.device.android.service;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+
+/**
+ * 该类负责序列化DisconnectedBufferOptions相关信息
+ */
+
+public class TXDisconnectedBufferOptions extends DisconnectedBufferOptions implements Parcelable {
+    private int bufferSize = DISCONNECTED_BUFFER_SIZE_DEFAULT;
+    private boolean bufferEnabled = DISCONNECTED_BUFFER_ENABLED_DEFAULT;
+    private boolean persistBuffer = PERSIST_DISCONNECTED_BUFFER_DEFAULT;
+    private boolean deleteOldestMessages = DELETE_OLDEST_MESSAGES_DEFAULT;
+
+    public TXDisconnectedBufferOptions() {
+        super();
+    }
+
+    protected TXDisconnectedBufferOptions(Parcel in) {
+        bufferSize = in.readInt();
+        bufferEnabled = in.readByte() != 0;
+        persistBuffer = in.readByte() != 0;
+        deleteOldestMessages = in.readByte() != 0;
+    }
+
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel parcel, int i) {
+        parcel.writeInt(bufferSize);
+        parcel.writeByte((byte) (bufferEnabled ? 1 : 0));
+        parcel.writeByte((byte) (persistBuffer ? 1 : 0));
+        parcel.writeByte((byte) (deleteOldestMessages ? 1 : 0));
+
+    }
+
+    public static final Creator<TXDisconnectedBufferOptions> CREATOR = new Creator<TXDisconnectedBufferOptions>() {
+        @Override
+        public TXDisconnectedBufferOptions createFromParcel(Parcel in) {
+            return new TXDisconnectedBufferOptions(in);
+        }
+
+        @Override
+        public TXDisconnectedBufferOptions[] newArray(int size) {
+            return new TXDisconnectedBufferOptions[size];
+        }
+    };
+
+    /**
+     * 转换为DisconnectedBufferOptions
+     *
+     * @return
+     */
+    public DisconnectedBufferOptions transToDisconnectedBufferOptions() {
+        DisconnectedBufferOptions disconnectedBufferOptions = new DisconnectedBufferOptions();
+        disconnectedBufferOptions.setBufferSize(bufferSize);
+        disconnectedBufferOptions.setBufferEnabled(bufferEnabled);
+        disconnectedBufferOptions.setPersistBuffer(persistBuffer);
+        disconnectedBufferOptions.setDeleteOldestMessages(deleteOldestMessages);
+        return disconnectedBufferOptions;
+    }
+
+    public int getBufferSize() {
+        return bufferSize;
+    }
+
+    public void setBufferSize(int bufferSize) {
+        if (bufferSize < 1) {
+            throw new IllegalArgumentException();
+        }
+        this.bufferSize = bufferSize;
+    }
+
+    public boolean isBufferEnabled() {
+        return bufferEnabled;
+    }
+
+    public void setBufferEnabled(boolean bufferEnabled) {
+        this.bufferEnabled = bufferEnabled;
+    }
+
+    public boolean isPersistBuffer() {
+        return persistBuffer;
+    }
+
+    public void setPersistBuffer(boolean persistBuffer) {
+        this.persistBuffer = persistBuffer;
+    }
+
+    public boolean isDeleteOldestMessages() {
+        return deleteOldestMessages;
+    }
+
+    public void setDeleteOldestMessages(boolean deleteOldestMessages) {
+        this.deleteOldestMessages = deleteOldestMessages;
+    }
+
+    @Override
+    public String toString() {
+        return "TXDisconnectedBufferOptions{" +
+                "bufferSize=" + bufferSize +
+                ", bufferEnabled=" + bufferEnabled +
+                ", persistBuffer=" + persistBuffer +
+                ", deleteOldestMessages=" + deleteOldestMessages +
+                '}';
+    }
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/dynreg/TXMqttDynreg.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/dynreg/TXMqttDynreg.java	(date 1606400383017)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/dynreg/TXMqttDynreg.java	(date 1606400383017)
@@ -0,0 +1,269 @@
+package com.tencent.iot.hub.device.android.core.dynreg;
+
+import android.os.NetworkOnMainThreadException;
+import android.util.Base64;
+import android.util.Log;
+
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import java.io.BufferedReader;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+
+import javax.crypto.BadPaddingException;
+import javax.crypto.Cipher;
+import javax.crypto.IllegalBlockSizeException;
+import javax.crypto.Mac;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+
+/**
+ * The type Tx iothub dynreg.
+ */
+public class TXMqttDynreg {
+    private static final String TAG = "TXMQTT";
+    private static final String HMAC_ALGO = "HmacSHA1";
+    private static final String DECRYPT_MODE = "AES/CBC/NoPadding";
+
+    private String mProductKey;
+    private String mProductId;
+    private String mDynRegUrl;
+    private String mDeviceName;
+
+    private TXMqttDynregCallback mCallback;
+
+    // 默认的动态注册URL，文档链接：https://cloud.tencent.com/document/product/634/47225
+    private final String mDefaultDynRegUrl ="http://ap-guangzhou.gateway.tencentdevices.com/register/dev";
+
+
+    /**
+     * Instantiates a new Tx iothub dynreg.
+     *
+     * @param dynregUrl  the dynreg url
+     * @param productId  the product id
+     * @param productKey the product key
+     * @param deviceName the device name
+     * @param callback    the callback for operation result
+     */
+    public TXMqttDynreg(String dynregUrl, String productId, String productKey, String deviceName, TXMqttDynregCallback callback) {
+        this.mDynRegUrl = dynregUrl;
+        this.mProductId = productId;
+        this.mProductKey = productKey;
+        this.mDeviceName = deviceName;
+        this.mCallback = callback;
+    }
+
+    /**
+     * Instantiates a new Tx iothub dynreg.
+     *
+     * @param productId  the product id
+     * @param productKey the product key
+     * @param deviceName the device name
+     * @param callback callback for operation result
+     */
+    public TXMqttDynreg(String productId, String productKey, String deviceName, TXMqttDynregCallback callback) {
+        this.mDynRegUrl = mDefaultDynRegUrl;
+        this.mProductId = productId;
+        this.mProductKey = productKey;
+        this.mDeviceName = deviceName;
+        this.mCallback = callback;
+    }
+
+    private String inputStream2String(InputStream in) {
+        InputStreamReader reader = null;
+        try {
+            reader = new InputStreamReader(in, "UTF-8");
+        } catch (UnsupportedEncodingException e1) {
+            e1.printStackTrace();
+        }
+        BufferedReader br = new BufferedReader(reader);
+        StringBuilder sb = new StringBuilder();
+        String line = "";
+        try {
+            while ((line = br.readLine()) != null) {
+                sb.append(line);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return sb.toString();
+    }
+
+    private class HttpPostThread extends Thread {
+        private String postData;
+        private String url;
+
+        /**
+         * Instantiates a new Http post thread.
+         *
+         * @param upStr the up str
+         * @param upUrl the up url
+         */
+        HttpPostThread(String upStr, String upUrl) {
+            this.postData = upStr;
+            this.url = upUrl;
+        }
+
+        public void run() {
+            StringBuffer serverRsp = new StringBuffer();
+            try {
+                URL url = new URL(mDynRegUrl);
+                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+                conn.setRequestMethod("POST");
+                conn.setRequestProperty("Content-Type", "application/json;charset=UTF-8");
+                conn.setRequestProperty("Accept","application/json");
+                conn.setDoOutput(true);
+                conn.setDoInput(true);
+                conn.setConnectTimeout(2000);
+
+                DataOutputStream os = new DataOutputStream(conn.getOutputStream());
+
+                os.writeBytes(postData);
+                os.flush();
+                os.close();
+
+                int rc = conn.getResponseCode();
+
+                String line;
+                if(rc == 200){
+                    BufferedReader br=new BufferedReader(new InputStreamReader(conn.getInputStream()));
+                    while ((line = br.readLine()) != null) {
+                        serverRsp.append(line);
+                    }
+                    conn.disconnect();
+                }else {
+                    Log.e(TAG, "Get error rc "+ rc);
+                    conn.disconnect();
+
+                    mCallback.onFailedDynreg(new Throwable("Failed to get response from server, rc is " + rc));
+                    return;
+                }
+
+            } catch (IOException|NetworkOnMainThreadException e) {
+                Log.e(TAG, e.toString());
+                e.printStackTrace();
+
+                mCallback.onFailedDynreg(e);
+                return;
+            }
+
+            String plStr;
+            int actLen;
+            Log.i(TAG, "Get response string " + serverRsp);
+            try {
+                JSONObject rspObj = new JSONObject(serverRsp.toString());
+                plStr = rspObj.getString("payload");
+                actLen = rspObj.getInt("len");
+            } catch (JSONException e) {
+                Log.e(TAG, e.toString());
+                e.printStackTrace();
+                mCallback.onFailedDynreg(e, "receive Msg " + serverRsp);
+                return ;
+            }
+
+            byte[] plBytes;
+            try {
+                SecretKeySpec skeySpec = new SecretKeySpec(mProductKey.substring(0, 16).getBytes(), "AES");
+                Cipher cipher = Cipher.getInstance(DECRYPT_MODE);
+                byte [] ivArr = new byte[cipher.getBlockSize()];
+                for (int i = 0; i < 16; i++) {
+                    ivArr[i] = (byte)'0';
+                }
+                cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(ivArr));
+                plBytes = cipher.doFinal(Base64.decode(plStr, Base64.DEFAULT));
+            } catch (NoSuchAlgorithmException|NoSuchPaddingException|InvalidKeyException|IllegalBlockSizeException|BadPaddingException|InvalidAlgorithmParameterException e) {
+                e.printStackTrace();
+                mCallback.onFailedDynreg(e);
+                return;
+            }
+            String rspSb = new String(plBytes);
+            rspSb = rspSb.substring(0, actLen);
+
+            try {
+                JSONObject rspObj = new JSONObject(rspSb.toString());
+                int encryptionType = rspObj.getInt("encryptionType");
+
+                // Cert
+                if (encryptionType == 1) {
+                    mCallback.onGetDeviceCert(rspObj.getString("clientCert"), rspObj.getString("clientKey"));
+                } else if (encryptionType == 2) {
+                    // PSK
+                    mCallback.onGetDevicePSK(rspObj.getString("psk"));
+                } else {
+                    mCallback.onFailedDynreg(new Throwable("Get wrong encryption type:" + encryptionType));
+                }
+            } catch (JSONException e) {
+                e.printStackTrace();
+
+                mCallback.onFailedDynreg(e);
+                return;
+            }
+        }
+    }
+
+    /**
+     * Do dynamic register
+     *
+     * @return true for register OK, false for register ERROR
+     */
+    public boolean doDynamicRegister() {
+        Mac mac = null;
+
+        try {
+            mac = Mac.getInstance(HMAC_ALGO);
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+            return false;
+        }
+        int randNum = (int)(Math.random() * ((1 << 31) - 1));
+        String hmacSign;
+        int timestamp = (int)(System.currentTimeMillis() / 1000);
+        SecretKeySpec signKey = new SecretKeySpec(mProductKey.getBytes(), HMAC_ALGO);
+
+        String signSourceStr = String.format("deviceName=%s&nonce=%d&productId=%s&timestamp=%d", mDeviceName, randNum, mProductId, timestamp);
+
+        try {
+            mac.init(signKey);
+            byte[] rawHmac = mac.doFinal(signSourceStr.getBytes());
+            StringBuffer sBuffer = new StringBuffer();
+            for (int i = 0; i < rawHmac.length; i++) {
+                sBuffer.append(String.format("%02x", rawHmac[i] & 0xff));
+            }
+
+            hmacSign = Base64.encodeToString(sBuffer.toString().getBytes(), Base64.NO_WRAP);
+        } catch (InvalidKeyException e) {
+            e.printStackTrace();
+            return false;
+        }
+
+        final JSONObject obj = new JSONObject();
+        try {
+            obj.put("deviceName", mDeviceName);
+            obj.put("nonce", randNum);
+            obj.put("productId", mProductId);
+            obj.put("timestamp", timestamp);
+            obj.put("signature", hmacSign);
+        } catch (JSONException e) {
+            e.printStackTrace();
+            return false;
+        }
+
+        TXLog.i(TAG, "Register request " + obj);
+        HttpPostThread httpThread = new HttpPostThread(obj.toString(), mDefaultDynRegUrl);
+        httpThread.start();
+
+        return true;
+    }
+}
Index: iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttConnectOptions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttConnectOptions.java	(date 1606400383033)
+++ iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttConnectOptions.java	(date 1606400383033)
@@ -0,0 +1,182 @@
+package com.tencent.iot.hub.device.android.service;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+
+/**
+ * 该类负责序列化MqttConnectOptions相关信息
+ */
+
+public class TXMqttConnectOptions implements Parcelable {
+
+    private int mConnectionTimeout = MqttConnectOptions.CONNECTION_TIMEOUT_DEFAULT;
+    private int mKeepAliveInterval = MqttConnectOptions.KEEP_ALIVE_INTERVAL_DEFAULT;
+    private boolean mAutomaticReconnect = false;
+    private boolean mCleanSession = MqttConnectOptions.CLEAN_SESSION_DEFAULT;
+
+    /**
+     * 是否使用shadow
+     */
+    private boolean mUseShadow = false;
+
+    /**
+     * 是否采用非对称加密
+     */
+    private boolean mAsymcEncryption = true;
+
+    /**
+     * 设备证书名
+     */
+    private String mDeviceCertName;
+
+    /**
+     * 设备私钥文件名
+     */
+    private String mDeviceKeyName;
+
+    /**
+     * 设备密码
+     */
+    private String mSecretKey;
+
+    public static final Creator<TXMqttConnectOptions> CREATOR = new Creator<TXMqttConnectOptions>() {
+        @Override
+        public TXMqttConnectOptions createFromParcel(Parcel in) {
+            return new TXMqttConnectOptions(in);
+        }
+
+        @Override
+        public TXMqttConnectOptions[] newArray(int size) {
+            return new TXMqttConnectOptions[size];
+        }
+    };
+
+    public TXMqttConnectOptions() {
+    }
+
+    public TXMqttConnectOptions(int mConnectionTimeout, int mKeepAliveInterval, boolean mAutomaticReconnect, boolean mCleanSession,
+                                boolean mAsymcEncryption, String mDeviceCertName, String mDeviceKeyName, String mSecretKey) {
+        this.mConnectionTimeout = mConnectionTimeout;
+        this.mKeepAliveInterval = mKeepAliveInterval;
+        this.mAutomaticReconnect = mAutomaticReconnect;
+        this.mCleanSession = mCleanSession;
+        this.mAsymcEncryption = mAsymcEncryption;
+        this.mDeviceCertName = mDeviceCertName;
+        this.mDeviceKeyName = mDeviceKeyName;
+        this.mSecretKey = mSecretKey;
+    }
+
+    protected TXMqttConnectOptions(Parcel in) {
+        mConnectionTimeout = in.readInt();
+        mKeepAliveInterval = in.readInt();
+        mDeviceCertName = in.readString();
+        mDeviceKeyName = in.readString();
+        mSecretKey = in.readString();
+        boolean[] booleanArray = new boolean[4];
+        in.readBooleanArray(booleanArray);
+        mAutomaticReconnect = booleanArray[0];
+        mUseShadow = booleanArray[1];
+        mCleanSession = booleanArray[2];
+        mAsymcEncryption = booleanArray[3];
+    }
+
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int flag) {
+        out.writeInt(mConnectionTimeout);
+        out.writeInt(mKeepAliveInterval);
+        out.writeString(mDeviceCertName);
+        out.writeString(mDeviceKeyName);
+        out.writeString(mSecretKey);
+        boolean[] booleanArray = new boolean[]{mAutomaticReconnect, mUseShadow, mCleanSession, mAsymcEncryption};
+        out.writeBooleanArray(booleanArray);
+    }
+
+    public int getConnectionTimeout() {
+        return mConnectionTimeout;
+    }
+
+    public TXMqttConnectOptions setConnectionTimeout(int mConnectionTimeout) {
+        this.mConnectionTimeout = mConnectionTimeout;
+        return this;
+    }
+
+    public int getKeepAliveInterval() {
+        return mKeepAliveInterval;
+    }
+
+    public TXMqttConnectOptions setKeepAliveInterval(int mKeepAliveInterval) {
+        this.mKeepAliveInterval = mKeepAliveInterval;
+        return this;
+    }
+
+    public boolean isAutomaticReconnect() {
+        return mAutomaticReconnect;
+    }
+
+    public TXMqttConnectOptions setAutomaticReconnect(boolean mAutomaticReconnect) {
+        this.mAutomaticReconnect = mAutomaticReconnect;
+        return this;
+    }
+
+    public boolean isCleanSession() {
+        return mCleanSession;
+    }
+
+    public TXMqttConnectOptions setCleanSession(boolean mCleanSession) {
+        this.mCleanSession = mCleanSession;
+        return this;
+    }
+
+    public boolean isAsymcEncryption() {
+        return mAsymcEncryption;
+    }
+
+    public TXMqttConnectOptions setAsymcEncryption(boolean mAsymcEncryption) {
+        this.mAsymcEncryption = mAsymcEncryption;
+        return this;
+    }
+
+    public String getDeviceCertName() {
+        return mDeviceCertName;
+    }
+
+    public TXMqttConnectOptions setDeviceCertName(String mDeviceCertName) {
+        this.mDeviceCertName = mDeviceCertName;
+        return this;
+    }
+
+    public String getDeviceKeyName() {
+        return mDeviceKeyName;
+    }
+
+    public TXMqttConnectOptions setDeviceKeyName(String mDeviceKeyName) {
+        this.mDeviceKeyName = mDeviceKeyName;
+        return this;
+    }
+
+    public String getSecretKey() {
+        return mSecretKey;
+    }
+
+    public TXMqttConnectOptions setSecretKey(String secretKey) {
+        this.mSecretKey = secretKey;
+        return this;
+    }
+
+    protected boolean isUseShadow() {
+        return mUseShadow;
+    }
+
+    protected TXMqttConnectOptions setUseShadow(boolean mUseShadow) {
+        this.mUseShadow = mUseShadow;
+        return this;
+    }
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/AsymcSslUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/AsymcSslUtils.java	(date 1606400383021)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/util/AsymcSslUtils.java	(date 1606400383021)
@@ -0,0 +1,224 @@
+package com.tencent.iot.hub.device.android.core.util;
+
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.util.Base64;
+
+import com.tencent.iot.hub.device.java.core.util.Asn1Object;
+import com.tencent.iot.hub.device.java.core.util.DerParser;
+
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyFactory;
+import java.security.PrivateKey;
+import java.security.SecureRandom;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.security.spec.KeySpec;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.security.spec.RSAPrivateCrtKeySpec;
+import java.util.Random;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+
+public class AsymcSslUtils {
+
+    public static final String TAG = "iot.AsymcSslUtils";
+
+    private static String PASSWORD = String.valueOf(new Random(System.currentTimeMillis()).nextInt());
+
+    /**
+     * 证书文件及Key文件存放在Android asset目录下，通过AssetManager读取文件内容获取输入流，
+     * 通过输入流构造双向认证SSLSocketFactory
+     *
+     * @param context              Android上下文，可使用进程上下文/Activity
+     * @param clientCrtFileName    客户端证书文件名
+     * @param clientPriKeyFileName 客户端私钥文件名
+     * @return
+     */
+    public static SSLSocketFactory getSocketFactoryByAssetsFile(Context context, final String clientCrtFileName, final String clientPriKeyFileName) {
+        SSLSocketFactory factory = null;
+
+        AssetManager assetManager = context.getAssets();
+        if (assetManager == null) {
+            return null;
+        }
+
+        InputStream clientInputStream = null;
+        InputStream keyInputStream = null;
+        try {
+            clientInputStream = assetManager.open(clientCrtFileName);
+            keyInputStream = assetManager.open(clientPriKeyFileName);
+
+            factory = getSocketFactoryByStream(clientInputStream, keyInputStream);;
+        } catch (IOException e) {
+            TXLog.e(TAG, "getSocketFactory failed, cannot open CRT Files.", e);
+        }finally {
+            if (clientInputStream != null) {
+                try {
+                    clientInputStream.close();
+                }catch (Exception e) {
+
+                }
+            }
+
+            if (keyInputStream != null) {
+                try {
+                    keyInputStream.close();
+                }catch (Exception e) {
+
+                }
+            }
+        }
+
+        return factory;
+    }
+
+    /**
+     * 证书文件及Key文件存放在Android 本地存储中，通过FileInputStream读取文件内容输入流
+     * 通过输入流解析构造双向认证SSLSocketFactory
+     *
+     * @param clientCrtFileName    客户端证书文件名，要求全路径
+     * @param clientPriKeyFileName 客户端私钥文件名，要求全路径
+     * @return
+     */
+    public static SSLSocketFactory getSocketFactoryByFile(final String clientCrtFileName, final String clientPriKeyFileName) {
+        return com.tencent.iot.hub.device.java.core.util.AsymcSslUtils.getSocketFactoryByFile(clientCrtFileName, clientPriKeyFileName);
+    }
+
+    /**
+     * 获取双向认证SSLSocketFactory
+     *
+     * @param clientInput 设备证书文件输入流
+     * @param keyInput    设备私钥文件输入流
+     * @return
+     */
+    public static SSLSocketFactory getSocketFactoryByStream(final InputStream clientInput, final InputStream keyInput) {
+        return com.tencent.iot.hub.device.java.core.util.AsymcSslUtils.getSocketFactoryByStream(clientInput, keyInput);
+    }
+
+    public static SSLContext getDefaultSLLContext() {
+        SSLContext sslContext = null;
+        try {
+            sslContext = SSLContext.getInstance("TLS");
+            sslContext.init(null, new TrustManager[] {trustManagers}, new SecureRandom());
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return sslContext;
+    }
+
+    /**
+     * 信任管理器
+     */
+    private static TrustManager trustManagers = new X509TrustManager() {
+
+        @Override
+        public void checkClientTrusted(X509Certificate[] chain, String authType)
+                throws CertificateException {}
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] chain, String authType)
+                throws CertificateException {
+
+        }
+
+        @Override
+        public X509Certificate[] getAcceptedIssuers() {
+            return new X509Certificate[0];
+        }
+    };
+
+    /**
+     * 获取SSLSocketFactory
+     *
+     * @return
+     */
+    public static SSLSocketFactory getSocketFactory() {
+        return com.tencent.iot.hub.device.java.core.util.AsymcSslUtils.getSocketFactory();
+    }
+
+    /**
+     * 获取自定义CA证书的SSLSocketFactory
+     *
+     * @param customCA 自定义CA证书
+     * @return SSLSocketFactory
+     */
+    public static SSLSocketFactory getSocketFactory(String customCA) {
+        return com.tencent.iot.hub.device.java.core.util.AsymcSslUtils.getSocketFactory(customCA);
+    }
+
+    private static PrivateKey getPrivateKey(InputStream stream, String algorithm) throws IOException,
+            GeneralSecurityException {
+        PrivateKey key = null;
+        boolean isRSAKey = false;
+
+        BufferedReader br = new BufferedReader(new InputStreamReader(stream, "UTF-8"));
+        StringBuilder builder = new StringBuilder();
+        boolean inKey = false;
+        for (String line = br.readLine(); line != null; line = br.readLine()) {
+            if (!inKey) {
+                if (line.startsWith("-----BEGIN ") && line.endsWith(" PRIVATE KEY-----")) {
+                    inKey = true;
+                    isRSAKey = line.contains("RSA");
+                }
+                continue;
+            } else {
+                if (line.startsWith("-----END ") && line.endsWith(" PRIVATE KEY-----")) {
+                    inKey = false;
+                    isRSAKey = line.contains("RSA");
+                    break;
+                }
+                builder.append(line);
+            }
+        }
+        KeySpec keySpec = null;
+        byte[] encoded = Base64.decode(builder.toString(), Base64.DEFAULT);
+        if (isRSAKey) {
+            keySpec = getRSAKeySpec(encoded);
+        } else {
+            keySpec = new PKCS8EncodedKeySpec(encoded);
+        }
+        KeyFactory kf = KeyFactory.getInstance((algorithm == null) ? "RSA" : algorithm);
+        key = kf.generatePrivate(keySpec);
+
+        return key;
+    }
+
+    private static RSAPrivateCrtKeySpec getRSAKeySpec(byte[] keyBytes) throws IOException {
+
+        DerParser parser = new DerParser(keyBytes);
+
+        Asn1Object sequence = parser.read();
+        if (sequence.getType() != DerParser.SEQUENCE)
+            throw new IOException("Invalid DER: not a sequence"); //$NON-NLS-1$
+
+        // Parse inside the sequence
+        parser = sequence.getParser();
+
+        parser.read(); // Skip version
+        BigInteger modulus = parser.read().getInteger();
+        BigInteger publicExp = parser.read().getInteger();
+        BigInteger privateExp = parser.read().getInteger();
+        BigInteger prime1 = parser.read().getInteger();
+        BigInteger prime2 = parser.read().getInteger();
+        BigInteger exp1 = parser.read().getInteger();
+        BigInteger exp2 = parser.read().getInteger();
+        BigInteger crtCoef = parser.read().getInteger();
+
+        RSAPrivateCrtKeySpec keySpec = new RSAPrivateCrtKeySpec(modulus, publicExp, privateExp, prime1, prime2, exp1,
+                exp2, crtCoef);
+
+        return keySpec;
+    }
+}
+
Index: iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttClientOptions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttClientOptions.java	(date 1606400383033)
+++ iot_service/src/main/java/com/tencent/iot/hub/device/android/service/TXMqttClientOptions.java	(date 1606400383033)
@@ -0,0 +1,116 @@
+package com.tencent.iot.hub.device.android.service;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * mqtt远程客户端选项
+ */
+
+public class TXMqttClientOptions implements Parcelable {
+
+    /**
+     * 服务器URI
+     */
+    private String mServerURI;
+
+    /**
+     * Iot Hub控制台获取产品ID
+     */
+    private String mProductId;
+
+    /**
+     * 设备名，唯一
+     */
+    private String mDeviceName;
+
+    private String mSecretKey;
+
+    public static final Creator<TXMqttClientOptions> CREATOR = new Creator<TXMqttClientOptions>() {
+        @Override
+        public TXMqttClientOptions createFromParcel(Parcel in) {
+            return new TXMqttClientOptions(in);
+        }
+
+        @Override
+        public TXMqttClientOptions[] newArray(int size) {
+            return new TXMqttClientOptions[size];
+        }
+    };
+
+    public TXMqttClientOptions() {
+    }
+
+    public TXMqttClientOptions(String serverURI, String productId, String deviceName, String secretKey) {
+        this.mServerURI = serverURI;
+        this.mProductId = productId;
+        this.mDeviceName = deviceName;
+        this.mSecretKey = secretKey;
+    }
+
+    protected TXMqttClientOptions(Parcel in) {
+        mServerURI = in.readString();
+        mProductId = in.readString();
+        mDeviceName = in.readString();
+        mSecretKey = in.readString();
+    }
+
+
+    public String getServerURI() {
+        return mServerURI;
+    }
+
+    public TXMqttClientOptions serverURI(String serverURI) {
+        this.mServerURI = serverURI;
+        return this;
+    }
+
+    public String getProductId() {
+        return mProductId;
+    }
+
+    public TXMqttClientOptions productId(String productId) {
+        this.mProductId = productId;
+        return this;
+    }
+
+    public String getDeviceName() {
+        return mDeviceName;
+    }
+
+    public TXMqttClientOptions deviceName(String deviceName) {
+        this.mDeviceName = deviceName;
+        return this;
+    }
+
+    public String getSecretKey() {
+        return mSecretKey;
+    }
+
+    public TXMqttClientOptions secretKey(String secretKey) {
+        this.mSecretKey = secretKey;
+        return this;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel parcel, int i) {
+        parcel.writeString(mServerURI);
+        parcel.writeString(mProductId);
+        parcel.writeString(mDeviceName);
+        parcel.writeString(mSecretKey);
+    }
+
+    @Override
+    public String toString() {
+        return "TXMqttClientOptions{" +
+                "mServerURI='" + mServerURI + '\'' +
+                ", mProductId='" + mProductId + '\'' +
+                ", mDeviceName='" + mDeviceName + '\'' +
+                '}';
+    }
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/shadow/TXShadowConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/shadow/TXShadowConnection.java	(date 1606400383020)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/shadow/TXShadowConnection.java	(date 1606400383020)
@@ -0,0 +1,324 @@
+package com.tencent.iot.hub.device.android.core.shadow;
+
+import android.content.Context;
+
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.android.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowActionCallBack;
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowConstants;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.MQTT_SERVER_PORT_TLS;
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.QCLOUD_IOT_MQTT_DIRECT_DOMAIN;
+
+
+public class TXShadowConnection {
+
+    public static final String TAG = TXShadowConnection.class.getName();
+
+    /**
+     * clientToken formatter
+     */
+    private static final String CLIENT_TOKEN = "%s-%d";
+
+    private Context mContext = null;
+
+    private com.tencent.iot.hub.device.java.core.shadow.TXShadowConnection mTXShadowConn = null;
+
+    /**
+     * shadow action回调接口
+     */
+    private TXShadowActionCallBack mShadowActionCallback = null;
+
+    /**
+     * mqtt 连接实例
+     */
+    private TXMqttConnection mMqttConnection = null;
+
+
+    private int mQos = TXMqttConstants.QOS0;
+
+
+    /**
+     * 保存用户注册的属性
+     */
+    private HashMap<String, DeviceProperty> mRegisterPropertyMap = new HashMap<>();
+
+    /**
+     * 是否已经成功订阅OPERATION_RESULT_TOPIC
+     */
+    private boolean mIsOperationResultSubscribeSuccess = false;
+
+    /**
+     * 文档版本号
+     */
+    private int mDocumentVersion = 0;
+
+    private String OPERATION_TOPIC = null;
+    private String OPERATION_RESULT_TOPIC = null;
+
+    private static final int MAX_MESSAGE_ID = 65535;
+    private int mPublishMessageId = 0;
+
+    /**
+     * @param context    用户上下文（这个参数在回调函数时透传给用户）
+     * @param productID  产品名
+     * @param deviceName 设备名，唯一
+     * @param secretKey  密钥
+     * @param callBack   连接、消息发布、消息订阅回调接口
+     */
+    public TXShadowConnection(Context context, String productID, String deviceName, String secretKey, TXShadowActionCallBack callBack) {
+        this(context, productID, deviceName, secretKey, null, callBack);
+    }
+
+    /**
+     * @param context    用户上下文（这个参数在回调函数时透传给用户）
+     * @param productID  产品名
+     * @param deviceName 设备名，唯一
+     * @param secretKey  密钥
+     * @param bufferOpts 发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+     * @param callBack   连接、消息发布、消息订阅回调接口
+     */
+    public TXShadowConnection(Context context, String productID, String deviceName, String secretKey,
+                              DisconnectedBufferOptions bufferOpts, TXShadowActionCallBack callBack) {
+        this(context, productID, deviceName, secretKey, bufferOpts, null, callBack);
+    }
+
+    /**
+     * @param context           用户上下文（这个参数在回调函数时透传给用户）
+     * @param productID         产品名
+     * @param deviceName        设备名，唯一
+     * @param secretKey         密钥
+     * @param bufferOpts        发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+     * @param clientPersistence 消息永久存储
+     * @param callBack          连接、消息发布、消息订阅回调接口
+     */
+    public TXShadowConnection(Context context, String productID, String deviceName, String secretKey,
+                              DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence, TXShadowActionCallBack callBack) {
+        this(context, null, productID, deviceName, secretKey, bufferOpts, clientPersistence, callBack);
+    }
+
+    /**
+     * Shadow连接器构造器
+     *
+     * @param context           用户上下文（这个参数在回调函数时透传给用户）
+     * @param serverURI         服务器URI
+     * @param productID         产品名
+     * @param deviceName        设备名，唯一
+     * @param secretKey         密钥
+     * @param bufferOpts        发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+     * @param clientPersistence 消息永久存储
+     * @param callBack          连接、消息发布、消息订阅回调接口
+     */
+    public TXShadowConnection(Context context, String serverURI, String productID, String deviceName, String secretKey,
+                              DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence, TXShadowActionCallBack callBack) {
+        this.mContext = context;
+        this.mShadowActionCallback = callBack;
+
+        mTXShadowConn = new com.tencent.iot.hub.device.java.core.shadow.TXShadowConnection(serverURI, productID, deviceName, secretKey,
+                bufferOpts, clientPersistence, callBack);
+        mMqttConnection = new TXMqttConnection(context, serverURI, productID, deviceName, secretKey,
+                bufferOpts, clientPersistence, mTXShadowConn.mShadowUponMqttCallBack);
+
+        OPERATION_TOPIC = "$shadow/operation/" + productID + "/" + mMqttConnection.mDeviceName;
+        OPERATION_RESULT_TOPIC = "$shadow/operation/result/" + productID + "/" + mMqttConnection.mDeviceName;
+
+        mPublishMessageId = new Random().nextInt(MAX_MESSAGE_ID);
+
+        mTXShadowConn.setMqttConnection(mMqttConnection);
+    }
+
+    /**
+     * 获取TXMqttConnection句柄
+     */
+    public TXMqttConnection getMqttConnection() {
+        return (TXMqttConnection) mTXShadowConn.getMqttConnection();
+    }
+
+
+    /**
+     * 设置断连状态buffer缓冲区
+     *
+     * @param bufferOpts 缓冲参数
+     */
+    public void setBufferOpts(DisconnectedBufferOptions bufferOpts) {
+        mTXShadowConn.setBufferOpts(bufferOpts);
+    }
+
+    /**
+     * 与云端建立连接，结果通过回调函数通知。
+     *
+     * @param options     连接参数
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public synchronized Status connect(MqttConnectOptions options, Object userContext) {
+        return mTXShadowConn.connect(options, userContext);
+    }
+
+    /**
+     * 断开连接请求，结果通过回调函数通知。
+     *
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status disConnect(Object userContext) {
+        return mTXShadowConn.disConnect(userContext);
+    }
+
+    /**
+     * 获取连接状态
+     *
+     * @return 连接状态
+     */
+    public TXMqttConstants.ConnectStatus getConnectStatus() {
+        return mTXShadowConn.getConnectStatus();
+    }
+
+    /**
+     * 订阅普通主题
+     *
+     * @param topicName 主题名
+     * @param qos QOS等级
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status subscribe(String topicName, int qos, Object userContext) {
+        Status status;
+        status = checkMqttStatus();
+        if (status != Status.OK) {
+            return status;
+        }
+        TXLog.d(TAG, "sub topic is " + topicName);
+        // 订阅主题
+        return mMqttConnection.subscribe(topicName, qos, userContext);
+    }
+
+    /**
+     * 取消订阅普通主题
+     *
+     * @param topicName 主题名
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status unSubscribe(String topicName, Object userContext) {
+        Status status;
+        status = checkMqttStatus();
+        if (status != Status.OK) {
+            return status;
+        }
+        TXLog.d(TAG, "Start to unSubscribe" + topicName);
+        // 取消订阅主题
+        return mMqttConnection.unSubscribe(topicName, userContext);
+    }
+
+    /**
+     * 实现普通topic的发布
+     *
+     * @param topicName    topic
+     * @param message     发布的消息
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status publish(String topicName, MqttMessage message, Object userContext) {
+        //判断MQTT状态
+        Status status;
+        status = checkMqttStatus();
+        if (status != Status.OK) {
+            return status;
+        }
+        TXLog.d(TAG, "pub topic " + topicName + message);
+        // 发布主题
+        return mMqttConnection.publish(topicName, message, userContext);
+    }
+
+    /**
+     * 更新设备属性信息，结果通过回调函数通知。
+     *
+     * @param devicePropertyList 需要更新的设备属性集
+     * @param userContext        用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status update(List<DeviceProperty> devicePropertyList, Object userContext) {
+        return mTXShadowConn.update(devicePropertyList, userContext);
+    }
+
+    /**
+     * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息。
+     *
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportNullDesiredInfo() {
+        return mTXShadowConn.reportNullDesiredInfo();
+    }
+
+    /**
+     * 更新delta信息后，上报空的desired信息，通知服务器不再发送delta消息。
+     *
+     * @param reportJsonDoc 用户上报的JSON内容
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status reportNullDesiredInfo(String reportJsonDoc) {
+        return mTXShadowConn.reportNullDesiredInfo(reportJsonDoc);
+    }
+
+    /**
+     * 获取设备影子文档，结果通过回调函数通知。
+     *
+     * @param userContext 用户上下文（这个参数在回调函数时透传给用户）
+     * @return 发送请求成功时返回Status.OK; 其它返回值表示发送请求失败；
+     */
+    public Status get(Object userContext) {
+        return mTXShadowConn.get(userContext);
+    }
+
+    /**
+     * 注册当前设备的设备属性
+     *
+     * @param property 设备属性
+     */
+    public void registerProperty(DeviceProperty property) {
+        mTXShadowConn.registerProperty(property);
+    }
+
+    /**
+     * 取消注册当前设备的指定属性
+     *
+     * @param property
+     */
+    public void unRegisterProperty(DeviceProperty property) {
+        mTXShadowConn.unRegisterProperty(property);
+    }
+
+    /**
+     * 检查mqtt状态
+     *
+     * @return 当前状态
+     */
+    private Status checkMqttStatus() {
+        if (null == mMqttConnection || mMqttConnection.getConnectStatus() != TXMqttConstants.ConnectStatus.kConnected) {
+            TXLog.e(TAG, "mqtt is disconnected!");
+            return Status.MQTT_NO_CONN;
+        }
+
+        return Status.OK;
+    }
+}
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/shadow/DeviceProperty.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/shadow/DeviceProperty.java	(date 1606400383020)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/shadow/DeviceProperty.java	(date 1606400383020)
@@ -0,0 +1,46 @@
+package com.tencent.iot.hub.device.android.core.shadow;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.tencent.iot.hub.device.java.core.shadow.TXShadowConstants;
+
+/**
+ * 设备属性信息
+ */
+public class DeviceProperty extends com.tencent.iot.hub.device.java.core.shadow.DeviceProperty implements Parcelable {
+
+    public static final Creator<DeviceProperty> CREATOR = new Creator<DeviceProperty>() {
+        @Override
+        public DeviceProperty createFromParcel(Parcel in) {
+            return new DeviceProperty(in);
+        }
+
+        @Override
+        public DeviceProperty[] newArray(int size) {
+            return new DeviceProperty[size];
+        }
+    };
+
+    public DeviceProperty() {
+    }
+
+    protected DeviceProperty(Parcel in) {
+        // 注意，此处的读值顺序应与writeToParcel()方法中一致
+        mKey = in.readString();
+        mData = in.readString();
+        mDataType = TXShadowConstants.JSONDataType.valueOf(TXShadowConstants.JSONDataType.class, in.readString());
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int flag) {
+        out.writeString(mKey);
+        out.writeString(mData.toString());
+        out.writeString(mDataType.name());
+    }
+}
Index: iot_service/src/test/java/com/qcloud/iot/service/ExampleUnitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/test/java/com/qcloud/iot/service/ExampleUnitTest.java	(date 1606400383036)
+++ iot_service/src/test/java/com/qcloud/iot/service/ExampleUnitTest.java	(date 1606400383036)
@@ -0,0 +1,17 @@
+package com.qcloud.iot.service;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
Index: iot_core/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/AndroidManifest.xml	(date 1606400383013)
+++ iot_core/src/main/AndroidManifest.xml	(date 1606400383013)
@@ -0,0 +1,17 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+
+    package="com.tencent.iot.hub.device.android.core">
+
+    <application android:allowBackup="true" android:label="@string/app_name"
+        android:supportsRtl="true">
+
+    </application>
+
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.WAKE_LOCK" />
+
+</manifest>
Index: iot_core/src/main/java/com/tencent/iot/hub/device/android/core/gateway/TXGatewayConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/main/java/com/tencent/iot/hub/device/android/core/gateway/TXGatewayConnection.java	(date 1606400383018)
+++ iot_core/src/main/java/com/tencent/iot/hub/device/android/core/gateway/TXGatewayConnection.java	(date 1606400383018)
@@ -0,0 +1,523 @@
+package com.tencent.iot.hub.device.android.core.gateway;
+
+import android.content.Context;
+import android.util.Base64;
+import android.util.Log;
+
+import com.tencent.iot.hub.device.android.core.log.TXMqttLogCallBack;
+import com.tencent.iot.hub.device.android.core.mqtt.TXAlarmPingSender;
+import com.tencent.iot.hub.device.android.core.mqtt.TXMqttConnection;
+import com.tencent.iot.hub.device.android.core.util.TXLog;
+import com.tencent.iot.hub.device.java.core.common.Status;
+import com.tencent.iot.hub.device.java.core.gateway.TXGatewaySubdev;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttActionCallBack;
+import com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants;
+import com.tencent.iot.hub.device.java.core.util.HmacSha256;
+
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttAsyncClient;
+import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.HashMap;
+
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+
+import static com.tencent.iot.hub.device.java.core.mqtt.TXMqttConstants.MQTT_SDK_VER;
+
+/**
+ * Created by willssong on 2018/12/25.
+ */
+
+public class TXGatewayConnection  extends TXMqttConnection {
+    public static final String TAG = "TXMQTT" + MQTT_SDK_VER;
+    private static final String HMAC_SHA_256 = "HmacSHA256";
+
+    private HashMap<String, TXGatewaySubdev> mSubdevs = new HashMap<String, TXGatewaySubdev>();
+    private static final String GW_OPERATION_RES_PREFIX = "$gateway/operation/result/";
+    private static final String GW_OPERATION_PREFIX = "$gateway/operation/";
+    private static final String PRODUCT_CONFIG_PREFIX = "$config/operation/result/";
+
+    public TXGatewayConnection(Context context, String serverURI, String productID, String deviceName, String secretKey, DisconnectedBufferOptions bufferOpts,
+                               MqttClientPersistence clientPersistence, Boolean mqttLogFlag, TXMqttLogCallBack logCallBack, TXMqttActionCallBack callBack) {
+        super(context, serverURI, productID, deviceName, secretKey, bufferOpts, clientPersistence, mqttLogFlag,logCallBack,callBack);
+    }
+
+    /**
+     * @param context           用户上下文（这个参数在回调函数时透传给用户）
+     * @param serverURI         服务器URI
+     * @param productID         产品名
+     * @param deviceName        设备名，唯一
+     * @param secretKey         密钥
+     * @param bufferOpts        发布消息缓存buffer，当发布消息时MQTT连接非连接状态时使用
+     * @param clientPersistence 消息永久存储
+     * @param callBack          连接、消息发布、消息订阅回调接口
+     */
+    public TXGatewayConnection(Context context, String serverURI, String productID, String deviceName, String secretKey,
+                            DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence, TXMqttLogCallBack logCallBack,TXMqttActionCallBack callBack) {
+        this(context, serverURI, productID, deviceName, secretKey, bufferOpts, clientPersistence,true, logCallBack, callBack);
+    }
+
+    /**
+     * 使用腾讯云物联网通信默认地址 "${ProductId}.iotcloud.tencentdevices.com:8883"  https://cloud.tencent.com/document/product/634/32546
+     * @param context
+     * @param productID
+     * @param deviceName
+     * @param secretKey
+     * @param bufferOpts
+     * @param clientPersistence
+     * @param callBack
+     */
+    public TXGatewayConnection(Context context, String productID, String deviceName, String secretKey,
+                               DisconnectedBufferOptions bufferOpts, MqttClientPersistence clientPersistence,
+                               TXMqttActionCallBack callBack) {
+        this(context, null, productID, deviceName, secretKey, bufferOpts, clientPersistence, false,null, callBack);
+    }
+
+    /**
+     *
+     * @param context
+     * @param productID
+     * @param deviceName
+     * @param secretKey
+     * @param bufferOpts
+     * @param callBack
+     */
+    public TXGatewayConnection(Context context, String productID, String deviceName, String secretKey,
+                               DisconnectedBufferOptions bufferOpts, TXMqttActionCallBack callBack) {
+        this(context, productID, deviceName, secretKey, bufferOpts, null, callBack);
+    }
+
+    public TXGatewayConnection(Context context, String srvURL, String productID, String deviceName,
+                               String secretKey, TXMqttActionCallBack callBack) {
+        this(context, srvURL, productID, deviceName, secretKey, null, null, false, null, callBack);
+    }
+
+    /**
+     *
+     * @param context
+     * @param productID
+     * @param deviceName
+     * @param secretKey
+     * @param callBack
+     */
+    public TXGatewayConnection(Context context, String productID, String deviceName,
+                               String secretKey, TXMqttActionCallBack callBack) {
+        this(context, productID, deviceName, secretKey, null, null, callBack);
+    }
+
+
+
+    /**
+     *
+     * @param productId
+     * @param devName
+     * @return null if not existed otherwise the subdev
+     */
+    private TXGatewaySubdev findSubdev(String productId, String devName) {
+        Log.d(TAG, "The hashed information is " + mSubdevs);
+        return mSubdevs.get(productId + devName);
+    }
+
+    /**
+     * remove the subdev if it is offline
+     * @param subdev
+     * @return the operation results
+     */
+    private synchronized TXGatewaySubdev removeSubdev(TXGatewaySubdev subdev) {
+        return mSubdevs.remove(subdev.mProductId + subdev.mDevName);
+    }
+
+    /**
+     * remove the subdev if it is offline
+     * @param productId
+     * @param devName
+     * @return
+     */
+    private synchronized TXGatewaySubdev removeSubdev(String productId, String devName) {
+        return mSubdevs.remove(productId + devName);
+    }
+
+    /**
+     *  add a new subdev entry
+     * @param dev
+     */
+    private synchronized void addSubdev(TXGatewaySubdev dev) {
+        mSubdevs.put(dev.mProductId + dev.mDevName, dev);
+    }
+
+    /**
+     *  Get the subdev status
+     * @param productId
+     * @param devName
+     * @return the status of subdev
+     */
+    public Status getSubdevStatus(String productId, String devName) {
+        TXGatewaySubdev subdev = findSubdev(productId, devName);
+        if (subdev == null) {
+            return Status.SUBDEV_STAT_NOT_EXIST;
+        }
+        return subdev.getSubdevStatus();
+    }
+
+    /**
+     * set the status of the subdev
+     * @param productId
+     * @param devName
+     * @param stat
+     * @return the status of operation
+     */
+    public Status setSubdevStatus(String productId, String devName, Status stat) {
+        TXGatewaySubdev subdev = findSubdev(productId, devName);
+        if (subdev == null) {
+            return Status.SUBDEV_STAT_NOT_EXIST;
+        }
+        subdev.setSubdevStatus(stat);
+        return Status.OK;
+    }
+
+    /**
+     * publish the offline message for the subdev
+     * @param subProductID
+     * @param subDeviceName
+     * @return the result of operation
+     */
+    public Status gatewaySubdevOffline(String subProductID, String subDeviceName) {
+        Log.d(TAG, "Try to find " + subProductID + " & " + subDeviceName);
+        TXGatewaySubdev subdev = findSubdev(subProductID, subDeviceName);
+        if (subdev == null) {
+            Log.d(TAG, "Cant find the subdev");
+            subdev = new TXGatewaySubdev(subProductID, subDeviceName);
+        }
+        String topic = GW_OPERATION_PREFIX + mProductId + "/" + mDeviceName;
+
+        Log.d(TAG, "set " + subProductID + " & " + subDeviceName + " to offline");
+
+        // format the payload
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("type", "offline");
+            JSONObject plObj = new JSONObject();
+            String strDev = "[{'product_id':'" + subProductID +"','device_name':'" + subDeviceName + "'}]";
+            JSONArray devs = new JSONArray(strDev);
+            plObj.put("devices", devs);
+            obj.put("payload", plObj);
+        } catch (JSONException e) {
+            return Status.ERROR;
+        }
+        MqttMessage message = new MqttMessage();
+        message.setQos(0);
+        message.setPayload(obj.toString().getBytes());
+        Log.d(TAG, "publish message " + message);
+
+        return super.publish(topic, message, null);
+    }
+
+    private static String sign(String src, String psk) {
+        Mac mac;
+
+        try {
+            mac = Mac.getInstance(HMAC_SHA_256);
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        String hmacSign;
+        SecretKeySpec signKey = new SecretKeySpec(psk.getBytes(), HMAC_SHA_256);
+
+        try {
+            mac.init(signKey);
+            byte[] rawHmac = mac.doFinal(src.getBytes());
+            hmacSign = com.tencent.iot.hub.device.java.core.util.Base64.encodeToString(rawHmac, com.tencent.iot.hub.device.java.core.util.Base64.NO_WRAP);
+            return hmacSign;
+        } catch (InvalidKeyException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public Status gatewayBindSubdev(String subProductID, String subDeviceName, String psk) {
+
+        String topic = GW_OPERATION_PREFIX + mProductId + "/" + mDeviceName;
+
+        // format the payload
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("type", "bind");
+            JSONObject plObj = new JSONObject();
+            JSONObject dev = new JSONObject();
+            dev.put("product_id", subProductID);
+            dev.put("device_name", subDeviceName);
+            int randNum = (int) (Math.random() * 999999);
+            dev.put("random", randNum);
+            long timestamp = System.currentTimeMillis() / 1000;
+            dev.put("timestamp", timestamp);
+            dev.put("signmethod", "hmacsha256");
+            dev.put("authtype", "psk");
+            String text2Sgin = subProductID + subDeviceName + ";" + randNum + ";" + timestamp;
+            dev.put("signature", sign(text2Sgin, psk));
+            JSONArray devs = new JSONArray();
+            devs.put(dev);
+            plObj.put("devices", devs);
+            obj.put("payload", plObj);
+        } catch (JSONException e) {
+            return Status.ERROR;
+        }
+
+        MqttMessage message = new MqttMessage();
+        message.setQos(0);
+        message.setPayload(obj.toString().getBytes());
+        Log.d(TAG, "publish message " + message);
+
+        return super.publish(topic, message, null);
+    }
+
+    public Status gatewayUnbindSubdev(String subProductID, String subDeviceName) {
+
+        String topic = GW_OPERATION_PREFIX + mProductId + "/" + mDeviceName;
+
+        // format the payload
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("type", "unbind");
+            JSONObject plObj = new JSONObject();
+            JSONObject dev = new JSONObject();
+            dev.put("product_id", subProductID);
+            dev.put("device_name", subDeviceName);
+            JSONArray devs = new JSONArray();
+            devs.put(dev);
+            plObj.put("devices", devs);
+            obj.put("payload", plObj);
+        } catch (JSONException e) {
+            return Status.ERROR;
+        }
+
+        MqttMessage message = new MqttMessage();
+        message.setQos(0);
+        message.setPayload(obj.toString().getBytes());
+        Log.d(TAG, "publish message " + message);
+
+        return super.publish(topic, message, null);
+    }
+
+    public Status getGatewaySubdevRealtion() {
+        String topic = GW_OPERATION_PREFIX + mProductId + "/" + mDeviceName;
+
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("type", "describe_sub_devices");
+        } catch (JSONException e) {
+            return Status.ERROR;
+        }
+
+        MqttMessage message = new MqttMessage();
+        message.setQos(0);
+        message.setPayload(obj.toString().getBytes());
+        Log.d(TAG, "publish message " + message);
+
+        return super.publish(topic, message, null);
+    }
+
+    public Status getRemoteConfig() {
+        // format the payload
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("type", "get");
+        } catch (JSONException e) {
+            return Status.ERROR;
+        }
+
+        MqttMessage message = new MqttMessage();
+        // 这里添加获取到的数据
+        message.setPayload(obj.toString().getBytes());
+        message.setQos(1);
+        String topic = String.format("$config/report/%s/%s", mProductId, mDeviceName);
+        return super.publish(topic, message, null);
+    }
+
+    public Status concernConfig() {
+        String subscribeConfigTopic = PRODUCT_CONFIG_PREFIX + mProductId + "/" + mDeviceName;
+        return this.subscribe(subscribeConfigTopic, 1, "subscribe config topic");
+    }
+
+    public Status gatewaySubdevOnline(String subProductID, String subDeviceName) {
+        TXGatewaySubdev subdev = findSubdev(subProductID, subDeviceName);
+        if (subdev == null) {
+            Log.d(TAG, "Cant find the subdev");
+            subdev = new TXGatewaySubdev(subProductID, subDeviceName);
+        }
+        String topic = GW_OPERATION_PREFIX + mProductId + "/" + mDeviceName;
+        Log.d(TAG, "set " + subProductID + " & " + subDeviceName + " to Online");
+
+        // format the payload
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("type", "online");
+            JSONObject plObj = new JSONObject();
+            String strDev = "[{'product_id':'" + subProductID +"','device_name':'" + subDeviceName + "'}]";
+            JSONArray devs = new JSONArray(strDev);
+            plObj.put("devices", devs);
+            obj.put("payload", plObj);
+        } catch (JSONException e) {
+            return Status.ERROR;
+        }
+        addSubdev(subdev);
+
+        MqttMessage message = new MqttMessage();
+        message.setQos(0);
+        message.setPayload(obj.toString().getBytes());
+        Log.d(TAG, "publish message " + message);
+
+        return super.publish(topic, message, null);
+    }
+
+    private boolean consumeGwOperationMsg(String topic, MqttMessage message) {
+        if (!topic.startsWith(GW_OPERATION_RES_PREFIX)) {
+            return false;
+        }
+        Log.d(TAG, "got gate operation messga " + topic + message);
+        String productInfo = topic.substring(GW_OPERATION_RES_PREFIX.length());
+        int splitIdx = productInfo.indexOf('/');
+        String productId = productInfo.substring(0, splitIdx);
+        String devName = productInfo.substring(splitIdx + 1);
+
+        TXGatewaySubdev subdev = findSubdev(productId, devName);
+
+        // this subdev is not managed by me
+        if (subdev == null) {
+            return false;
+        }
+
+        try {
+            byte[] payload = message.getPayload();
+            JSONObject jsonObject = new JSONObject(new String(payload));
+
+            String type = jsonObject.getString("type");
+            if (type.equalsIgnoreCase("online")) {
+                String res = jsonObject.getString("result");
+
+                if (res.equals("0")) {
+                    subdev.setSubdevStatus(Status.SUBDEV_STAT_ONLINE);
+                }
+
+            } else if (type.equalsIgnoreCase("offline")) {
+                String res = jsonObject.getString("result");
+
+                if (res.equals("0")) {
+                    removeSubdev(subdev);
+                }
+            }
+
+        }catch (JSONException e) {
+
+        }
+
+        return true;
+    }
+
+    @Override
+    public void messageArrived(String topic, MqttMessage message) throws Exception {
+        Log.d(TAG, "message received " + topic);
+        if (!consumeGwOperationMsg(topic, message)) {
+            super.messageArrived(topic, message);
+        }
+    }
+
+    @Override
+    public synchronized Status connect(MqttConnectOptions options, Object userContext) {
+        if (mConnectStatus.equals(TXMqttConstants.ConnectStatus.kConnecting)) {
+            TXLog.i(TAG, "The client is connecting. Connect return directly.");
+            return Status.MQTT_CONNECT_IN_PROGRESS;
+        }
+
+        if (mConnectStatus.equals(TXMqttConstants.ConnectStatus.kConnected)) {
+            TXLog.i(TAG, "The client is already connected. Connect return directly.");
+            return Status.OK;
+        }
+
+        this.mConnOptions = options;
+        if (mConnOptions == null) {
+            TXLog.e(TAG, "Connect options == null, will not connect.");
+            return Status.PARAMETER_INVALID;
+        }
+
+        Long timestamp = System.currentTimeMillis()/1000 + 600;
+        String userNameStr = mUserName + ";" + getConnectId() + ";" + timestamp;
+
+        mConnOptions.setUserName(userNameStr);
+
+        if (mSecretKey != null && mSecretKey.length() != 0) {
+            try {
+                String passWordStr = HmacSha256.getSignature(userNameStr.getBytes(), Base64.decode(mSecretKey, Base64.DEFAULT)) + ";hmacsha256";
+                mConnOptions.setPassword(passWordStr.toCharArray());
+            }
+            catch (IllegalArgumentException e) {
+                Log.d(TAG, "Failed to set password");
+            }
+        }
+
+        mConnOptions.setMqttVersion(MqttConnectOptions.MQTT_VERSION_3_1_1);
+
+        IMqttActionListener mActionListener = new IMqttActionListener() {
+            @Override
+            public void onSuccess(IMqttToken token) {
+                TXLog.i(TAG, "onSuccess!");
+                setConnectingState(TXMqttConstants.ConnectStatus.kConnected);
+                mActionCallBack.onConnectCompleted(Status.OK, false, token.getUserContext(), "connected to " + mServerURI);
+                // If the connection is established, subscribe the gateway operation topic
+                String gwTopic = GW_OPERATION_RES_PREFIX + mProductId + "/" + mDeviceName;
+                int qos = TXMqttConstants.QOS1;
+
+                subscribe(gwTopic, qos, "Subscribe GATEWAY result topic");
+                Log.d(TAG, "Connected, then subscribe the gateway result topic");
+
+                if (mMqttLogFlag) {
+                    initMqttLog(TAG);
+                }
+            }
+
+            @Override
+            public void onFailure(IMqttToken token, Throwable exception) {
+                TXLog.e(TAG, exception, "onFailure!");
+                setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+                mActionCallBack.onConnectCompleted(Status.ERROR, false, token.getUserContext(), exception.toString());
+            }
+        };
+
+        if (mMqttClient == null) {
+            try {
+                mPingSender = new TXAlarmPingSender(mContext);
+                mMqttClient = new MqttAsyncClient(mServerURI, mClientId, mMqttPersist, mPingSender);
+                mMqttClient.setCallback(this);
+                mMqttClient.setBufferOpts(super.bufferOpts);
+                mMqttClient.setManualAcks(false);
+            } catch (Exception e) {
+                TXLog.e(TAG, "new MqttClient failed", e);
+                setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+                return Status.ERROR;
+            }
+        }
+
+        try {
+            TXLog.i(TAG, "Start connecting to %s", mServerURI);
+            setConnectingState(TXMqttConstants.ConnectStatus.kConnecting);
+            mMqttClient.connect(mConnOptions, userContext, mActionListener);
+        } catch (Exception e) {
+            TXLog.e(TAG, "MqttClient connect failed", e);
+            setConnectingState(TXMqttConstants.ConnectStatus.kConnectFailed);
+            return Status.ERROR;
+        }
+
+        return Status.OK;
+    }
+}
Index: iot_core/src/test/java/com/qcloud/iot/ExampleUnitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_core/src/test/java/com/qcloud/iot/ExampleUnitTest.java	(date 1606400383024)
+++ iot_core/src/test/java/com/qcloud/iot/ExampleUnitTest.java	(date 1606400383024)
@@ -0,0 +1,17 @@
+package com.qcloud.iot;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
Index: iot_service/src/androidTest/java/com/example/iot_service/ExampleInstrumentedTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- iot_service/src/androidTest/java/com/example/iot_service/ExampleInstrumentedTest.java	(date 1606400383027)
+++ iot_service/src/androidTest/java/com/example/iot_service/ExampleInstrumentedTest.java	(date 1606400383027)
@@ -0,0 +1,26 @@
+package com.example.iot_service;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumentation test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() throws Exception {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getTargetContext();
+
+        assertEquals("com.example.iot_service.test", appContext.getPackageName());
+    }
+}
